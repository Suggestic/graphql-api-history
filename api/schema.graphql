"""Exposes a URL that specifies the behavior of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behavior of this scalar."""
  url: String!
) on SCALAR

"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

type AcknowledgeConversationMessage {
  success: Boolean!
  message: String!
}

input AcknowledgeConversationMessageInput {
  coachId: ID!
  conversationSid: String!
  messageSid: String!
}

enum ActionType {
  INCREASE
  DECREASE
}

enum ActivityLevel {
  """Not active"""
  NOT_ACTIVE

  """Exercise 1-2 times per week"""
  EXERCISE_1_2

  """Exercise 3+ times per week"""
  EXERCISE_3_MORE

  """Exercise 1-2 times per week"""
  EXERCISE_1

  """Exercise 3+ times per week"""
  EXERCISE_2
}

type ActivityLog implements Node {
  id: ID!
  eventName: String!
  userEmail: String
  userName: String
  payload: GenericScalar
  createdAt: DateTime!
}

type ActivityLogConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ActivityLogEdge]!
  count: Int
}

"""A Relay edge containing a `ActivityLog` and its cursor."""
type ActivityLogEdge {
  """The item at the end of the edge"""
  node: ActivityLog

  """A cursor for use in pagination"""
  cursor: String!
}

type AddBiomarker {
  success: Boolean!
  message: String!
  errors: [FormError!]
  biomarker: Biomarker
}

input AddBiomarkerInput {
  name: String!
  category: ID!
  method: String
  description: String
  order: Int = 0
  isVisible: Boolean = true
  range: BiomarkerRangeInput
  optimalRange: BiomarkerRangeInput
  borderlineRange: BiomarkerRangeInput
  units: [ID!]!
  aliases: [BiomarkerAliasInput!]
  normalValues: [GenericScalar!] = ["{}"]
  displayRange: Boolean = true
}

type AddBiomarkerResults {
  success: Boolean!
  message: String!
  errors: [FormError!]
}

input AddBiomarkerResultsInput {
  labTestReportId: ID!
  biomarkers: [BiomarkerResultInput!]!
}

type AddBloodPressureLog {
  success: Boolean!
  message: String!
}

type AddCoachChatConversation {
  success: Boolean!
  message: String!
}

input AddCoachChatConversationInput {
  coachId: ID!
  conversationSid: String!
}

type AddExerciseEntry {
  success: Boolean!
  message: String!
}

type AddFavoriteArticle {
  success: Boolean!
  message: String!
}

type AddFoodLog {
  success: Boolean!
  message: String!
  foodLog: FoodLog
}

type AddHeartRateLog {
  success: Boolean!
  message: String!
}

type AddHRVLog {
  success: Boolean!
  message: String!
}

type AddRecipeItemsToShoppingList {
  success: Boolean!
  message: String!
}

type AddRecipesToShoppingList {
  success: Boolean
  message: String
}

type AddSleepQualityScore {
  success: Boolean!
  message: String!
}

type AddSleepTime {
  success: Boolean!
  message: String!
}

type AddStepsCount {
  success: Boolean!
  message: String!
}

type AddToShoppingList {
  success: Boolean
  message: String
}

type AddUserConsent {
  success: Boolean!
  message: String!
  errors: [FormError!]
}

input AddUserConsentInput {
  consentTypeId: ID!
}

type AddUserToJourney {
  success: Boolean!
  message: String!
}

input AddUserToJourneyInput {
  profile: ID!
  journey: ID!
  portalUser: ID
}

type Adherence {
  score: Float
  color: AdherenceColor
  icon: Icon
  title: String
  reason: String
  isRecommended: Boolean
}

enum AdherenceColor {
  GREEN
  YELLOW
  RED
  BLUE
  GREY
}

type Aggregate implements Node {
  """The ID of the object"""
  id: ID!
  profile: ProfileType!
  aisleName: String
  quantity: Int
  grams: Float
  unit: String
  comment: String
  ingredient: String
  isDone: Boolean!
  isCleared: Boolean!
  updatedAt: DateTime!
  createdAt: DateTime!
  meta: JSONString!
  listitemSet(offset: Int, before: String, after: String, first: Int, last: Int, recipe: ID): ListItemConnection!
  databaseId: String
  aggregateMeta: AggregateMeta
  servingEquivalent: Float
}

type AggregateConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AggregateEdge]!
}

"""A Relay edge containing a `Aggregate` and its cursor."""
type AggregateEdge {
  """The item at the end of the edge"""
  node: Aggregate

  """A cursor for use in pagination"""
  cursor: String!
}

type AggregateMeta {
  aisle: String
  ids: [String]
  idsContribution: [Contribution]
  name: String
  qty: Int
  rawQty: Float
  grams: Float @deprecated(reason: "Not used, will be removed")
}

enum AlertAction {
  ATTEMPTED_FAILED
  CONTACTED
}

enum AlertStatus {
  IN_REVIEW
  REVIEWED
  OUT_OF_RANGE
  OTHER
  FOLLOW_UP
  NO_FOLLOW_UP
  COMPLETED
}

type Answer {
  id: ID
  answer: String
  selected: Boolean
  imageUrl: String
  type: HabitAnswerType!
}

type AnswerCounter {
  total: Int!
  answer: Answer!
}

input AnswersFilterInput {
  questionId: ID
  text: String
}

input AnswerSupplementInput {
  supplementId: ID!
  score: Float!
}

type Appointment {
  id: ID!
  title: String!
  description: String
  meetingUrl: String
  start: DateTime!
  end: DateTime!
  attendees: [Attendee!]!
  status: EventStatus!
  appointmentType: AppointmentType!
  contactType: CalendarContactType!
  sendbirdRoomId: String @deprecated(reason: "Soon it will be removed")
  zoomSessionName: String
  zoomSessionPassword: String
  labTestReports(before: String, after: String, first: Int, last: Int): LabTestReportConnection
  postEventStatus: PostEventStatus
  coach: Coach
  attachments: [AppointmentAttachment!]
}

type AppointmentAttachment {
  id: ID!
  name: String
  url: String!
}

type AppointmentConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppointmentEdge]!
}

type AppointmentCredit {
  id: ID!
  appointmentType: AppointmentType!
  value: Int!
  labTestReports(before: String, after: String, first: Int, last: Int): LabTestReportConnection
}

type AppointmentCredits {
  credits: [AppointmentCredit!]!
}

"""A Relay edge containing a `Appointment` and its cursor."""
type AppointmentEdge {
  """The item at the end of the edge"""
  node: Appointment

  """A cursor for use in pagination"""
  cursor: String!
}

enum AppointmentMultiCoachType {
  INDIVIDUAL
  COLLECTIVE
  ANY_COACH_AVAILABLE
}

type AppointmentType implements Node {
  id: ID!
  title: String!
  numberOfMember: Int!
  durationMin: Int!
  contactType: [String!]!
  multiCoachType: AppointmentMultiCoachType!
  refundableBeforeHours: Int!
}

type AppointmentTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppointmentTypeEdge]!
}

"""A Relay edge containing a `AppointmentType` and its cursor."""
type AppointmentTypeEdge {
  """The item at the end of the edge"""
  node: AppointmentType

  """A cursor for use in pagination"""
  cursor: String!
}

"""A set of limitations per subscription related to an app feature"""
type AppRestriction {
  feature: String!
  limitations: [Limitation!]!
}

input AppUserActivityLogFiltersInput {
  profileId: ID
  eventName: String
}

type ArticleRecommended implements Node {
  valueMax: Float
  valueMin: Float
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
  biomarker: Biomarker!
  article: ContentLibraryType!
  normalValues: [GenericScalar!]
}

type ArticleRecommendedConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ArticleRecommendedEdge]!
}

"""A Relay edge containing a `ArticleRecommended` and its cursor."""
type ArticleRecommendedEdge {
  """The item at the end of the edge"""
  node: ArticleRecommended

  """A cursor for use in pagination"""
  cursor: String!
}

type ArtifactContent {
  title: String!
  body: String!
  footer: String
}

input ArtifactContentInput {
  title: String!
  body: String!
  footer: String
}

type Assessment implements Node {
  title: String!
  description: String
  order: Int!
  icon: String
  interval: Int
  weight: Int
  isDraft: Boolean!
  isPublic: Boolean!
  progressBar: Boolean!
  progressMaxCount: Int!
  hasScore: Boolean!
  bottomProgressBar: Boolean!
  disableLoader: Boolean!
  relativeButtonPosition: Boolean!
  resultsImageUrl: String
  closeButton: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
  questions(offset: Int, before: String, after: String, first: Int, last: Int): AssessmentQuestionConnection
  assessmentType: AssessmentType!
  initialQuestion: AssessmentQuestion
  finalQuestion: AssessmentQuestion
  status: AssessmentStatus
  score: Float
  url: String
  style: GenericScalar
  lastAnsweredQuestion: AssessmentQuestion
}

type AssessmentAnswer implements Node {
  text: String!
  value: String
  isCorrect: Boolean!
  score: Float
  assessmentEnded: Boolean!
  blockOtherAnswers: Boolean!
  triggerEvent: String
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
  nextQuestion: AssessmentQuestion
  attribute: GenericScalar
  isSelected: Boolean
  rankingOrder: Int
  question: AssessmentQuestion
  supplements: [AssessmentAnswerSupplement]
  icon: String
}

type AssessmentAnswerConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AssessmentAnswerEdge]!
}

"""A Relay edge containing a `AssessmentAnswer` and its cursor."""
type AssessmentAnswerEdge {
  """The item at the end of the edge"""
  node: AssessmentAnswer

  """A cursor for use in pagination"""
  cursor: String!
}

type AssessmentAnswerSupplement implements Node {
  supplement: Supplement!
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
  score: Float!
}

type AssessmentAnswerSupplementConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AssessmentAnswerSupplementEdge]!
}

"""A Relay edge containing a `AssessmentAnswerSupplement` and its cursor."""
type AssessmentAnswerSupplementEdge {
  """The item at the end of the edge"""
  node: AssessmentAnswerSupplement

  """A cursor for use in pagination"""
  cursor: String!
}

type AssessmentConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AssessmentEdge]!
}

type AssessmentDynamicQuestion implements Node {
  """The ID of the object"""
  id: ID!
  order: Int!
  dependsOnAnswers: [AssessmentAnswer!]
  parentQuestion: AssessmentQuestion
}

"""A Relay edge containing a `Assessment` and its cursor."""
type AssessmentEdge {
  """The item at the end of the edge"""
  node: Assessment

  """A cursor for use in pagination"""
  cursor: String!
}

type AssessmentQuestion implements Node {
  """The ID of the object"""
  id: ID!
  text: String!
  questionType: QuestionType!
  htmlElement: FormHtmlElement
  isInitialQuestion: Boolean!
  isFinalQuestion: Boolean!
  canSkip: Boolean!
  profileField: AssessmentsQuestionProfileFieldChoices
  helpText: String
  information: String
  finalText: String
  helpTitle: String
  informationTitle: String
  comment: String
  maxOptionsSelected: Int
  minOptionsSelected: Int
  collapsibleHelpText: Boolean!
  finalTitle: String
  finalButton: String
  isExit: Boolean!
  hasDynamicAnswers: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  answers: [AssessmentAnswer!]
  assessment: Assessment
  nextQuestion: AssessmentQuestion
  answerText: String
  attributes: [AssessmentQuestionAttribute!]
  dynamicQuestion: AssessmentDynamicQuestion
}

type AssessmentQuestionAttribute implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  value: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AssessmentQuestionAttributeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AssessmentQuestionAttributeEdge]!
}

"""
A Relay edge containing a `AssessmentQuestionAttribute` and its cursor.
"""
type AssessmentQuestionAttributeEdge {
  """The item at the end of the edge"""
  node: AssessmentQuestionAttribute

  """A cursor for use in pagination"""
  cursor: String!
}

type AssessmentQuestionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AssessmentQuestionEdge]!
}

"""A Relay edge containing a `AssessmentQuestion` and its cursor."""
type AssessmentQuestionEdge {
  """The item at the end of the edge"""
  node: AssessmentQuestion

  """A cursor for use in pagination"""
  cursor: String!
}

input AssessmentsFilterInput {
  title: String
  description: String
  isDraft: Boolean
  isPublic: Boolean
}

"""An enumeration."""
enum AssessmentsQuestionProfileFieldChoices {
  """biological_sex"""
  BIOLOGICAL_SEX

  """birthdate"""
  BIRTHDATE

  """height"""
  HEIGHT

  """starting_weight"""
  STARTING_WEIGHT

  """target_weight"""
  TARGET_WEIGHT

  """weekly_weight_goal"""
  WEEKLY_WEIGHT_GOAL

  """activity_level"""
  ACTIVITY_LEVEL

  """favorite_cuisines"""
  FAVORITE_CUISINES

  """restrictions"""
  RESTRICTIONS

  """custom_attributes"""
  CUSTOM_ATTRIBUTES

  """malnutrition_risk"""
  MALNUTRITION_RISK

  """tube_feeding_oral_intake"""
  TUBE_FEEDING_ORAL_INTAKE

  """program"""
  PROGRAM

  """is_imperial"""
  IS_IMPERIAL

  """phone"""
  USER_PHONE

  """family_size"""
  FAMILY_SIZE
}

enum AssessmentStatus {
  TODO
  DONE
  NEEDS_UPDATE
  IN_PROGRESS
}

enum AssessmentType {
  COMMON
  ON_BOARDING
  DIET_ID
}

type Assistant {
  id: ID!
  name: String!
  mainGoal: String!
  program: ID
  mode: AssistantMode!
  voice: String
  onboarding: Boolean!
  onboardingPrompt: String
  welcomeMessage: String
  initialSuggestedReplies: [String!]!
  chatName: String
  journey: JourneyAssistantType
  chatAvatar: String
}

input AssistantAnalyticFiltersInput {
  startDate: Date
  endDate: Date
}

type AssistantAnalytics {
  currentNumberUserSubscribed: Int!
  totalMessagesSent: Int!
}

input AssistantConversationInput {
  interactionId: ID
  hasConstraints: Boolean!
  hasEscalations: Boolean!
  hasKnowledgeBase: Boolean!
  usingInteractionGoal: Boolean!
  userProfile: ProfileTest!
}

type AssistantConversationResponse {
  id: ID!
  chat: [ChatResponse]
  escalations: [EscalationConversationResponse]
}

input AssistantFiltersInput {
  ids: [String]!
}

type AssistantIngredient {
  name: String
  grams: Float
  quantity: Float
  unit: String
}

enum AssistantMode {
  MANUAL
  AUTO
}

type Attendee {
  email: String!
  status: EventParticipationStatus!
  displayName: String
}

enum AttrDataType {
  STRING
  INT
  FLOAT
  BOOLEAN
}

input AttributeInput {
  name: String!
  value: GenericScalar
  dataType: AttrDataType!
}

type AutoGenerateConversationMessage {
  success: Boolean!
  message: String!
  generatedMessage: String
}

input AutoGenerateConversationMessageInput {
  coachId: ID!
  conversationSid: String!
  assistantId: ID
}

union AvailableChecklistItems = ChecklistItem | SupplementOnPlan | MyChecklistItemOnPlan

"""
The `BigInt` scalar type represents non-fractional whole numeric values.
`BigInt` is not constrained to 32-bit like the `Int` type and thus is a less
compatible type.
"""
scalar BigInt

enum BiologicalSex {
  """MALE"""
  MALE

  """FEMALE"""
  FEMALE
  UNCERTAIN
  UNKNOWN
  PREFER_NOT_TO_DISCLOSE
}

type Biomarker {
  id: ID!
  name: String!
  method: String
  category: BiomarkerCategory!
  units: [BiomarkerUnit!]!
  aliases: [BiomarkerAlias!]
  description: String
  range: BiomarkerRange
  optimalRange: BiomarkerRange
  borderlineRange: BiomarkerRange
  normalValues: [GenericScalar!]
  normalStringValues: JSONString
  displayRange: Boolean
  order: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BiomarkerAlias {
  name: String!
  language: String!
}

input BiomarkerAliasInput {
  name: String!
  language: BiomarkerLanguage!
}

type BiomarkerCategory implements Node {
  name: String!
  parent: BiomarkerCategory
  order: Int
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
}

type BiomarkerCategoryConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BiomarkerCategoryEdge]!
}

"""A Relay edge containing a `BiomarkerCategory` and its cursor."""
type BiomarkerCategoryEdge {
  """The item at the end of the edge"""
  node: BiomarkerCategory

  """A cursor for use in pagination"""
  cursor: String!
}

input BiomarkerCategoryFilterInput {
  isOwned: Boolean
}

input BiomarkerCategoryOrderBy {
  field: BiomarkerCategoryOrderByField!
  order: SortOrder = ASC
}

enum BiomarkerCategoryOrderByField {
  name
  order
  created_at
  updated_at
}

type BiomarkerConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BiomarkerEdge]!
}

"""A Relay edge containing a `Biomarker` and its cursor."""
type BiomarkerEdge {
  """The item at the end of the edge"""
  node: Biomarker

  """A cursor for use in pagination"""
  cursor: String!
}

input BiomarkerFilterInput {
  name: String
  categoryId: ID
}

enum BiomarkerIntervalRange {
  ALL
  OUT_RANGE
  IN_RANGE
  IN_OPTIMAL_RANGE
}

enum BiomarkerLanguage {
  AFRIKAANS
  ALBANIAN
  ARABIC
  CATALAN
  CHINESE
  CROATIAN
  CZECH
  DANISH
  DUTCH
  ENGLISH
  ESTONIAN
  FRENCH
  GERMAN
  HEBREW
  HINDI
  INDONESIAN
  ITALIAN
  JAPANESE
  KOREAN
  POLISH
  PORTUGUESE
  ROMANIAN
  RUSSIAN
  SERBIAN
  SPANISH
  SWEDISH
  THAI
  TURKISH
  UKRAINIAN
  VIETNAMESE
  ZULU
}

type BiomarkerRange {
  max: Float!
  min: Float!
}

input BiomarkerRangeInput {
  max: Float!
  min: Float!
}

input BiomarkerResultInput {
  biomarkerId: ID!
  biomarkerUnitId: ID!
  result: BiomarkerValueInput!
  date: DateTime!
  alert: Boolean
  alertText: String
  displayValue: String
}

input BiomarkerResultsFilterInput {
  categoryId: ID
  biomarkerId: ID
  biomarkerName: String
  intervalRange: BiomarkerIntervalRange = null
}

type BiomarkerUnit implements Node {
  name: String!
  factor: Float!
  alias: String
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
}

type BiomarkerUnitConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BiomarkerUnitEdge]!
}

"""A Relay edge containing a `BiomarkerUnit` and its cursor."""
type BiomarkerUnitEdge {
  """The item at the end of the edge"""
  node: BiomarkerUnit

  """A cursor for use in pagination"""
  cursor: String!
}

enum BiomarkerValueDatatype {
  BOOLEAN
  STRING
  NUMBER
}

input BiomarkerValueInput {
  type: BiomarkerValueDatatype!
  value: GenericScalar!
}

type BloodPressureLog {
  id: ID!
  systolicValue: Int!
  diastolicValue: Int!
  source: SourceType!
  datetime: DateTime!
  createdAt: DateTime!
}

type BloodPressureLogs {
  node: BloodPressureLog
  cursor: String!
}

type BloodPressureLogsConnnection {
  pageInfo: PageInfo!
  edges: [BloodPressureLogs]!
}

type BrandedFoodConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BrandedFoodEdge]!
  count: Int
}

"""A Relay edge containing a `BrandedFood` and its cursor."""
type BrandedFoodEdge {
  """The item at the end of the edge"""
  node: BrandedFoodNode

  """A cursor for use in pagination"""
  cursor: String!
}

type BrandedFoodNode implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  description: String
  dataType: String
  nutrients: [Nutrient!]!
  isGeneric: Boolean!
  isActive: Boolean!
  isCore: Boolean!
  tags: [String!]!
  isOpenFoodFacts: Boolean
  foodDataId: String
  brandOwner: String
  brandName: String
  householdServingFulltext: String
  brandedFoodCategory: String
  servingSizeUnit: String!
  servingSize: Float!
  gtinUpc: String
  calories: Float
}

type BrandedFoodNodeProxy {
  brandedFood: BrandedFoodNode!
}

type BulkCreateEntries {
  success: Boolean!
  message: String!
}

enum CalendarContactType {
  VIDEO_CALL
  GOOGLE_MEET
  ZOOM
  PHONE_CALL
}

type CaloriesPerServing {
  protein: Float
  carbs: Float
  fat: Float
  dha: Float
  dpa: Float
  epa: Float
  ala: Float
  saturatedFat: Float
  monounsaturatedFat: Float
  polyunsaturatedFat: Float
  transFat: Float
  omega3: Float
}

type CancelAppointment {
  success: Boolean!
  message: String!
  appointment: Appointment
}

type CancelPodcast {
  success: Boolean!
  message: String!
  podcast: Podcast!
}

type ChangeMealPlannerDayMeal {
  recipe: Recipe
  success: Boolean
}

enum ChatContentType {
  TEXT
  ARTIFACT
}

type ChatFile implements Node {
  """The ID of the object"""
  id: ID!
  result: String
  createdAt: DateTime!
  updatedAt: DateTime!
  pdfFile: String!
  status: ChatFileStatus!
}

enum ChatFileStatus {
  IN_PROGRESS
  DONE
  ERROR
  CANCELLED
}

type ChatMessage implements Node {
  """The ID of the object"""
  id: ID!
  message: String!
  brand: String!
  template: String!
  timestamp: DateTime!
  product: String
  blogs: String
  region: String
  language: String
  audioStyle: String
  role: ChatMessageRole!
  image: String
  pdfFile: String
  content: [MessageContent!]
  edits: [ChatMessageHistory!]
}

type ChatMessageConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ChatMessageEdge]!
}

input ChatMessageContentInput {
  type: ChatContentType!
  value: String!
  artifact: ArtifactContentInput = null
}

"""A Relay edge containing a `ChatMessage` and its cursor."""
type ChatMessageEdge {
  """The item at the end of the edge"""
  node: ChatMessage

  """A cursor for use in pagination"""
  cursor: String!
}

type ChatMessageHistory {
  id: ID!
  editor: ID!
  editedAt: DateTime!
  changes: [MessageContent!]
}

enum ChatMessageRole {
  USER
  ASSISTANT
}

input ChatMessagesFilterInput {
  threadId: ID!
}

type ChatResponse {
  id: ID!
  sender: String!
  content: String!
  createdAt: DateTime!
}

type CheckIntake {
  success: Boolean!
  message: String!
}

type CheckItemDirections {
  mealTime: TimeOfDay!
  monday: Boolean!
  tuesday: Boolean!
  wednesday: Boolean!
  thursday: Boolean!
  friday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  id: ID!
}

type Checklist {
  name: String!
  icon: String
  items: [ChecklistItem!]!
}

type ChecklistItem {
  id: ID!
  title: String!
  image: String!
  checked: Boolean!
  subtitle: String
  category: String
}

type CheckoutCreate {
  success: Boolean!
  message: String!
  webUrl: String
}

input CheckoutCreateInput {
  supplementsInCart: [SupplementCartItem!]!
}

type CheckTodayFoodEntry {
  success: Boolean!
  message: String!
}

type CheckTodaySupplementEntry {
  success: Boolean!
  message: String!
}

type ClearShoppingList {
  success: Boolean
}

type ClearShoppingListCheckedItems {
  success: Boolean
}

"""An enumeration."""
enum ClientApiThirdPartyGoalGoalChoices {
  """DAILY_RECAP"""
  DAILY_RECAP

  """DAILY_MOOD"""
  DAILY_MOOD

  """WEIGHT_TRACKER"""
  WEIGHT_TRACKER

  """MP_MEAL_TRACKER"""
  MP_MEAL_TRACKER

  """HYDRATION_TRACKER"""
  HYDRATION_TRACKER

  """TODAY_FOOD"""
  TODAY_FOOD

  """TODAY_SUPPLEMENT"""
  TODAY_SUPPLEMENT

  """FOOD_LOGS"""
  FOOD_LOGS

  """STEPS_TRACKER"""
  STEPS_TRACKER

  """EXERCISE_TRACKER"""
  EXERCISE_TRACKER

  """PLAN_SUPPLEMENT"""
  PLAN_SUPPLEMENT

  """MY_CHECKLIST_TRACKER"""
  MY_CHECKLIST_TRACKER

  """SLEEP_TIME_TRACKER"""
  SLEEP_TIME_TRACKER

  """SLEEP_QUALITY_SCORE_TRACKER"""
  SLEEP_QUALITY_SCORE_TRACKER

  """HRV_TRACKER"""
  HRV_TRACKER

  """HEART_RATE_TRACKER"""
  HEART_RATE_TRACKER

  """PLAN_SUPPLEMENTS_MY_CHECKLIST"""
  PLAN_SUPPLEMENTS_MY_CHECKLIST

  """FOOD_LOG_MEAL_TRACKER"""
  FOOD_LOG_MEAL_TRACKER

  """BLOOD_PRESSURE_TRACKER"""
  BLOOD_PRESSURE_TRACKER

  """SYMPTOM_TRACKER"""
  SYMPTOM_TRACKER
}

type Coach implements Node {
  name: String!
  showAllMembers: Boolean!
  id: ID!
  appointments(start: DateTime, end: DateTime, timezone: String): [Appointment!]!
  avatarUrl: String
  email: String!
  sendbirdId: String
  irad: String
  irmp: String
  isPrimary: Boolean
  coachTypes(offset: Int, before: String, after: String, first: Int, last: Int): CoachTypeConnection
  coachTeams(offset: Int, before: String, after: String, first: Int, last: Int): CoachTeamConnection
}

input CoachActivityLogFiltersInput {
  start: DateTime
  end: DateTime
  coachId: ID
  profileId: ID
  eventName: String
}

type CoachConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CoachEdge]!
  count: Int
}

"""A Relay edge containing a `Coach` and its cursor."""
type CoachEdge {
  """The item at the end of the edge"""
  node: Coach

  """A cursor for use in pagination"""
  cursor: String!
}

type CoachTeam implements Node {
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
  coaches: [Coach!]
}

type CoachTeamConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CoachTeamEdge]!
}

"""A Relay edge containing a `CoachTeam` and its cursor."""
type CoachTeamEdge {
  """The item at the end of the edge"""
  node: CoachTeam

  """A cursor for use in pagination"""
  cursor: String!
}

input CoachTeamsFilterInput {
  name: String
}

type CoachType implements Node {
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
  coaches: [Coach!]
}

type CoachTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CoachTypeEdge]!
}

"""A Relay edge containing a `CoachType` and its cursor."""
type CoachTypeEdge {
  """The item at the end of the edge"""
  node: CoachType

  """A cursor for use in pagination"""
  cursor: String!
}

input CoachTypesFilterInput {
  name: String
  mealPlanTemplateId: ID
}

type CommonFoodConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CommonFoodEdge]!
  count: Int
}

"""A Relay edge containing a `CommonFood` and its cursor."""
type CommonFoodEdge {
  """The item at the end of the edge"""
  node: CommonFoodNode

  """A cursor for use in pagination"""
  cursor: String!
}

type CommonFoodNode implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  description: String
  dataType: String
  nutrients: [Nutrient!]!
  isGeneric: Boolean!
  isActive: Boolean!
  isCore: Boolean!
  tags: [String!]!
  isOpenFoodFacts: Boolean
  foodDataId: String
  portions: [Portion]
}

type CommonFoodNodeProxy {
  commonFood: CommonFoodNode!
}

enum CommunicationChannel {
  SMS
  CHAT
  WHATSAPP
}

type ComponentGoal {
  component: EntryType!
  goal: Int!
}

type Condition implements Node {
  """The ID of the object"""
  id: ID!
  attrName: String
  dataType: DataType
  term: String
  bool: Boolean
  lte: Float
  gte: Float
  supplementSet(offset: Int, before: String, after: String, first: Int, last: Int): SupplementConnection!
  biomarkerId: ID
}

type ConfirmFoodLogAssistant {
  success: Boolean!
  message: String!
}

input ConfirmFoodLogAssistantInput {
  id: ID!
  mealTime: MealTime!

  """Food name used for this recipe"""
  recipeName: String

  """Date to log food on, defaults to now()"""
  date: Date
}

type ConnectedSource {
  sourceId: Int!
  createdAt: DateTime!
  id: ID!
  sourceName: SourceType!

  """Indicates if it is the selected active source."""
  currentActive: Boolean!
}

type ConsentType implements Node {
  name: String!

  """The ID of the object"""
  id: ID!
}

type ConstraintConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ConstraintEdge]!
  count: Int
}

"""A Relay edge containing a `Constraint` and its cursor."""
type ConstraintEdge {
  """The item at the end of the edge"""
  node: ConstraintType

  """A cursor for use in pagination"""
  cursor: String!
}

input ConstraintFilters {
  assistant: ID
}

type ConstraintType implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  description: String!
  assistant: Assistant!
}

type ContentCategoryType implements Node {
  slug: String!
  order: Int!
  lang: JSONString
  subtitle: String
  contentlibrarySet(offset: Int, before: String, after: String, first: Int, last: Int): ContentLibraryTypeConnection! @deprecated(reason: "Not used. Renamed to contentLibrary")
  id: ID!
  databaseId: String
  image: String
  subcategories: [ContentCategoryType!]
  tags: [ContentTagType!]
  contentLibrary(offset: Int, before: String, after: String, first: Int, last: Int): ContentLibraryTypeConnection!
  name: String
}

type ContentCategoryTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ContentCategoryTypeEdge]!
}

"""A Relay edge containing a `ContentCategoryType` and its cursor."""
type ContentCategoryTypeEdge {
  """The item at the end of the edge"""
  node: ContentCategoryType

  """A cursor for use in pagination"""
  cursor: String!
}

input ContentLibraryOrderBy {
  field: ContentLibraryOrderByField!
  order: SortOrder = ASC
}

enum ContentLibraryOrderByField {
  created_at
  popularity
}

type ContentLibraryType implements Node {
  isBlocked: Boolean!
  updatedAt: DateTime
  createdAt: DateTime
  order: Int!
  isFeatured: Boolean!
  lang: JSONString!
  id: ID!
  databaseId: String
  isFavorite: Boolean!
  categories: [ContentCategoryType]
  tags: [ContentTagType!]
  programs: [Program!]
  title: String
  subTitle: String
  imageUrl: String
  sourceUrl: String
  isRead: Boolean
  personalizedContent: Boolean
}

type ContentLibraryTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ContentLibraryTypeEdge]!
}

"""A Relay edge containing a `ContentLibraryType` and its cursor."""
type ContentLibraryTypeEdge {
  """The item at the end of the edge"""
  node: ContentLibraryType

  """A cursor for use in pagination"""
  cursor: String!
}

type ContentTagType implements Node {
  id: ID!
  name: String!
}

type ContentTagTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ContentTagTypeEdge]!
}

"""A Relay edge containing a `ContentTagType` and its cursor."""
type ContentTagTypeEdge {
  """The item at the end of the edge"""
  node: ContentTagType

  """A cursor for use in pagination"""
  cursor: String!
}

type Contribution {
  eqv: Float
  databaseId: String
}

type ConversationSummary {
  text: String
}

type CPC {
  benefits: String
  description: String
  name: String
  simpleExamples: [String]
  matchCustomAttribute: Boolean
}

type CPCIngredient {
  cpcName: String
  type: String
  priority: String
  softmax: String
}

type CPCIngredientGroup {
  avoid: [CPC]
  decrease: [CPC]
  increase: [CPC]
}

type CPCRule {
  avoid: [CPC]
  decrease: [CPC]
  increase: [CPC]
}

"""An enumeration."""
enum CpcsProgramEnergyNutrientEquationChoices {
  """Harris Benedict"""
  HARRIS_BENEDICT

  """Oncology"""
  ONCOLOGY
}

type CreateAnswer {
  success: Boolean!
  message: String!
  errors: [FormError!]
  answer: AssessmentAnswer
}

input CreateAnswerInput {
  text: String!
  questionId: ID!
  value: String
  isCorrect: Boolean
  score: Int
  nextQuestionId: ID
  attribute: AttributeInput
  assessmentEnded: Boolean = false
  blockOtherAnswers: Boolean = false
  supplements: [AnswerSupplementInput!]
  icon: Upload
  triggerEvent: String
}

type CreateAppointment {
  success: Boolean!
  message: String!
  appointment: Appointment
}

input CreateAppointmentInput {
  coach: ID
  appointmentType: ID!
  datetime: DateTime!
  contactType: CalendarContactType = VIDEO_CALL
  note: String
  postEventStatus: PostEventStatus
}

type CreateArticleRecommended {
  success: Boolean!
  message: String!
  errors: [FormError!]
  articleRecommended: ArticleRecommended
}

input CreateArticleRecommendedInput {
  biomarkerId: ID!
  range: BiomarkerRangeInput = null
  normalValues: [GenericScalar!]
  articleId: ID!
}

type CreateAssessment {
  success: Boolean!
  message: String!
  errors: [FormError!]
  assessment: Assessment
}

input CreateAssessmentInput {
  title: String!
  description: String
  assessmentType: AssessmentType = COMMON
  icon: Upload
  order: Int = 0
  interval: Int
  weight: Int
  isDraft: Boolean = true
  isPublic: Boolean = true
  progressBar: Boolean = true
  hasScore: Boolean = true
  bottomProgressBar: Boolean = false
  progressMaxCount: Int = 0
  closeButton: Boolean = true
  style: GenericScalar
  disableLoader: Boolean
  relativeButtonPosition: Boolean
  resultsImageUrl: String
}

type CreateAssistant {
  success: Boolean!
  message: String!
  errors: [FormError!]
  assistant: Assistant
}

type CreateAssistantConversationMessage {
  success: Boolean!
  message: String!
  response: AssistantConversationResponse
}

input CreateAssistantInput {
  name: String!
  mainGoal: String!
  program: ID
  mode: AssistantMode = MANUAL
  voice: String
  onboarding: Boolean
  onboardingPrompt: String
  welcomeMessage: String
  initialSuggestedReplies: [String!]
  chatAvatar: Upload
  chatName: String
}

type CreateBiomarkerCategory {
  success: Boolean!
  message: String!
  errors: [FormError!]
  biomarkerCategory: BiomarkerCategory
}

input CreateBiomarkerCategoryInput {
  name: String!
  parent: ID
  order: Int
}

type CreateCoachTeam {
  success: Boolean!
  message: String!
  errors: [FormError!]
  coachTeam: CoachTeam
}

input CreateCoachTeamInput {
  name: String!
  description: String
  coaches: [ID!]
}

type CreateCoachType {
  success: Boolean!
  message: String!
  errors: [FormError!]
  coachType: CoachType
}

input CreateCoachTypeInput {
  name: String!
  description: String
  coaches: [ID!]
}

type CreateContentCategory {
  success: Boolean!
  message: String!
  contentCategory: ContentCategoryType
  errors: [FormError!]
}

input CreateContentCategoryInput {
  name: String!
  order: Int!

  """Subcategories IDs."""
  subcategories: [ID]
  image: Upload

  """Content tags IDs."""
  tags: [ID]
  lang: GenericScalar
  subtitle: String
}

type CreateContentLibrary {
  success: Boolean!
  message: String!
  contentLibrary: ContentLibraryType
  errors: [FormError!]
}

input CreateContentLibraryInput {
  title: String!
  imageUrl: String!
  subTitle: String
  isBlocked: Boolean
  isFeatured: Boolean
  order: Int

  """Categories IDs."""
  categories: [ID]
  sourceUrl: String

  """Content tags IDs."""
  tags: [ID]

  """Programs IDs."""
  programs: [ID]
  lang: GenericScalar = "{}"
}

type CreateContentTag {
  success: Boolean!
  message: String!
  contentTag: ContentTagType
  errors: [FormError!]
}

type CreateDailyRecapAnswer {
  success: Boolean!
  message: String!
  dailyRecapAnswer: DailyRecapAnswer
  errors: [FormError!]
}

input CreateDailyRecapAnswerInput {
  answer: String!
  type: String!
  lang: GenericScalar = "{}"
}

type CreateDailyRecapEntry {
  success: Boolean!
  message: String!
}

type CreateDailyRecapQuestion {
  success: Boolean!
  message: String!
  dailyRecapQuestion: ThirdPartyDailyRecapQuestion
  errors: [FormError!]
}

input CreateDailyRecapQuestionInput {
  question: String!
  imageUrl: String
  program: ID

  """Answer IDs."""
  answers: [ID]!
  lang: GenericScalar
}

input CreatedAtRangeInput {
  start: Date!
  end: Date!
}

type CreateDayJourney {
  success: Boolean!
  message: String!
  dayJourney: DayJourneyType
}

type CreateDietPreference {
  success: Boolean!
  message: String!
  errors: [FormError!]
  dietPreference: DietPreference
}

input CreateDietPreferenceInput {
  name: String!
  restrictions: [ID!]
}

input CreateDynamicQuestionInput {
  dependsOnAnswers: [ID!]!
  order: Int = 0
  parentQuestionId: ID
}

type CreateExpressTrack {
  success: Boolean!
  message: String!
}

type CreateGooglePlayTransaction {
  success: Boolean
  message: String
}

type CreateGuardrail {
  success: Boolean!
  message: String!
  errors: [FormError!]
  guardrail: Guardrail
}

input CreateGuardrailInput {
  name: String!
  description: String!
  message: String!
  assistant: ID!
}

type CreateInteraction {
  success: Boolean!
  message: String!
  interaction: InteractionType
}

type CreateJourney {
  success: Boolean!
  message: String!
  journey: JourneyAssistantType
}

type CreateJourneyChat {
  success: Boolean!
  message: String!
  response: JourneyChatResponse
}

type CreateKnowledgeBase {
  success: Boolean!
  message: String!
  errors: [FormError!]
  knowledgeBase: KnowledgeBaseType
}

type CreateKnowledgeBaseChat {
  success: Boolean!
  message: String!
  response: KnowledgeBaseChatResponse
}

type CreateLabTestReport {
  success: Boolean!
  message: String!
  report: LabTestReport
}

type CreateMealEntry {
  success: Boolean!
  message: String!
}

type CreateMealLogMutation {
  success: Boolean
  databaseId: String
}

type CreateMealPlanTemplate {
  success: Boolean!
  message: String!
  mealPlan: MealPlanTemplate
}

type CreateMessageHistoryEntry {
  success: Boolean!
  message: String!
  messageHistory: ChatMessageHistory
}

input CreateMessageHistoryEntryInput {
  message: ID!
  editor: ID!
  changes: [ChatMessageContentInput!]!
}

type CreateMyBrandedFood {
  success: Boolean!
  message: String!
}

input CreateMyBrandedFoodInput {
  brandOwner: String!
  brandName: String
  servingSizeUnit: String!
  servingSize: Float!
  gtinUpc: String!
  name: String!
  description: String
  nutrients: [NutrientInput!]!
  householdServingFulltext: String
  brandedFoodCategory: String
}

type CreateMyChecklistItem {
  success: Boolean!
  message: String!
  myChecklistItem: MyChecklistItem
}

type CreateMyChecklistItemLog {
  success: Boolean!
  message: String!
}

type CreateMyCommonFood {
  success: Boolean!
  message: String!
}

input CreateMyCommonFoodInput {
  name: String
  description: String
  nutrients: [NutrientInput]
  portions: [PortionInput!]!
}

type CreateMyRecipe {
  success: Boolean!
  message: String!
  recipe: UserRecipe
}

input CreateMyRecipeInput {
  ingredientLines: [String!]!
  name: String!
  numberOfServings: Int!
  instructions: [String!]
  ingredients: [IngredientAmount!]!
  mealTimes: [MealTime!]!
  courses: [String!]!
  cuisines: [String!]!
  language: Language = EN
  mainImage: String = null
  squareImage: String = null
  tags: [String!] = null
  text: String = null
  totalTime: String = null
  totalTimeInSeconds: Int = null
}

type CreateNote {
  success: Boolean!
  message: String!
  note: Note
}

type CreateOwnMealLogMutation {
  success: Boolean
  message: String
  databaseId: String
}

type CreateOwnRecipe {
  success: Boolean
  databaseId: String
}

type CreatePodcast {
  success: Boolean!
  message: String!
  podcast: Podcast
  errors: [FormError!]
}

input CreatePodcastInput {
  message: ID!
  hostName: String!
  guestName: String!
  hostVoice: String!
  guestVoice: String!
  language: String!
  script: String!
  audioStyle: String
}

type CreateProfileBiomarkers {
  success: Boolean
}

type CreateProfileCustomAttributes {
  success: Boolean
  errors: [ErrorType]
}

type CreateQuestion {
  success: Boolean!
  message: String!
  errors: [FormError!]
  question: AssessmentQuestion
}

input CreateQuestionAnswerInput {
  text: String!
  value: String
  isCorrect: Boolean = false
  score: Int
  nextQuestionId: ID
  attribute: AttributeInput
}

input CreateQuestionInput {
  assessmentId: ID!
  text: String!
  questionType: QuestionType = SINGLE_SELECT
  htmlElement: FormHtmlElement = null
  isInitialQuestion: Boolean
  isFinalQuestion: Boolean
  canSkip: Boolean = false
  nextQuestionId: ID
  information: String
  helpText: String
  profileField: ProfileField = null
  answers: [CreateQuestionAnswerInput!]
  attributes: [ID!]
  finalText: String
  helpTitle: String
  informationTitle: String
  maxOptionsSelected: Int
  minOptionsSelected: Int
  collapsibleHelpText: Boolean = false
  finalButton: String
  finalTitle: String
  comment: String
  isExit: Boolean = false
  hasDynamicAnswers: Boolean = false
  dynamicQuestion: CreateDynamicQuestionInput
}

type CreateQuizResult {
  success: Boolean
  errors: [ErrorType]
}

input CreateSPInput {
  coach: ID
  name: String!
  startDate: Date!
  overview: String
  nutrition: String
  exercise: String
  resources: String
  visibility: Boolean
  isActive: Boolean
  protocols: [SPProtocolInput!]
  supplements: [SingleSupplementActivableProtocolInput!]
}

type CreateSupplement {
  success: Boolean!
  message: String!
  supplement: Supplement
}

input CreateSupplementConditionInput {
  biomarkerId: ID
  dataType: DataType
  attrName: String
  term: String
  bool: Boolean
  lte: Float
  gte: Float
}

input CreateSupplementInput {
  description: String
  images: [String!]
  directionsOfUseText: String
  sizeCount: Int
  externalId: String
  sku: String
  storeId: String
  shopifyVariantId: String
  shopifyParentId: String
  instructions: String
  ingredients: String
  supplementFacts: String
  name: String!
  category: String!
  mainImage: String!
  brand: String!
  servingName: String!
  directionsOfUse: [DirectionsOfUseInput!]
  type: SupplementType
  conditions: [ID!]
  createConditions: [CreateSupplementConditionInput!]
}

type CreateSupplementPlan {
  success: Boolean!
  message: String!
  supplementPlan: SupplementPlan
}

type CreateSupplementRecommended {
  success: Boolean!
  message: String!
  errors: [FormError!]
  supplementRecommended: SupplementRecommended
}

input CreateSupplementRecommendedInput {
  biomarkerId: ID!
  range: BiomarkerRangeInput = null
  normalValues: [GenericScalar!]
  supplementId: ID!
}

type CreateSymptomLog {
  success: Boolean!
  message: String!
}

type CreateThirdPartyGoal {
  success: Boolean!
  message: String!
  goal: ThirdPartyGoal
}

input CreateThirdPartyGoalInput {
  goal: TrackerComponent!
  value: Float!
}

type CreateTwilioAccessToken {
  success: Boolean!
  message: String!
  jwt: String
}

type CreateUser {
  success: Boolean!
  message: String!
  user: User
}

type CreateUserTracker {
  success: Boolean!
  message: String!
  tracker: UserTracker
  errors: [FormError!]
}

input CreateUserTrackerInput {
  tracker: TrackerComponent!
  goal: Float
  source: SourceType = null
}

type CreateWebhookEndpoint {
  success: Boolean!
  message: String!
  endpoint: WebhookEndpoint
}

input CreateWebhookEndpointInput {
  url: String!
  eventTypes: [WebhookEventType!]!
}

type CreateWeightEntry {
  success: Boolean
  message: String
}

type Cuisine implements Node {
  id: ID!
  name: String!
}

type CuisineConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CuisineEdge]!
}

"""A Relay edge containing a `Cuisine` and its cursor."""
type CuisineEdge {
  """The item at the end of the edge"""
  node: Cuisine

  """A cursor for use in pagination"""
  cursor: String!
}

type DailyChecklist {
  name: String!
  icon: String
  days: [DayChecklistItems!]!
}

type DailyExerciseTime {
  type: String
  totalTime: Int! @deprecated
  floatTotalTime: Float!
}

type DailyMoodSummary {
  question: DailyQuestion
  answersStats: [AnswerCounter!]!
}

type DailyQuestion {
  id: ID
  question: String
  done: Boolean
  imageUrl: String
  answers: [Answer]
  title: String
  isDefault: Boolean!
  group: GroupQuestion
}

type DailyRecap {
  date: Date!
  questions: [DailyQuestion!]!
}

type DailyRecapAnswer implements Node {
  """The ID of the object"""
  id: ID!
  type: String!
  imageUrl: String
  lang: JSONString!
  answer: String
}

enum DailyRecapQuestionGroup {
  MOOD
}

type DailyStreakScore {
  date: Date!
  score: Float!
}

type Dashboard {
  components: [EntryType!]!
  goals: [ComponentGoal!]!
}

type DashboardPDFType {
  id: ID!
  name: String!
  pdfUrl: String
  databaseId: String
}

enum DataType {
  RANGE
  NUMBER
  TERM
  BOOL
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

type Day {
  closing: String
  description: String
  opening: String
}

type DayChecklistItems {
  date: Date!
  items: [ChecklistItem!]!
}

input DayJourneyInput {
  journeyId: ID
  order: Int!
  skipped: Boolean!
  interactions: [InteractionInput]!
}

type DayJourneyType {
  order: BigInt!
  skipped: Boolean!
  id: ID
  interactions: [InteractionType]
}

enum DayStatus {
  PERFECT_DAY
  REGULAR_DAY
  GOOD_DAY
  EMPTY_DAY
}

type DebugMealPlanVariables {
  kcal: Int!
  conditions: DebugMPConditions
  format: [String!]
  skipIds: [String!]
  restrictions: [String!]
}

type DebugMPConditions {
  procnt: Int
  chocdf: Int
  fat: Int
  omega3: Int
  increase: [String!]
  decrease: [String!]
  include: [String!]
  distribution: DebugMPMealTimeValues
  maxPrepTimeMinutes: DebugMPMealTimeValues
  maxIngredientsCount: DebugMPMealTimeValues
  maxEnercKcal: Int
  maxNumOfServings: Int
  maxServingWeight: Int
  minServingWeight: Int
}

type DebugMPMealTimeValues {
  breakfast: Int
  dinner: Int
  lunch: Int
  snack: Int
}

type DeleteAnswer {
  success: Boolean!
  message: String!
  answer: AssessmentAnswer
}

type DeleteAppointmentAttachment {
  success: Boolean!
  message: String!
}

type DeleteArticleRecommended {
  success: Boolean!
  message: String!
  articleRecommended: ArticleRecommended
}

type DeleteAssessment {
  success: Boolean!
  message: String!
  assessment: Assessment
}

type DeleteAssistant {
  success: Boolean!
  message: String!
}

type DeleteBiomarker {
  success: Boolean!
  message: String!
  biomarker: Biomarker
}

type DeleteBiomarkerCategory {
  success: Boolean!
  message: String!
  biomarkerCategory: BiomarkerCategory
}

type DeleteBloodPressureLog {
  success: Boolean!
  message: String!
}

type DeleteCoachTeam {
  success: Boolean!
  message: String!
  coachTeam: CoachTeam
}

type DeleteCoachType {
  success: Boolean!
  message: String!
  coachType: CoachType
}

type DeleteCondition {
  success: Boolean!
  message: String!
  condition: Condition
}

type DeleteContentCategory {
  success: Boolean!
  message: String!
  contentCategory: ContentCategoryType
}

type DeleteContentLibrary {
  success: Boolean!
  message: String!
  contentLibrary: ContentLibraryType
}

type DeleteContentTag {
  success: Boolean!
  message: String!
  contentTag: ContentTagType
}

type DeleteDailyRecapAnswer {
  success: Boolean!
  message: String!
  dailyRecapAnswer: DailyRecapAnswer
}

type DeleteDailyRecapEntry {
  success: Boolean!
  message: String!
}

type DeleteDailyRecapQuestion {
  success: Boolean!
  message: String!
  dailyRecapQuestion: ThirdPartyDailyRecapQuestion
}

type DeleteDayJourney {
  success: Boolean!
  message: String!
}

type DeleteDietPreference {
  success: Boolean!
  message: String!
  dietPreference: DietPreference
}

type DeleteDynamicQuestion {
  success: Boolean!
  message: String!
  dynamicQuestion: AssessmentDynamicQuestion
}

type DeleteExerciseEntry {
  success: Boolean!
  message: String!
}

type DeleteExpressTrack {
  success: Boolean!
  message: String!
}

type DeleteFoodLog {
  success: Boolean!
  message: String!
}

type DeleteGuardrail {
  success: Boolean!
  message: String!
  guardrail: Guardrail
}

type DeleteHeartRateLog {
  success: Boolean!
  message: String!
}

type DeleteHRVLog {
  success: Boolean!
  message: String!
}

type DeleteInteraction {
  success: Boolean!
  message: String!
  interaction: InteractionType
}

type DeleteKnowledgeBase {
  success: Boolean!
  message: String!
}

type DeleteLabTestReport {
  success: Boolean!
  message: String!
  report: LabTestReport
}

type DeleteMealPlanTemplate {
  success: Boolean!
  message: String!
  mealPlan: MealPlanTemplate
}

type DeleteMyBrandedFood {
  success: Boolean!
  message: String!
}

type DeleteMyChecklistItem {
  success: Boolean!
  message: String!
  myChecklistItem: MyChecklistItem
}

type DeleteMyChecklistItemLog {
  success: Boolean!
  message: String!
}

type DeleteMyCommonFood {
  success: Boolean!
  message: String!
}

type DeleteMyRecipe {
  success: Boolean!
  message: String!
}

type DeleteNote {
  success: Boolean!
  message: String!
  note: Note
}

type DeleteQuestion {
  success: Boolean!
  message: String!
  question: AssessmentQuestion
}

type DeleteSleepQualityScore {
  success: Boolean!
  message: String!
}

type DeleteSleepTime {
  success: Boolean!
  message: String!
}

type DeleteStepsCount {
  success: Boolean!
  message: String!
}

type DeleteSupplementRecommended {
  success: Boolean!
  message: String!
  supplementRecommended: SupplementRecommended
}

type DeleteSymptomLog {
  success: Boolean!
  message: String!
}

type DeleteThirdPartyGoal {
  success: Boolean!
  message: String!
}

type DeleteUserTracker {
  success: Boolean!
  message: String!
  tracker: UserTracker
}

type DeleteWebhookEndpoint {
  success: Boolean!
  message: String!
  endpoint: WebhookEndpoint
}

type DeleteWeightEntry {
  success: Boolean!
  message: String!
}

type Depletion implements Node {
  description: String
  referenceUrl: String
  foods: String
  foodsSourceUrl: String
  updatedAt: DateTime!
  createdAt: DateTime!

  """The ID of the object"""
  id: ID!
  restrictions: [Restriction!]
  ingredient: DrugIngredient
}

type DepletionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DepletionEdge]!
}

"""A Relay edge containing a `Depletion` and its cursor."""
type DepletionEdge {
  """The item at the end of the edge"""
  node: Depletion

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum DialogsDialogCollectionTypeChoices {
  """bool"""
  BOOL

  """char"""
  CHAR

  """int"""
  INT

  """datetime"""
  DATETIME
}

"""An enumeration."""
enum DialogsDialogValueTypeChoices {
  """Integer"""
  INTEGER

  """Float"""
  FLOAT

  """String"""
  STRING

  """None"""
  NULL

  """Date"""
  DATE

  """Datetime"""
  DATETIME
}

type DialogType {
  id: ID!
  name: String!
  defaultJump: String!
  jumpFalse: String!
  taskList: TaskListType
  title: String
  video: String!
  endpoint: String!
  valueType: DialogsDialogValueTypeChoices
  type: String!
  action: String!
  deviceAction: String!
  field: String!
  catalog: String!
  collectionType: DialogsDialogCollectionTypeChoices
  htmlUrl: String
  messages: [String!]
  attachment: GenericScalar
  uploadedVideo: String
  databaseId: String
  videoThumbnail: String
}

enum DietaryTag {
  VEGETARIAN
  DAIRY_FREE
  GLUTEN_FREE
  PLANT_BASED
  VEGAN
}

type DietPreference {
  name: String!
  restrictions: [UUID!]!
  id: ID!
}

input DirectionsOfUseInput {
  quantity: Float!
  timeOfDay: TimeOfDay!
}

type Drug implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  updatedAt: DateTime!
  createdAt: DateTime!
}

type DrugGroup implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  updatedAt: DateTime!
  createdAt: DateTime!
  drugs: [Drug!]
  depletions(offset: Int, before: String, after: String, first: Int, last: Int): DepletionConnection
  interactions(offset: Int, before: String, after: String, first: Int, last: Int): InteractionConnection
}

type DrugGroupConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DrugGroupEdge]!
}

"""A Relay edge containing a `DrugGroup` and its cursor."""
type DrugGroupEdge {
  """The item at the end of the edge"""
  node: DrugGroup

  """A cursor for use in pagination"""
  cursor: String!
}

type DrugIngredient {
  id: ID!
  name: String!
  groups: [String!]
}

input DrugNutrientInteractionsFilterInput {
  name: String
}

type DuplicateMealPlanTemplate {
  success: Boolean!
  message: String!
  mealPlan: MealPlanTemplate
}

type EmailCustomFields implements Node {
  """The ID of the object"""
  id: ID!
  inviteCoachSubject: String
  inviteCoachSignature: String
  inviteCoachHtml: String
  inviteCoachText: String
  inviteMemberSubject: String
  inviteMemberHtml: String
  inviteMemberText: String
  coachingBaseUrl: String
  appointmentConfirmationSubject: String
  appointmentConfirmationHtml: String
  appointmentConfirmationText: String
  appointmentUpdatedSubject: String
  appointmentUpdatedHtml: String
  appointmentUpdatedText: String
  appointmentCanceledSubject: String
  appointmentCanceledHtml: String
  appointmentCanceledText: String
  magicLinkSubject: String
  magicLinkHtml: String
  magicLinkText: String
  resetPasswordSubject: String
  resetPasswordText: String
  resetPasswordHtml: String
  autoReplyFeedbackSubject: String
  autoReplyFeedbackText: String
  autoReplyFeedbackHtml: String
  enableBccToCoaches: Boolean!
}

type Entry {
  value: Float
  date: Date
  source: SourceType
  createdAt: DateTime
}

enum EntryType {
  WEIGHT_TRACKER
  HYDRATION_TRACKER
  DAILY_RECAP
  DAILY_MOOD
  MP_MEAL_TRACKER
  TODAY_FOOD
  TODAY_SUPPLEMENT
  FOOD_LOGS
  STEPS_TRACKER
  EXERCISE_TRACKER
  MY_CHECKLIST_TRACKER
  SLEEP_TIME_TRACKER
  SLEEP_QUALITY_SCORE_TRACKER
  HRV_TRACKER
  HEART_RATE_TRACKER
  PLAN_SUPPLEMENT
  PLAN_SUPPLEMENTS_MY_CHECKLIST
  FOOD_LOG_MEAL_TRACKER
  BLOOD_PRESSURE_TRACKER
  SYMPTOM_TRACKER
}

type ErrorType {
  field: String!
  messages: [String!]!
}

type EscalationConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EscalationEdge]!
  count: Int
}

type EscalationConversationResponse {
  name: String
  flagged: Boolean
}

"""A Relay edge containing a `Escalation` and its cursor."""
type EscalationEdge {
  """The item at the end of the edge"""
  node: EscalationType

  """A cursor for use in pagination"""
  cursor: String!
}

input EscalationFilters {
  assistant: ID
}

type EscalationType implements Node {
  name: String!
  redirectTo: WellnessgptEscalationRedirectToChoices!
  description: String!
  flagMessage: Boolean!
  alertCoach: Boolean!
  autoRespond: Boolean!
  autoRespondText: String
  assistant: Assistant!

  """The ID of the object"""
  id: ID!
}

enum EventParticipationStatus {
  NEEDS_ACTION
  ACCEPTED
  DECLINED
  TENTATIVE
  UNKNOWN
}

enum EventStatus {
  TENTATIVE
  CONFIRMED
  CANCELLED
  UNKNOWN
}

enum EventType {
  SESSION
}

type ExerciseEntriesConnection {
  pageInfo: PageInfo!
  edges: [ExerciseEntryEdge]!
  dailyGoal: Int!
  totalTime: Int! @deprecated
  floatTotalTime: Float!
  totalTimePerType: [DailyExerciseTime!]!
  latestEntry: DateTime
}

type ExerciseEntry {
  id: ID!
  datetime: DateTime!
  createdAt: DateTime!
  type: ExerciseType
  intensity: ExerciseIntensity
  durationMinutes: Int! @deprecated
  floatDurationMinutes: Float!
  source: SourceType
  calories: Int

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
}

type ExerciseEntryEdge {
  node: ExerciseEntry
  cursor: String!
}

input ExerciseEntryInput {
  datetime: DateTime!
  type: ExerciseType
  intensity: ExerciseIntensity
  durationMinutes: PositiveInt!
  source: SourceType
}

enum ExerciseIntensity {
  VIGOROUS
  MODERATE
  LOW
}

enum ExerciseType {
  ACTIVE
  CARDIO
  STRENGTH
  WORKOUT_ROUTINE
  RECOVERY
  OTHER
  WALK
  CYCLE
  JOG_OR_RUN
  SWIM
  BREATHWORK
  STRETCH
  YOGA
  PILATES
  HIKE
  DANCE
  HOUSEHOLD_CHORES
  YARD_WORK
  PHYSICAL_THERAPY_EXERCISES
  IN_BED_EXERCIES
}

type ExpressMealTrack {
  id: ID!
  mealTime: MealTime!
  calories: Float!
  proteins: Float!
  carbs: Float!
  fats: Float!
  fibers: Float
  imageUrl: String
  foodName: String
  datetime: DateTime!
  createdAt: DateTime!
}

type ExpressMealTrackConnection {
  pageInfo: PageInfo!
  edges: [ExpressMealTrackEdge]!
}

type ExpressMealTrackEdge {
  node: ExpressMealTrack
  cursor: String!
}

input FeedbackInput {
  executionId: ID!
  rating: WorkflowExecutionLogRating!
  comment: String
}

union Food = BrandedFoodNodeProxy | CommonFoodNodeProxy | GenericFoodNodeProxy | MyBrandedFoodProxy | MyCommonFoodProxy | RecipeProxy | UserRecipeProxy | MealProxy

type FoodAnalysis implements Node {
  """The ID of the object"""
  id: ID!
  profile: ProfileType!
  image: String
  foodDescription: String
  status: GptFoodAnalysisStatusChoices!
  errorMessage: String
  errorCode: Int
  serviceResponse: JSONString
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum FoodCategory {
  BRANDED
  COMMON
  MY_COMMON
  MY_BRANDED
  USER_RECIPE
  MEAL_PLAN_MEAL
  RECIPE
  COMMON_NCC
  GENERIC_FOOD
}

input FoodFilter {
  id: ID
  externalId: String
  name: String
  barcode: String
  tags: [String]
  mealTime: MealTime
  ingredients: [String!]
  nutrients: [NutrientFilterInput!]

  """Join the filters with an AND logical operator"""
  must: [FoodFilter!]

  """Join the filters with an OR logical operator"""
  should: [FoodFilter!]

  """Join the filters with an AND logical operator"""
  mustNot: [FoodFilter!]
}

type FoodLog {
  id: ID!
  date: Date!
  mealTime: MealTime!
  foodId: ID!
  grams: Float
  servings: Float
  time: Time
  portionModifier: String
  type: FoodCategory!
  food: Food!
}

type FoodLogAssistant {
  id: ID!
  ingredients: [AssistantIngredient]
}

type FoodLogConnection {
  pageInfo: PageInfo!
  edges: [FoodLogEdge]!
  macros: [MacroNutrientLogged!]!
}

type FoodLogEdge {
  node: FoodLog
  cursor: String!
}

type FoodProduct {
  name: String
  longDesc: String
  displayName: String
  brand: String
  mealType: MealType
  databaseId: String
  serving: Int
  servings: [Servings]

  """True when product is verified by Suggestic"""
  isVerified: Boolean

  """True if product is missing a property like name or nutrients"""
  isIncomplete: Boolean
  nutritionalInfo: NutritionalInfo
}

type FormError {
  field: String
  messages: [String!]
}

enum FormHtmlElement {
  INPUT
  CHECKBOX
  RADIO_BUTTON
  SELECT
  TEXTAREA
}

type GenerateMagicLink {
  success: Boolean!
  message: String!
  magicLink: String
}

type GenerateMealPlan {
  mealPlan: [MealPlanDay!]

  """True if the meal plan was successfully generated"""
  success: Boolean

  """
  Error logs or info message. See "success"
  """
  message: String
}

type GenerateShopifyMultipassUrl {
  success: Boolean!
  message: String!
  url: String
}

input GenerateShopifyMultipassUrlInput {
  returnTo: String
}

type GenerateSimpleMealPlan {
  """True if the meal plan was successfully generated"""
  success: Boolean

  """
  Error logs or info message. See "success"
  """
  message: String
}

input GenerateVideoZoomTokenInput {
  sessionName: String!
  sessionKey: String
  role: VideoZoomRole

  """Max length 10 characters"""
  password: String

  """Max length 15 characters"""
  userIdentity: String
  clientMutationId: String
}

type GenerateVideoZoomTokenPayload {
  success: Boolean!
  message: String!
  token: String
  clientMutationId: String
}

type GenericFoodConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [GenericFoodEdge]!
  count: Int
}

"""A Relay edge containing a `GenericFood` and its cursor."""
type GenericFoodEdge {
  """The item at the end of the edge"""
  node: GenericFoodNode

  """A cursor for use in pagination"""
  cursor: String!
}

type GenericFoodNode implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  description: String
  dataType: String
  nutrients: [Nutrient!]!
  isGeneric: Boolean!
  isActive: Boolean!
  isCore: Boolean!
  tags: [String!]!
  isOpenFoodFacts: Boolean
  foodDataId: String
  portions: [Portion]
  brandOwner: String
  brandName: String
  brandedFoodCategory: String
  servingSizeUnit: String!
  servingSize: Float!
  barcode: String
  calories: Float
  isCommon: Boolean
  isBranded: Boolean
}

type GenericFoodNodeProxy {
  genericFood: GenericFoodNode!
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

input GeoBoundingBox {
  """Eg. -122.162104"""
  topLeftLon: Float

  """Eg. 37.450766"""
  topLeftLat: Float

  """Eg. -122.151554"""
  bottomRightLon: Float

  """Eg. 37.435659"""
  bottomRightLat: Float
}

type GeoPoint {
  lat: Float
  lon: Float
}

type GooglePlayTransactionType implements Node {
  id: ID!
  createdAt: DateTime
  rawData: GenericScalar
  databaseId: String
}

type GooglePlayTransactionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [GooglePlayTransactionTypeEdge]!
}

"""A Relay edge containing a `GooglePlayTransactionType` and its cursor."""
type GooglePlayTransactionTypeEdge {
  """The item at the end of the edge"""
  node: GooglePlayTransactionType

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum GptFoodAnalysisStatusChoices {
  """Pending"""
  PENDING

  """Processing"""
  PROCESSING

  """Completed"""
  COMPLETED

  """Failed"""
  FAILED
}

enum GroupQuestion {
  MOOD
}

type Guardrail implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  description: String!
  message: String!
  assistant: Assistant!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GuardrailConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [GuardrailEdge]!
}

"""A Relay edge containing a `Guardrail` and its cursor."""
type GuardrailEdge {
  """The item at the end of the edge"""
  node: Guardrail

  """A cursor for use in pagination"""
  cursor: String!
}

input GuardrailFilterInput {
  assistant: ID
}

enum HabitAnswerType {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

type HardDeleteAppUserProfile {
  success: Boolean
  message: String
  email: String
}

type HardDeleteMyProfileMutation {
  success: Boolean
  email: String
}

input HeartRateEntryInput {
  value: PositiveInt!
  datetime: DateTime!
  source: SourceType!
}

type HeartRateLog {
  id: ID!
  value: Float!
  source: SourceType!
  timestamp: DateTime!
  createdAt: DateTime!

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
}

type HeartRateLogs {
  node: HeartRateLog
  cursor: String!
}

type HeartRateLogsConnnection {
  pageInfo: PageInfo!
  edges: [HeartRateLogs]!
  average: Float!
  minimum: Float!
  maximum: Float!
  latestEntry: DateTime
}

input HistoricalBiomarkerResultsFilterInput {
  categoryId: ID
  biomarkerId: ID
  biomarkerName: String
  intervalRange: BiomarkerIntervalRange = null
  labTestReportId: ID
}

type Hours {
  monday: Day
  tuesday: Day
  wednesday: Day
  thursday: Day
  friday: Day
  saturday: Day
  sunday: Day
}

input HRVEntryInput {
  value: PositiveFloat!
  datetime: DateTime!
  source: SourceType!
}

type HrvLog {
  id: ID!
  value: Float!
  source: SourceType!
  timestamp: DateTime!

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
  createdAt: DateTime!
}

type HrvLogs {
  node: HrvLog
  cursor: String!
}

type HrvLogsConnnection {
  pageInfo: PageInfo!
  edges: [HrvLogs]!
  average: Float!
  latestEntry: DateTime
}

type Hydration {
  isToday: Boolean
  date: Date
  quantity: Int
  goal: Int
  source: SourceType

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
}

input HydrationEntryInput {
  date: Date!
  quantity: Float!
  source: SourceType
}

enum Icon {
  CROSS
  UNKNOWN
  ALERT
}

input ImageAssistantInput {
  image: Upload!
}

type Ingredient {
  name: String
  confirmed: Boolean
  cpc: String
  type: String
  priority: Float
}

input IngredientAmount {
  foodId: ID!
  grams: Float
  milliliters: Float
}

type IngredientFoodFormat {
  foodId: String!
  name: String!
  grams: Float
  milliliters: Float
}

type IngredientLine {
  ingredient: String
  ingredientLine: String
  quantity: String
  unit: String
  other: String
  comment: String
}

type insightFields {
  highlight: String!
  text: String!
  description: String!
}

type InsightsByCategory {
  category: InsightsCategory!
  fields: insightFields
}

enum InsightsCategory {
  SLEEP
  STEPS
}

enum IntakeCategory {
  FOOD
  SUPPLEMENT
  PLAN_SUPPLEMENT
  MY_CHECKLIST_ITEM
}

type IntakesChecklist {
  name: String!
  icon: String
  days: [IntakesChecklistDay!]!
}

type IntakesChecklistDay {
  date: Date!
  items: [AvailableChecklistItems!]!
}

type Interaction implements Node {
  description: String
  referenceUrl: String
  foods: String
  foodsSourceUrl: String
  updatedAt: DateTime!
  createdAt: DateTime!

  """The ID of the object"""
  id: ID!
  restrictions: [Restriction!]
  ingredient: DrugIngredient
}

type InteractionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [InteractionEdge]!
}

"""A Relay edge containing a `Interaction` and its cursor."""
type InteractionEdge {
  """The item at the end of the edge"""
  node: Interaction

  """A cursor for use in pagination"""
  cursor: String!
}

input InteractionInput {
  order: Int!
  interaction: String!
  goal: String!
  deliveryTime: Time
}

type InteractionType {
  order: BigInt!
  interaction: String!
  goal: String!
  deliveryTime: Time!
  id: ID
  dayJourneyId: ID
}

input IntValueByMealTime {
  breakfast: Int
  dinner: Int
  lunch: Int
  snack: Int
}

input ItemDirectionsOfUseInput {
  mealTime: TimeOfDay!
  monday: Boolean
  tuesday: Boolean
  wednesday: Boolean
  thursday: Boolean
  friday: Boolean
  saturday: Boolean
  sunday: Boolean
}

type JourneyAssistantType {
  id: ID
  sendWelcomeMessage: Boolean!
  welcomeMessage: String
  dayJourney: [DayJourneyType]
}

type JourneyAssistantTypeResponse {
  success: Boolean!
  message: String!
  journey: JourneyAssistantType
}

type JourneyChatResponse {
  id: ID!
  userMessage: String!
  response: String!
}

type JourneyDialogType {
  id: ID!
  dashboard: JourneyType!
  dialog: DialogType!
  sortIndex: Int!
  databaseId: String
}

input JourneyInput {
  assistantId: ID!
  dayJourney: [DayJourneyInput]!
  sendWelcomeMessage: Boolean
  welcomeMessage: String
}

type JourneyProfileType implements Node {
  id: ID!
  updatedAt: DateTime
  createdAt: DateTime
  dashboard: JourneyType!
  profile: ProfileType!
  status: JourneyStatus
  databaseId: String
  subJourneys: [JourneyProfileType!]!
}

type JourneyProfileTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [JourneyProfileTypeEdge]!
}

"""A Relay edge containing a `JourneyProfileType` and its cursor."""
type JourneyProfileTypeEdge {
  """The item at the end of the edge"""
  node: JourneyProfileType

  """A cursor for use in pagination"""
  cursor: String!
}

enum JourneyStatus {
  CLOSE
  OPEN
  FINISH
}

type JourneyType {
  id: ID!
  program: Program
  daysIntoProgram: Int!
  pdfs: [String!]!
  title: String
  subTitle: String
  pdfsRel: [DashboardPDFType!]!
  subJourneys: [JourneyType!]!
  header: String!
  externalUrl: String!
  dashboardDialogs: [JourneyDialogType!]!
  databaseId: String
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

type KBSearchResult {
  text: String
  score: Float
  keywords: [String]
  document: String
  label: String
}

type KBSearchResults {
  results: [KBSearchResult]
}

enum KnowledgeBaseCategory {
  PRODUCT
  SUPPORT
  GENERAL
}

type KnowledgeBaseChatResponse {
  id: ID!
  userMessage: String!
  response: String!
}

enum KnowledgeBaseRefreshRate {
  DAILY
  WEEKLY
  MONTHLY
}

type KnowledgeBaseResponse {
  success: Boolean!
  message: String!
  knowledgeBase: KnowledgeBaseType
}

type KnowledgeBaseType {
  name: String!
  url: String
  sitemapUrl: String
  pdfFile: String
  pdfUrl: String
  txt: String
  taskStatus: WellnessgptKnowledgeBaseTaskStatusChoices!
  metadata: JSONString
  preProcess: Boolean!
  lastCrawledAt: DateTime
  id: ID
  sitemapUrls: [SitemapUrlType]
  category: KnowledgeBaseCategory
  refreshRate: KnowledgeBaseRefreshRate
}

type LabTestReport {
  id: ID!
  testName: String!
  testDate: DateTime
  labName: String!
  reportPdf: String
  title: String
  isVisible: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  orderingPhysician: String
  externalId: String
  orderId: String
  sampleCollectionDate: Date
  requisitionId: String
  productId: String
  status: LabTestReportStatus
  description: String
  image: String
  alert: Boolean
  alertText: String
  alertStatus: AlertStatus
  alertAction: AlertAction
  videoUrl: String
  imageUrl: String
  userEmail: String
}

type LabTestReportConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [LabTestReportEdge]!
}

"""A Relay edge containing a `LabTestReport` and its cursor."""
type LabTestReportEdge {
  """The item at the end of the edge"""
  node: LabTestReport

  """A cursor for use in pagination"""
  cursor: String!
}

enum LabTestReportStatus {
  CREATED
  ORDERED
  FULFILLED
  ERROR
  RETURNED_TO_LAB
  RESULTS_READY
  PROCESS_COMPLETE
  RESULTS_DELIVERED
}

enum Language {
  EN
  ES
  NL
  AR
  EN_GB
  DE
  CS
  IT
}

"""Details describing a feature limitation's subscription and periodicity"""
type Limitation {
  limit: Int!
  level: String!
  subscriptionId: ID!
  periodicity: String!
}

type LinkUserAssessment {
  success: Boolean!
  message: String!
  userAssessment: Assessment
}

input LinkUserAssessmentInput {
  assessmentId: ID!
}

type ListItem implements Node {
  """The ID of the object"""
  id: ID!
  recipeName: String
  profile: ProfileType!
  aisleName: String
  grams: Float
  comment: String
  ingredientLine: String
  ingredient: String!
  isDone: Boolean!
  isCleared: Boolean!
  parse: JSONString!
  recipeServings: Int
  numberOfServings: Int
  aggregation(offset: Int, before: String, after: String, first: Int, last: Int): AggregateConnection!
  updatedAt: DateTime!
  createdAt: DateTime!
  quantity: String
  unit: String
  quantityMetric: String
  unitMetric: String

  """List of possible ingredient line parsing errors."""
  errors: [String]
  databaseId: String
  recipeId: String
  floatQuantity: Float
  mainImage: String
}

type ListItemConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ListItemEdge]!
}

"""A Relay edge containing a `ListItem` and its cursor."""
type ListItemEdge {
  """The item at the end of the edge"""
  node: ListItem

  """A cursor for use in pagination"""
  cursor: String!
}

type LocationAutocomplete {
  zipcode: String
  city: String
  state: String
  timezone: Int
  daylightSavingsTimeFlag: Boolean
  suggest: String
  location: GeoPoint
}

type Logger implements Node {
  """The ID of the object"""
  id: ID!
  user: String
  profileId: String
  userId: String
  program: String
  isPremium: Boolean
  restrictions: [String]
  adherenceScore: Float
  statusCode: String
  method: String
  path: String
  host: String
  uri: String
  requestGet: GenericScalar
  requestPost: GenericScalar
  requestBody: String
  response: GenericScalar
  location: [Float]
  indexedAt: DateTime
}

type LoggerConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [LoggerEdge]!
}

"""A Relay edge containing a `Logger` and its cursor."""
type LoggerEdge {
  """The item at the end of the edge"""
  node: Logger

  """A cursor for use in pagination"""
  cursor: String!
}

type LoginUser {
  accessToken: String
  refreshToken: String
}

type LogRecipeIngredient {
  id: String!
  mealType: MealType!
  quantity: Float!
  serving: Int!
  name: String
}

type MacroGoals {
  name: String

  """Basal Metabolic Rate"""
  bmr: Int

  """Total Daily Energy Expenditure"""
  tdee: Int

  """Caloric Deficit"""
  cd: Int

  """Daily Caloric Intake Goal"""
  dcig: Int

  """Body Mass Index Goal"""
  bmi: Int
  isUserGoal: Boolean
  carbs: MacroNutrientGoal
  protein: MacroNutrientGoal
  fat: MacroNutrientGoal
  netcarbs: MacroNutrientGoal
}

type MacroNutrientGoal {
  goal: Float
  logged: Float
  left: Float
  color: String
  upperLimit: Float
  lowerLimit: Float
}

type MacroNutrientLogged {
  value: Int!
  goal: Int
  name: String!
}

input MacroNutrientsRangeInput {
  """Amount in kcal"""
  proteinCalories: Range

  """Amount in kcal"""
  fatCalories: Range

  """Amount in kcal"""
  carbsCalories: Range

  """Amount in kcal"""
  calories: Range

  """Amount in gr"""
  protein: Range

  """Amount in gr"""
  fat: Range

  """Amount in gr"""
  carbs: Range

  """Amount in gr"""
  sugar: Range

  """Amount in gr"""
  fiber: Range

  """Amount in gr"""
  saturatedFat: Range

  """Amount in gr"""
  monounsaturatedFat: Range

  """Amount in gr"""
  polyunsaturatedFat: Range

  """Amount in gr"""
  transFat: Range

  """Amount in mg"""
  cholesterol: Range

  """Amount in mg"""
  sodium: Range

  """Amount in mg"""
  potassium: Range

  """Amount in I"""
  vitaminA: Range

  """Amount in mg"""
  vitaminB6: Range

  """Amount in mcg"""
  vitaminB12: Range

  """Amount in mg"""
  vitaminC: Range

  """Amount in mcg"""
  vitaminD: Range

  """Amount in mg"""
  vitaminE: Range

  """Amount in mg"""
  calcium: Range

  """Amount in mg"""
  iron: Range

  """Amount in gr"""
  netcarbs: Range

  """Amount in gr"""
  dha: Range

  """Amount in gr"""
  dpa: Range

  """Amount in gr"""
  epa: Range

  """Amount in gr"""
  ala: Range
}

type MarkContentAsReadOrUnread {
  success: Boolean!
  message: String!
  errors: [FormError!]
}

input MarkContentAsReadOrUnreadInput {
  contentLibraryId: ID!
  markAsRead: Boolean!
}

type Meal {
  id: String
  recipe: Recipe
  meal: String
  numOfServings: Int
  maxNumOfServings: Int
  calories: Float
}

type MealBalanceIndexScore {
  score: Int
  message: String
  errors: [String!]
}

type MealCustomPlannerDays {
  day1: [MealPlanDayRecipe]
  day2: [MealPlanDayRecipe]
  day3: [MealPlanDayRecipe]
  day4: [MealPlanDayRecipe]
  day5: [MealPlanDayRecipe]
  day6: [MealPlanDayRecipe]
  day7: [MealPlanDayRecipe]
  day8: [MealPlanDayRecipe]
}

type MealLog implements Node {
  """The ID of the object"""
  id: ID!
  databaseId: String
  date: Date
  userPid: String
  mealType: MealType
  mealTime: MealTime
  mealTypeDisplayName: String
  mealDatabaseId: String
  quantity: Float
  adherence: Float

  """non-null when the meal log is a recipe"""
  recipe: Recipe
  nutrients: Nutrients @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  createdAt: DateTime
  updatedAt: DateTime
  extraInfo: String
  name: String
  serving: Int
  servings: [Servings]
  nutrientsFull: NutrientsFull @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  macrosLog: Nutrients
  brand: String
  timestamp: DateTime
  isNew: Boolean
  ingredients: [LogRecipeIngredient]
  isVerified: Boolean
  barcode: String
  secondaryInfoText: String
  nutritionalInfo: NutritionalInfo
  servingWeight: Float
}

type MealLogConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [MealLogEdge]!
}

"""A Relay edge containing a `MealLog` and its cursor."""
type MealLogEdge {
  """The item at the end of the edge"""
  node: MealLog

  """A cursor for use in pagination"""
  cursor: String!
}

type MealLogMacroAggs {
  chocdf: Float
  fat: Float
  sugar: Float
  procnt: Float
  fibtg: Float
  netcarbs: Float
  calories: Float
}

type MealPlanDay {
  id: ID!
  date(useDatetime: Boolean): String
  day: Int
  calories: Float
  fat: Float
  protein: Float
  carbs: Float
  meals: [Meal]
}

type MealPlanDayRecipe {
  programDate: Date
  recipe: Recipe
  mealTime: String
}

enum MealPlanDiversity {
  HIGH
  MEDIUM
  LOW
}

type MealPlannerDays {
  day1: MealPlannerDayTime
  day2: MealPlannerDayTime
  day3: MealPlannerDayTime
  day4: MealPlannerDayTime
  day5: MealPlannerDayTime
  day6: MealPlannerDayTime
  day7: MealPlannerDayTime
  day8: MealPlannerDayTime
}

type MealPlannerDayTime {
  programDate: Date
  breakfast: [Recipe]
  lunch: [Recipe]
  snack: [Recipe]
  dinner: [Recipe]
}

enum MealPlannerQueryType {
  RAW
  DAY_AGGREGATE
  SUGGESTIONS
}

type MealPlanTemplate implements Node {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  name: String!
  description: String!
  isPublic: Boolean!
  days: [MealPlanDay!]!
  coachId: ID
  coachName: String
  coachTypes(offset: Int, before: String, after: String, first: Int, last: Int): CoachTypeConnection
}

type MealPlanTemplateConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [MealPlanTemplateEdge]!
}

"""A Relay edge containing a `MealPlanTemplate` and its cursor."""
type MealPlanTemplateEdge {
  """The item at the end of the edge"""
  node: MealPlanTemplate

  """A cursor for use in pagination"""
  cursor: String!
}

type MealProxy {
  meal: Meal!
}

enum MealTime {
  BREAKFAST
  LUNCH
  DINNER
  SNACK
}

type MealTrack {
  mealId: ID!
  meal: Meal!
  value: MealTrackStatus!
  date: Date!
}

enum MealTrackStatus {
  SKIPPED
  ATE
  OTHER_FOLLOWING
  OTHER_NOT_FOLLOWING
  DELETE
}

enum MealType {
  RECIPE
  MENU_ITEM
  USDA_MEAL
  OWN_RECIPE
  OWN_ITEM
  BRANDED_FOOD
  COMMON_FOOD
  MY_BRANDED_FOOD
  MY_COMMON_FOOD
  MEAL_PLAN_MEAL
  USER_RECIPE
  COMMON_NCC
  GENERIC_FOOD
  EXPRESS_TRACK
}

type MenuItem implements Node {
  """The ID of the object"""
  id: ID!
  databaseId: String
  restaurantId: String
  restaurantName: String
  createdAt: DateTime
  updatedAt: DateTime
  indexedAt: DateTime
  menu: String
  sectionName: String
  name: String
  isActive: Boolean
  description: String
  minPrice: Float
  maxPrice: Float
  portionSize: String
  isAnnotated: Boolean
  isIndexed: Boolean
  isValidated: Boolean
  trustMe: Boolean
  deciderSource: String
  deciderVersion: Int
  language: String
  course: String @deprecated(reason: "use `courses` a menu item can have more than one course")
  ingredients: [Ingredient]
  mayHave: [Ingredient]
  programs: [String]
  programsIds: [String]
  confirmedIngredients: [String]
  tags: [String]
  isSourceActive: Boolean
  annotation: GenericScalar
  parent: String
  mealTags: [String]
  usersFavorite: [String]
  favoritesCount: Int
  isUserFavorite: Boolean
  nutrients: Nutrients @deprecated(reason: "use `nutritional_info`")
  type: String
  courses: [String]
  programScore: Float
  nutritionalInfo: NutritionalInfo
  hasNutrients: Boolean
  adherence: Adherence
  isRecommended: Boolean
  restaurant: Restaurant
  menuImage: String
  price: Float
  rating0To100: Int
  ratingCount: Int
}

type MenuItemConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [MenuItemEdge]!
}

"""A Relay edge containing a `MenuItem` and its cursor."""
type MenuItemEdge {
  """The item at the end of the edge"""
  node: MenuItem

  """A cursor for use in pagination"""
  cursor: String!
}

type MergeUser {
  success: Boolean!
  message: String!
  errors: [FormError!]
}

input MergeUserInput {
  """The ID of the user whose profile data will be merged"""
  userOrigin: ID!

  """The ID of the user who will receive the merged data"""
  userTarget: ID!
}

type MessageContent {
  type: ChatContentType!
  value: String!
  artifact: ArtifactContent
}

input MessageInput {
  assistantId: ID!
  userMessage: String!
}

type Money {
  amount: Float!
  currencyCode: String!
}

input MPTCustomOptionsInput {
  program: ID
  calories: Int

  """Percentage between 0 and 100"""
  fatPerc: Int

  """Percentage between 0 and 100"""
  carbsPerc: Int

  """Percentage between 0 and 100"""
  proteinPerc: Int
  format: [MealTime!]
}

input MPTFromDaysInput {
  profileId: ID!
  fromDate: Date!
  toDate: Date!
}

input MPTFromScratchDayInput {
  meals: [MPTFromScratchMealInput!]!
}

input MPTFromScratchInput {
  days: [MPTFromScratchDayInput!]!
}

input MPTFromScratchMealInput {
  recipeId: ID!
  mealType: MealTime!
  servings: Int
}

"""Meals variety in a generate meal plan request"""
enum MPVariety {
  LOW
  MEDIUM
  HIGH
}

type Mutation {
  createPodcast(input: CreatePodcastInput!): CreatePodcast
  cancelPodcast(id: ID!): CancelPodcast
  createWebhookEndpoint(input: CreateWebhookEndpointInput!): CreateWebhookEndpoint
  deleteWebhookEndpoint(id: ID!): DeleteWebhookEndpoint
  updateWebhookEndpoint(input: UpdateWebhookEndpointInput!): UpdateWebhookEndpoint
  createAssistant(input: CreateAssistantInput!): CreateAssistant
  updateAssistant(input: UpdateAssistantInput!): UpdateAssistant
  deleteAssistant(id: ID!): DeleteAssistant
  createKnowledgeBase(assistantId: ID!, category: KnowledgeBaseCategory, metadata: GenericScalar, name: String!, pdfFile: Upload, preProcess: Boolean = true, refreshRate: KnowledgeBaseRefreshRate, sitemapUrl: String, txt: String, url: String): CreateKnowledgeBase
  deleteKnowledgeBase(assistantId: ID!, id: ID!): DeleteKnowledgeBase
  updateRefreshRateKnowledgeBase(input: UpdateRefreshRateKnowledgeBaseInput!): UpdateRefreshRateKnowledgeBase
  createJourney(input: JourneyInput!): CreateJourney
  updateJourney(input: UpdateJourneyInput!): UpdateJourney
  createDayJourney(input: DayJourneyInput!): CreateDayJourney
  deleteDayJourney(id: ID!): DeleteDayJourney
  createInteraction(dayJourneyId: ID!, deliveryTime: Time!, goal: String!, interaction: String!, order: Int!): CreateInteraction
  updateInteraction(deliveryTime: Time!, goal: String!, id: ID!, interaction: String!, order: Int!): UpdateInteraction
  deleteInteraction(interactionId: ID!): DeleteInteraction
  addUserToJourney(input: AddUserToJourneyInput!): AddUserToJourney
  removeUserFromJourney(input: RemoveUserFromJourneyInput!): RemoveUserFromJourney
  createAssistantConversationMessage(assistantConversationInput: AssistantConversationInput!, assistantId: ID!, isInitial: Boolean!, language: String, profileId: ID!, toneOfVoice: String, useLongTermMemory: Boolean, userMessage: String!): CreateAssistantConversationMessage
  createJourneyChat(assistantId: ID!, interactionId: ID!, userMessage: String!): CreateJourneyChat
  createKnowledgeBaseChat(input: MessageInput!): CreateKnowledgeBaseChat
  autoGenerateConversationMessage(input: AutoGenerateConversationMessageInput!): AutoGenerateConversationMessage
  acknowledgeConversationMessage(input: AcknowledgeConversationMessageInput!): AcknowledgeConversationMessage
  storeConversationSummary(input: StoreConversationSummaryInput!): StoreConversationSummary
  createGuardrail(input: CreateGuardrailInput!): CreateGuardrail
  updateGuardrail(input: UpdateGuardrailInput!): UpdateGuardrail
  deleteGuardrail(id: ID!): DeleteGuardrail
  createTwilioAccessToken: CreateTwilioAccessToken
  startChatConversation(input: StartChatConversationInput!): StartChatConversationPayload
  removeCoachChatConversation(input: RemoveCoachChatConversationInput!): RemoveCoachChatConversation
  addCoachChatConversation(input: AddCoachChatConversationInput!): AddCoachChatConversation
  reassignChatConversation(input: ReassignChatConversationInput!): ReassignChatConversation
  submitFeedback(input: FeedbackInput!): SubmitFeedback
  createMessageHistoryEntry(input: CreateMessageHistoryEntryInput!): CreateMessageHistoryEntry
  processChatFile(input: ProcessChatFileInput!): ProcessChatFile
  createMyBrandedFoods(input: CreateMyBrandedFoodInput!): CreateMyBrandedFood
  createMyCommonFoods(input: CreateMyCommonFoodInput!): CreateMyCommonFood
  updateMyBrandedFood(id: ID!, input: UpdateMyBrandedFoodInput!): UpdateMyBrandedFood
  updateMyCommonFood(id: ID!, input: UpdateMyCommonFoodInput!): UpdateMyCommonFood
  deleteMyBrandedFood(id: ID!): DeleteMyBrandedFood
  deleteMyCommonFood(id: ID!): DeleteMyCommonFood
  createGooglePlayTransaction(acknowledged: Boolean!, autoRenewing: Boolean!, orderId: String!, packageName: String!, productId: String!, purchaseState: Int!, purchaseTime: Float!, purchaseToken: String!, subscriptionSku: String!): CreateGooglePlayTransaction
  updateSubscription(profileId: String, subscriptionId: String!, userId: String): UpdateSubscription
  processAppleReceipt(input: ProcessAppleReceiptInput!): ProcessAppleReceipt
  updateJourneyStatus(journeyId: String!, status: JourneyStatus!): UpdateJourneyStatus
  toggleTaskCompleted(keysHash: String!): ToggleTaskCompleted
  startJourneys(
    """Number of days initially unlocked. Default to 1"""
    daysUnlocked: Int

    """If true, the number of days unlocked can be updated using daysUnlocked"""
    override: Boolean
  ): StartJourneys
  createSupplementPlan(fromTemplate: ID, input: CreateSPInput): CreateSupplementPlan
  updateSupplementPlan(input: UpdateSPInput!): UpdateSupplementPlan
  updateProtocol(input: UpdateProtocolInput!): UpdateProtocol
  checkoutCreate(input: CheckoutCreateInput!): CheckoutCreate
  createSupplement(input: CreateSupplementInput!): CreateSupplement
  updateSupplement(input: UpdateSupplementInput!): UpdateSupplement
  sendFeedback(message: String!, subject: String!): SendFeedback
  createUser(birthdate: Date, email: String!, emailPasswordNotification: Boolean, extraData: JSONString, name: String!, password: String, phone: String, preferredCommunicationChannel: CommunicationChannel, program: String, restrictions: [ID!], subscription: ID): CreateUser
  login(userId: String!): LoginUser
  requestResetPassword(email: String!): RequestResetPassword
  resetPassword(code: String!, newPassword: String!): ResetPassword
  createNote(coach: ID, eventId: ID, text: String!, title: String!): CreateNote
  updateNote(coach: ID, noteId: ID!, text: String, title: String): UpdateNote
  deleteNote(noteId: ID!): DeleteNote
  addFavoriteArticle(articleId: ID!): AddFavoriteArticle
  removeFavoriteArticle(articleId: ID!): RemoveFavoriteArticle
  generateMagicLink(email: String!): GenerateMagicLink
  createAppointment(input: CreateAppointmentInput!): CreateAppointment
  updateAppointment(input: UpdateAppointmentInput!): UpdateAppointment
  cancelAppointment(appointment: ID!): CancelAppointment
  saveZoomSessionForAppointment(input: SaveZoomSessionForAppointmentInput!): SaveZoomSessionForAppointment
  updateAppointmentCredits(appointmentType: ID!, decrease: Int, increase: Int, labTestReports: [ID], profile: ID!, value: Int): UpdateAppointmentCredits
  resendAppointmentConfirmationEmail(appointment: ID!, profile: ID): ResendAppointmentConfirmationEmail
  setActiveSource(source: SourceType!): SetActiveSource
  createContentTag(name: String!): CreateContentTag
  updateContentTag(id: ID!, name: String!): UpdateContentTag
  deleteContentTag(id: ID!): DeleteContentTag
  createContentCategory(input: CreateContentCategoryInput!): CreateContentCategory
  updateContentCategory(input: UpdateContentCategoryInput!): UpdateContentCategory
  deleteContentCategory(id: ID!): DeleteContentCategory
  createContentLibrary(input: CreateContentLibraryInput!): CreateContentLibrary
  updateContentLibrary(input: UpdateContentLibraryInput!): UpdateContentLibrary
  deleteContentLibrary(id: ID!): DeleteContentLibrary
  createDailyRecapAnswer(input: CreateDailyRecapAnswerInput!): CreateDailyRecapAnswer
  updateDailyRecapAnswer(input: UpdateDailyRecapAnswerInput!): UpdateDailyRecapAnswer
  deleteDailyRecapAnswer(id: ID!): DeleteDailyRecapAnswer
  createDailyRecapQuestion(input: CreateDailyRecapQuestionInput!): CreateDailyRecapQuestion
  updateDailyRecapQuestion(input: UpdateDailyRecapQuestionInput!): UpdateDailyRecapQuestion
  deleteDailyRecapQuestion(id: ID!): DeleteDailyRecapQuestion
  createCoachType(input: CreateCoachTypeInput!): CreateCoachType
  updateCoachType(input: UpdateCoachTypeInput!): UpdateCoachType
  deleteCoachType(id: ID!): DeleteCoachType
  createCoachTeam(input: CreateCoachTeamInput!): CreateCoachTeam
  updateCoachTeam(input: UpdateCoachTeamInput!): UpdateCoachTeam
  deleteCoachTeam(id: ID!): DeleteCoachTeam
  updateThirdPartyTrackerComponent(input: UpdateThirdPartyTrackerComponentInput!): UpdateThirdPartyTrackerComponent
  generateShopifyMultipassUrl(input: GenerateShopifyMultipassUrlInput): GenerateShopifyMultipassUrl
  createThirdPartyGoal(input: CreateThirdPartyGoalInput!): CreateThirdPartyGoal
  updateThirdPartyGoal(input: UpdateThirdPartyGoalInput!): UpdateThirdPartyGoal
  deleteThirdPartyGoal(id: ID!): DeleteThirdPartyGoal
  setThirdPartyAppUserAsTest(input: SetThirdPartyAppUserAsTestInput!): SetThirdPartyAppUserAsTest
  markContentAsReadOrUnread(input: MarkContentAsReadOrUnreadInput!): MarkContentAsReadOrUnread
  addUserConsent(input: AddUserConsentInput!): AddUserConsent
  removeUserConsent(consentType: ID!): RemoveUserConsent
  uploadAppointmentAttachment(input: UploadAppointmentAttachmentInput!): UploadAppointmentAttachment
  deleteAppointmentAttachment(id: ID!): DeleteAppointmentAttachment
  updateEmailCustomFields(input: UpdateEmailCustomFieldsInput!): UpdateEmailCustomFields
  generateMealPlan(
    addDays: Boolean
    appendDays: Int = 7

    """Percentage of the daily kcal goal that each breakfast covers"""
    breakfastDistribution: Float

    """Percentage of the daily kcal goal that each dinner covers"""
    dinnerDistribution: Float
    fromTemplate: ID
    ignoreLock: Boolean
    includeFavorites: Boolean
    isAppend: Boolean = false
    isCache: Boolean

    """Upper kcal limit per meal, as a percentage of daily goal"""
    kcalLimit: Float

    """Percentage of the daily kcal goal that each lunch covers"""
    lunchDistribution: Float

    """Max num of ingredients in recipe per meal time"""
    maxIngredientsCount: IntValueByMealTime

    """Maximum number of servings per meal allowed in the meal plan"""
    maxNumOfServings: Int

    """Maximum serving weight per meal allowed in the meal plan"""
    maxServingWeight: Int

    """Max preparation time in minutes per meal time"""
    maxTimeMinutes: IntValueByMealTime

    """Minimum serving weight per meal allowed in the meal plan"""
    minServingWeight: Int
    repeat: DateTime

    """Percentage of the daily kcal goal that each snack covers"""
    snackDistribution: Float
    startDate: Date
    variety: MPVariety
  ): GenerateMealPlan
  generateSimpleMealPlan(addDays: Boolean, appendDays: Int = 7, boostAdherence: Boolean, filters: SimpleMPFiltersInput, format: [MealTime!], ignoreLock: Boolean, isAppend: Boolean = false, repeat: DateTime, variety: MPVariety): GenerateSimpleMealPlan
  startOverMealPlan: StartOverMealPlan

  """
  Swaps a recipe from profile's MP, adding it to a specific day
  or every day in the same meal_fmt position
  """
  swapMealPlanRecipe(mealId: String, mealTag: MealTime, recipeId: String!, serving: Int): SwapMealPlanRecipe
  changeMealPlannerDayMeal(day: Int!, mealTime: MealTime!, recipeId: String!): ChangeMealPlannerDayMeal
  setMealPlanToTemplate(profileId: ID!, templateId: ID!): SetMealPlanToTemplate
  removeMealPlan: RemoveMealPlan
  removeMealPlanRecipe(mealId: ID!): RemoveMealPlanRecipe
  createMealPlanTemplate(coach: ID, customOptions: MPTCustomOptionsInput, description: String!, fromDays: MPTFromDaysInput, fromScratch: MPTFromScratchInput, isPublic: Boolean, name: String!): CreateMealPlanTemplate
  updateMealPlanTemplate(coach: ID, coachTypes: [ID!], description: String, id: ID!, isPublic: Boolean, mealPlanDays: MPTFromScratchInput, name: String): UpdateMealPlanTemplate
  duplicateMealPlanTemplate(id: ID!): DuplicateMealPlanTemplate
  deleteMealPlanTemplate(coach: ID, id: ID!): DeleteMealPlanTemplate
  addToShoppingList(recipeId: String!, servings: Int): AddToShoppingList
  addRecipesToShoppingList(recipeIds: [String]!): AddRecipesToShoppingList
  addRecipeItemsToShoppingList(recipes: [RecipeInShoppingList!]!): AddRecipeItemsToShoppingList
  removeFromShoppingList(recipeId: String!): RemoveFromShoppingList
  toggleShoppingListItem(isAggregate: Boolean!, itemId: String!): ToggleShoppingListItem
  toggleShoppingListItems(isAggregate: Boolean!, itemIds: [String!]!): ToggleShoppingListItems
  clearShoppingList: ClearShoppingList
  clearShoppingListCheckedItems: ClearShoppingListCheckedItems
  updateShoppingListRecipeServings(numberOfServings: Int!, recipeId: String!): UpdateShoppingListRecipeServings
  purchaseMealRecipe(externalId: String, profileId: String!, recipeId: ID!): PurchaseMealRecipe
  createMealLog(customServingEquivalent: Float, mealDatabaseId: String!, mealTime: MealTime!, mealType: MealType!, quantity: Float!, serving: Float, time: Time, timestamp: DateTime): CreateMealLogMutation
  updateMealLog(customServingEquivalent: Float, databaseId: String!, date: Date, mealTime: MealTime, quantity: Float, serving: Float, time: Time): UpdateMealLogMutation
  removeMealLog(databaseId: String!): RemoveMealLogMutation
  createOwnMealLog(barcode: String, brand: String, date: Date, logAfterCreation: Boolean, mealTime: MealTime, mealTimes: [MealTime], mealType: MealType!, name: String!, ownNutrients: OwnNutrients!, ownServing: OwnServing!): CreateOwnMealLogMutation
  updateOwnMeal(barcode: String, brand: String, databaseId: String!, date: Date, mealTime: MealTime, mealType: MealType, name: String, ownNutrients: OwnNutrients!, ownServing: OwnServing!): UpdateOwnMealMutation

  """Removes users own `food` or own `recipe`"""
  removeOwnMeal(databaseId: String!): RemoveOwnMeal
  createOwnRecipe(ingredients: [OwnRecipeIngredient], logAfterCreation: Boolean, quantity: Float!, recipeName: String!): CreateOwnRecipe
  updateOwnRecipe(databaseId: String!, ingredients: [OwnRecipeIngredient], quantity: Float, recipeName: String): UpdateOwnRecipe
  profileMacroGoalsSettings(activityLevel: ActivityLevel!, biologicalSex: BiologicalSex!, birthdate: Date!, goalsOn: Boolean!, height: Float!, isImperial: Boolean, startingWeight: Float!, targetWeight: Float!, weeklyWeightGoal: WeeklyWeightGoal!): ProfileMacroGoalsSettings
  profileRestrictionsUpdate(
    replace: Boolean

    """List of restrictions to be added to a user profile"""
    restrictions: [ID]
  ): ProfileRestrictionsUpdate
  deleteMyProfile: HardDeleteMyProfileMutation
  updateMealPlanSettings(overwrite: UpdateMPSettingsInput, update: UpdateMPSettingsInput): UpdateMealPlanSettings
  profileMealPlanSettings(calories: Int!, carbsPerc: Float!, error: Float!, fatPerc: Float!, format: [MealTime], omega3Perc: Float, proteinPerc: Float!): ProfileMealPlanSettings @deprecated(reason: "This doesn't allow doing settings reset. Use updateMealPlanSettings instead.")
  createProfileBiomarkers(cholesterolLdl: Float, cortisol: Float, ferritin: Float, hba1c: Float, totalCholesterol: Float, vitaminB12: Float, vitaminD: Float): CreateProfileBiomarkers
  updateProfileBiomarkers(cholesterolLdl: Float, cortisol: Float, ferritin: Float, hba1c: Float, totalCholesterol: Float, vitaminB12: Float, vitaminD: Float): UpdateProfileBiomarkers
  updateProfile(birthdate: Date, country: String, currentSource: SourceType, dietPreferences: [ID!], email: String, enabledTrackers: [TrackerComponent!], familySize: Int, favoriteCuisines: [String!], hasOnboarded: Boolean, isImperial: Boolean, language: Language, mpDiversity: MealPlanDiversity, name: String, operationDietPreferences: Operation, phone: String, preferredCommunicationChannel: CommunicationChannel, thryveAuthenticationToken: String, timezone: String): UpdateProfile
  createProfileCustomAttributes(append: Boolean, attributes: [ProfileCustomAttribute!]!): CreateProfileCustomAttributes
  sensitiveProfileAttributes(attributes: String, signingPublicKey: String): SensitiveProfileAttributes
  createLabTestReport(alert: Boolean, alertAction: AlertAction, alertStatus: AlertStatus, alertText: String, description: String, externalId: String, image: Upload, imageUrl: String, isVisible: Boolean, labName: String!, orderId: String, orderingPhysician: String, productId: String, reportPdf: Upload, requisitionId: String, sampleCollectionDate: Date, status: LabTestReportStatus, testDate: DateTime, testName: String!, title: String, userEmail: String, videoUrl: String): CreateLabTestReport
  deleteLabTestReport(id: ID!): DeleteLabTestReport
  updateLabTestReport(alert: Boolean, alertAction: AlertAction, alertStatus: AlertStatus, alertText: String, description: String, externalId: String, id: ID!, image: Upload, imageUrl: String, isVisible: Boolean, labName: String, orderId: String, orderingPhysician: String, productId: String, reportPdf: Upload, requisitionId: String, sampleCollectionDate: Date, status: LabTestReportStatus, testDate: DateTime, testName: String, title: String, userEmail: String, videoUrl: String): UpdateLabTestReport
  createMyChecklistItem(directionsOfUse: [ItemDirectionsOfUseInput!], header: String!, tags: [String!], text: String): CreateMyChecklistItem
  updateMyChecklistItem(directionsOfUse: [ItemDirectionsOfUseInput!], header: String, id: ID!, tags: [String!], text: String): UpdateMyChecklistItem
  deleteMyChecklistItem(id: ID!): DeleteMyChecklistItem
  requestAccountDeletion: RequestAccountDeletion
  generateVideoZoomToken(input: GenerateVideoZoomTokenInput!): GenerateVideoZoomTokenPayload
  mergeUser(input: MergeUserInput!): MergeUser
  createDietPreference(input: CreateDietPreferenceInput!): CreateDietPreference
  updateDietPreference(input: UpdateDietPreferenceInput!): UpdateDietPreference
  deleteDietPreference(id: ID!): DeleteDietPreference
  deleteAppUserProfile(id: ID!): HardDeleteAppUserProfile
  requestUserDataDownload: RequestUserDataDownload
  createUserTracker(input: CreateUserTrackerInput!): CreateUserTracker
  updateUserTracker(input: UpdateUserTrackerInput!): UpdateUserTracker
  deleteUserTracker(id: ID!): DeleteUserTracker
  userFavoriteRestaurant(restaurantId: String!): UserFavoriteRestaurant
  userFavoriteMenuitem(menuitemId: String!): UserFavoriteMenuItem
  userFavoriteRecipe(recipeId: String!): UserFavoriteRecipe
  createMyRecipe(input: CreateMyRecipeInput!): CreateMyRecipe
  deleteMyRecipe(id: ID!): DeleteMyRecipe
  updateMyRecipe(id: ID!, input: UpdateMyRecipeInput!): UpdateMyRecipe
  updateUserProgram(programId: String!): UpdateUserProgram
  deleteCondition(id: ID!): DeleteCondition
  createQuizResult(answers: [String]!, result: String!): CreateQuizResult
  publishEvent(appVersion: String!, client: String!, eventType: EventType!, location: GenericScalar, timezone: String!): PublishEvent
  confirmFoodLogAssistant(input: ConfirmFoodLogAssistantInput!): ConfirmFoodLogAssistant
  processFoodImageAssistant(input: ImageAssistantInput!): ProcessFoodImageAssistant
  processAiFood(input: ProcessAIFoodInput!): ProcessAIFood
  saveAiFoodLog(input: SaveAIFoodLogInput!): SaveAIFoodLog
  createAssessment(input: CreateAssessmentInput!): CreateAssessment
  updateAssessment(input: UpdateAssessmentInput!): UpdateAssessment
  deleteAssessment(id: ID!): DeleteAssessment
  createQuestion(input: CreateQuestionInput!): CreateQuestion
  updateQuestion(input: UpdateQuestionInput!): UpdateQuestion
  deleteQuestion(id: ID!): DeleteQuestion
  setUserAnswers(input: SetUserAnswersInput!): SetUserAnswers
  linkUserAssessment(input: LinkUserAssessmentInput!): LinkUserAssessment
  unlinkUserAssessment(input: LinkUserAssessmentInput!): UnlinkUserAssessment
  updateUserAssessmentScore(input: UpdateUserAssessmentScoreInput!): UpdateUserAssessmentScore
  updateUserProgress(input: UpdateUserProgressInput!): UpdateUserProgress
  createAnswer(input: CreateAnswerInput!): CreateAnswer
  updateAnswer(input: UpdateAnswerInput!): UpdateAnswer
  deleteAnswer(id: ID!): DeleteAnswer
  newUserAssessments(input: NewUserAssessmentsInput!): NewUserAssessments
  updateDynamicQuestion(input: UpdateDynamicQuestionInput!): UpdateDynamicQuestion
  deleteDynamicQuestion(id: ID!): DeleteDynamicQuestion
  addBiomarkerResults(input: AddBiomarkerResultsInput!): AddBiomarkerResults
  addBiomarker(input: AddBiomarkerInput!): AddBiomarker
  updateBiomarker(input: UpdateBiomarkerInput!): UpdateBiomarker
  deleteBiomarker(id: ID!): DeleteBiomarker
  createArticleRecommended(input: CreateArticleRecommendedInput!): CreateArticleRecommended
  updateArticleRecommended(input: UpdateArticleRecommendedInput!): UpdateArticleRecommended
  deleteArticleRecommended(id: ID!): DeleteArticleRecommended
  createSupplementRecommended(input: CreateSupplementRecommendedInput!): CreateSupplementRecommended
  updateSupplementRecommended(input: UpdateSupplementRecommendedInput!): UpdateSupplementRecommended
  deleteSupplementRecommended(id: ID!): DeleteSupplementRecommended
  createBiomarkerCategory(input: CreateBiomarkerCategoryInput!): CreateBiomarkerCategory
  updateBiomarkerCategory(input: UpdateBiomarkerCategoryInput!): UpdateBiomarkerCategory
  deleteBiomarkerCategory(id: ID!): DeleteBiomarkerCategory
  selectDailyRecapQuestions(questions: [ID!]!): SelectDailyRecapQuestions!
  createDailyRecapEntry(date: Date!, questionId: String!, answerId: String!): CreateDailyRecapEntry
  deleteDailyRecapEntry(date: Date!, questionId: String!): DeleteDailyRecapEntry
  createWeightEntry(date: Date!, value: Float!, source: SourceType): CreateWeightEntry
  updateStartWeight(value: Float!): UpdateStartWeight!
  updateHydration(date: Date!, action: ActionType!, quantity: Int, source: SourceType): UpdateHydration
  createMealEntry(mealId: ID!, date: Date, timezone: String, value: MealTrackStatus): CreateMealEntry
  deleteWeightEntry(date: Date!): DeleteWeightEntry
  addExerciseEntry(datetime: DateTime!, type: ExerciseType!, intensity: ExerciseIntensity!, durationMinutes: Int!, source: SourceType, calories: Int): AddExerciseEntry!
  deleteExerciseEntry(id: ID!): DeleteExerciseEntry!
  addStepsCount(datetime: DateTime!, steps: Int!, source: SourceType): AddStepsCount!
  deleteStepsCount(id: ID!): DeleteStepsCount!

  """
  checkIntake creates a log checking that the user ate food that they was supposed to eat as part of a plan
  """
  checkIntake(itemId: ID!, date: Date!, category: IntakeCategory!, timeOfDay: TimeOfDay): CheckIntake!

  """uncheckIntake is the opposite of checkIntake. It undoes the check"""
  uncheckIntake(itemId: ID!, date: Date!, category: IntakeCategory!, timeOfDay: TimeOfDay): UncheckIntake!

  """
  addFoodLog logs that the user ate specific food, like a recipe, a personal recipe, a meal plan's meal, etc
  """
  addFoodLog(foodId: ID!, date: Date!, mealTime: MealTime!, time: Time, grams: Int, gramsFloat: Float, milligrams: Int, servings: Float, portionModifier: String): AddFoodLog!

  """deleteFoodLog deletes a food log by ID"""
  deleteFoodLog(id: ID!): DeleteFoodLog!

  """
  checkIntake creates a log checking that the user fulfilled the action in one of their personal MyChecklistItem
  """
  createMyChecklistItemLog(itemId: ID!, date: Date!, timeOfDay: TimeOfDay!): CreateMyChecklistItemLog!

  """deleteMyChecklistItemLog deletes a MyChecklistItem log by ID"""
  deleteMyChecklistItemLog(itemId: ID!, date: Date!, timeOfDay: TimeOfDay!): DeleteMyChecklistItemLog!

  """
  addSleepTime add sleep time log | Args: value: Sleep duration in minutes
  """
  addSleepTime(value: Int!, date: Date, source: SourceType): AddSleepTime!

  """deleteSleepTime delete sleep time entry"""
  deleteSleepTime(id: ID!): DeleteSleepTime!

  """addSleepQualityScore add sleep quality score log"""
  addSleepQualityScore(value: Int!, date: Date, source: SourceType): AddSleepQualityScore!

  """deleteSleepQualityScore delete sleep quality score entry"""
  deleteSleepQualityScore(id: ID!): DeleteSleepQualityScore!

  """addHRVLog add HRV log"""
  addHRVLog(value: PositiveFloat!, timestamp: DateTime, source: SourceType): AddHRVLog!

  """deleteHRVLog delete hrv log entry"""
  deleteHRVLog(id: ID!): DeleteHRVLog!

  """addHeartRateLog add Heart Rate Log log"""
  addHeartRateLog(value: PositiveInt!, timestamp: DateTime, source: SourceType): AddHeartRateLog!

  """deleteHeartRateLog delete Heart Rate Log"""
  deleteHeartRateLog(id: ID!): DeleteHeartRateLog!
  bulkCreateEntries(weightEntries: [WeightEntryInput!], hydrationEntries: [HydrationEntryInput!], exerciseEntries: [ExerciseEntryInput!], stepsCountEntries: [StepCountEntryInput!], sleepTimeEntries: [SleepTimeEntryInput!], sleepQualityScoreEntries: [SleepQualityEntryInput!], hrvEntries: [HRVEntryInput!], heartRateEntries: [HeartRateEntryInput!]): BulkCreateEntries!
  addBloodPressureLog(systolicValue: PositiveInt!, diastolicValue: PositiveInt!, datetime: DateTime!, source: SourceType): AddBloodPressureLog!
  updateBloodPressureLog(id: ID!, systolicValue: PositiveInt, diastolicValue: PositiveInt): UpdateBloodPressureLog!
  deleteBloodPressureLog(id: ID!): DeleteBloodPressureLog!
  createExpressTrack(mealTime: MealTime!, calories: Float!, proteins: Float!, carbs: Float!, fats: Float!, fibers: Float, datetime: DateTime, foodName: String, imageUrl: String): CreateExpressTrack!
  updateExpressTrack(id: ID!, mealTime: MealTime, calories: Float, proteins: Float, carbs: Float, fats: Float, fibers: Float, datetime: DateTime, foodName: String, imageUrl: String): UpdateExpressTrack!
  deleteExpressTrack(id: ID!): DeleteExpressTrack!
  createSymptomLog(symptomId: ID!, timestamp: DateTime!, intensity: Int!, notes: String): CreateSymptomLog!
  updateSymptomLog(id: ID!, symptomId: ID, timestamp: DateTime, intensity: Int, notes: String): UpdateSymptomLog!
  deleteSymptomLog(id: ID!): DeleteSymptomLog!
  uncheckTodayFood(itemId: ID!, date: Date!): UncheckTodayFood @deprecated(reason: "No longer supported. Use uncheckIntake instead")
  uncheckTodaySupplement(itemId: ID!, date: Date!): UncheckTodaySupplement @deprecated(reason: "No longer supported. Use uncheckIntake instead")
  checkTodayFood(itemId: ID!, date: Date!): CheckTodayFoodEntry @deprecated(reason: "No longer supported. Use checkIntake instead")
  checkTodaySupplement(itemId: ID!, date: Date!): CheckTodaySupplementEntry @deprecated(reason: "No longer supported. Use checkIntake instead")
}

type MyBrandedFood implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  description: String
  dataType: String
  nutrients: [Nutrient!]!
  isGeneric: Boolean!
  isActive: Boolean!
  isCore: Boolean!
  tags: [String!]!
  isOpenFoodFacts: Boolean
  foodDataId: String
  brandOwner: String
  brandName: String
  householdServingFulltext: String
  brandedFoodCategory: String
  servingSizeUnit: String!
  servingSize: Float!
  gtinUpc: String
  calories: Float
  profileId: String!
}

type MyBrandedFoodConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [MyBrandedFoodEdge]!
  count: Int!
}

"""A Relay edge containing a `MyBrandedFood` and its cursor."""
type MyBrandedFoodEdge {
  """The item at the end of the edge"""
  node: MyBrandedFood

  """A cursor for use in pagination"""
  cursor: String!
}

type MyBrandedFoodProxy {
  myBrandedFood: MyBrandedFood!
}

type MyChecklistItem implements Node {
  id: ID!
  header: String!
  text: String
  tags: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  directionsOfUse: [CheckItemDirections!]
}

type MyChecklistItemConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [MyChecklistItemEdge]!
}

"""A Relay edge containing a `MyChecklistItem` and its cursor."""
type MyChecklistItemEdge {
  """The item at the end of the edge"""
  node: MyChecklistItem

  """A cursor for use in pagination"""
  cursor: String!
}

type MyChecklistItemOnPlan {
  checked: Boolean!
  timeOfDay: TimeOfDay
  myChecklistItem: MyChecklistItem!
}

type MyChecklistLog {
  id: ID!
  myChecklistItemId: ID!
  timeOfDay: TimeOfDay!
  myChecklistItem: MyChecklistItem!
}

type MyChecklistLogs {
  dates: [MyChecklistLogsDay!]!
}

type MyChecklistLogsDay {
  date: Date!
  logs: [MyChecklistLog!]!
}

type MyCommonFood implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  description: String
  dataType: String
  nutrients: [Nutrient!]!
  isGeneric: Boolean!
  isActive: Boolean!
  isCore: Boolean!
  tags: [String!]!
  isOpenFoodFacts: Boolean
  foodDataId: String
  portions: [Portion]
  profileId: String!
}

type MyCommonFoodConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [MyCommonFoodEdge]!
  count: Int!
}

"""A Relay edge containing a `MyCommonFood` and its cursor."""
type MyCommonFoodEdge {
  """The item at the end of the edge"""
  node: MyCommonFood

  """A cursor for use in pagination"""
  cursor: String!
}

type MyCommonFoodProxy {
  myCommonFood: MyCommonFood!
}

type NewUserAssessments {
  success: Boolean!
  message: String!
  userId: String
  externalId: String
  assessments(offset: Int, before: String, after: String, first: Int, last: Int): AssessmentConnection
}

input NewUserAssessmentsInput {
  """The User email, if the email isn't found, a new User will be created."""
  email: String!

  """Session External ID."""
  externalId: String
  assessment: ID
}

"""An object with an ID"""
interface Node {
  """The ID of the object"""
  id: ID!
}

type Note implements Node {
  """The ID of the object"""
  id: ID!
  title: String!
  text: String
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: Coach
  updatedBy: Coach
}

type NoteConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NoteEdge]!
}

"""A Relay edge containing a `Note` and its cursor."""
type NoteEdge {
  """The item at the end of the edge"""
  node: Note

  """A cursor for use in pagination"""
  cursor: String!
}

type Nutrient {
  type: NutrientEnum!
  amount: Float
  unit: String
  name: String
  id: Int
}

type NutrientAggregationsByFoodLog {
  chocdf: NutrientGoalComparison
  procnt: NutrientGoalComparison
  fat: NutrientGoalComparison
  netcarbs: NutrientGoalComparison
  calcium: NutrientGoalComparison
  chromium: NutrientGoalComparison
  copper: NutrientGoalComparison
  fluoride: NutrientGoalComparison
  iodine: NutrientGoalComparison
  iron: NutrientGoalComparison
  magnesium: NutrientGoalComparison
  manganese: NutrientGoalComparison
  molybdenum: NutrientGoalComparison
  phosphorus: NutrientGoalComparison
  selenium: NutrientGoalComparison
  zinc: NutrientGoalComparison
  potassium: NutrientGoalComparison
  sodium: NutrientGoalComparison
  chloride: NutrientGoalComparison
  vitamina: NutrientGoalComparison
  vitaminc: NutrientGoalComparison
  vitamind: NutrientGoalComparison
  vitamine: NutrientGoalComparison
  vitamink: NutrientGoalComparison
  thiamin: NutrientGoalComparison
  riboflavin: NutrientGoalComparison
  niacin: NutrientGoalComparison
  vitaminb6: NutrientGoalComparison
  folate: NutrientGoalComparison
  vitaminb12: NutrientGoalComparison
  pantothenicacid: NutrientGoalComparison
  biotin: NutrientGoalComparison
  choline: NutrientGoalComparison
  totalfiber: NutrientGoalComparison
  linoleicacid: NutrientGoalComparison
  alphaLinolenicacid: NutrientGoalComparison
}

enum NutrientEnum {
  DHA
  EPA
  DPA
  PROTEIN
  FAT
  CARBS
  ASH
  ENERGY
  STARCH
  SUCROSE
  GLUCOSE_DEXTROSE
  FRUCTOSE
  LACTOSE
  MALTOSE
  ALCOHOL_ETHYL
  SPECIFIC_GRAVITY_SP
  ACETIC_ACID
  LACTIC_ACID
  CARBOHYDRATE_BY_SUMMATION
  WATER
  SORBITOL
  CAFFEINE
  THEOBROMINE
  SUGARS_TOTAL_NLEA
  CARBOHYDRATE_OTHER
  GALACTOSE
  XYLITOL
  FIBER_TOTAL_DIETARY
  RIBOSE
  FIBER_SOLUBLE
  FIBER_INSOLUBLE
  TOTAL_FAT_NLEA
  TOTAL_SUGAR_ALCOHOLS
  CALCIUM_CA
  CHLORINE_CL
  IRON_FE
  MAGNESIUM
  PHOSPHORUS_P
  POTASSIUM_K
  SODIUM_NA
  SULFUR_S
  ZINC_ZN
  CHROMIUM_CR
  COBALT_CO
  COPPER_CU
  FLUORIDE_F
  IODINE_I
  MANGANESE_MN
  MOLYBDENUM_MO
  SELENIUM_SE
  VITAMIN_A_IU
  RETINOL
  VITAMIN_A_RAE
  CAROTENE_BETA
  CAROTENE_ALPHA
  VITAMIN_E_ALPHA_TOCOPHEROL
  VITAMIN_D_D2_D3_INTERNATIONAL_UNITS
  VITAMIN_D2_ERGOCALCIFEROL
  VITAMIN_D3_CHOLECALCIFEROL
  O25_HYDROXYCHOLECALCIFEROL
  VITAMIN_D_D2_D3
  PHYTOENE
  PHYTOFLUENE
  ZEAXANTHIN
  CRYPTOXANTHIN_BETA
  LUTEIN
  LYCOPENE
  LUTEIN_ZEAXANTHIN
  VITAMIN_E_LABEL_ENTRY_PRIMARILY
  TOCOPHEROL_BETA
  TOCOPHEROL_GAMMA
  TOCOPHEROL_DELTA
  TOCOTRIENOL_ALPHA
  TOCOTRIENOL_BETA
  TOCOTRIENOL_GAMMA
  TOCOTRIENOL_DELTA
  BORON_B
  NICKEL_NI
  VITAMIN_E
  CIS_BETA_CAROTENE
  CIS_LYCOPENE
  CIS_LUTEIN_ZEAXANTHIN
  VITAMIN_C_TOTAL_ASCORBIC_ACID
  THIAMIN
  RIBOFLAVIN
  NIACIN
  PANTOTHENIC_ACID
  VITAMIN_B_6
  BIOTIN
  FOLATE_TOTAL
  VITAMIN_B_12
  CHOLINE_TOTAL
  INOSITOL
  VITAMIN_K_MENAQUINONE_4
  VITAMIN_K_DIHYDROPHYLLOQUINONE
  VITAMIN_K_PHYLLOQUINONE
  FOLIC_ACID
  FOLATE_FOOD
  O5_METHYL_TETRAHYDROFOLATE_5_MTHF
  FOLATE_DFE
  O10_FORMYL_FOLIC_ACID_10HCOFA
  O5_FORMYLTETRAHYDROFOLIC_ACID_5_HCOH4
  CHOLINE_FREE
  CHOLINE_FROM_PHOSPHOCHOLINE
  CHOLINE_FROM_PHOSPHOTIDYL_CHOLINE
  CHOLINE_FROM_GLYCEROPHOSPHOCHOLINE
  BETAINE
  CHOLINE_FROM_SPHINGOMYELIN
  TRYPTOPHAN
  THREONINE
  ISOLEUCINE
  LEUCINE
  LYSINE
  METHIONINE
  CYSTINE
  PHENYLALANINE
  TYROSINE
  VALINE
  ARGININE
  HISTIDINE
  ALANINE
  ASPARTIC_ACID
  GLUTAMIC_ACID
  GLYCINE
  PROLINE
  SERINE
  HYDROXYPROLINE
  CYSTEINE
  GLUTAMINE
  TAURINE
  SUGARS_ADDED
  VITAMIN_E_ADDED
  VITAMIN_B_12_ADDED
  CHOLESTEROL
  FATTY_ACIDS_TOTAL_TRANS
  FATTY_ACIDS_TOTAL_SATURATED
  PHYTOSTEROLS
  STIGMASTEROL
  CAMPESTEROL
  BRASSICASTEROL
  BETA_SITOSTEROL
  CAMPESTANOL
  FATTY_ACIDS_TOTAL_MONOUNSATURATED
  FATTY_ACIDS_TOTAL_POLYUNSATURATED
  BETA_SITOSTANOL
  DELTA_5_AVENASTEROL
  PHYTOSTEROLS_OTHER
  FATTY_ACIDS_TOTAL_TRANS_MONOENOIC
  FATTY_ACIDS_TOTAL_TRANS_DIENOIC
  FATTY_ACIDS_TOTAL_TRANS_POLYENOIC
  EPIGALLOCATECHIN_3_GALLATE
  INULIN
  SUGARS_TOTAL_INCLUDING_NLEA
  TRANS_BETA_CAROTENE
  TRANS_LYCOPENE
  CRYPTOXANTHIN_ALPHA
}

input NutrientFilterInput {
  nutrient: NutrientEnum!
  range: RangeFilter
}

type NutrientGoalComparison {
  value: Float
  goal: Float
}

input NutrientInput {
  amount: Float!
  unit: String!
  nutrient: NutrientEnum!
}

type Nutrients {
  chocdf: Float
  fat: Float
  sugar: Float
  procnt: Float
  fibtg: Float
  netcarbs: Float
}

type NutrientsFull {
  energy: Float
  fiber: Float
  saturatedFat: Float
  transFats: Float
  cholesterol: Float
  sodiumNa: Float
  potassiumK: Float
  enercKcal: Float
  fasat: Float
  fams: Float
  fapu: Float
  fatrn: Float
  chole: Float
  na: Float
  k: Float
  vitaIu: Float
  vitc: Float
  ca: Float
  fe: Float
}

type NutrientsPerServing {
  calories: Float
  sugar: Float
  fiber: Float
  saturatedFat: Float
  monounsaturatedFat: Float
  polyunsaturatedFat: Float
  transFat: Float
  cholesterol: Float
  sodium: Float
  potassium: Float
  vitaminA: Float
  vitaminC: Float
  vitaminB6: Float
  vitaminB12: Float
  vitaminD: Float
  vitaminE: Float
  calcium: Float
  iron: Float
  netcarbs: Float
  protein: Float
  carbs: Float
  fat: Float
  dha: Float
  dpa: Float
  epa: Float
  ala: Float
  vitaminK: Float
  vitaminB1: Float
  vitaminB2: Float
  vitaminB3: Float
  vitaminB5: Float
  vitaminB7: Float
  vitaminB9: Float
  magnesium: Float
  zinc: Float
  selenium: Float
  phosphorus: Float
  choline: Float
  copper: Float
  manganese: Float
  molybdenum: Float
  iodine: Float
  omega3: Float
}

type NutritionalInfo {
  calories: Float
  protein: Float
  carbs: Float
  fat: Float
  dha: Float
  dpa: Float
  epa: Float
  ala: Float
  sugar: Float
  fiber: Float
  saturatedFat: Float
  monounsaturatedFat: Float
  polyunsaturatedFat: Float
  transFat: Float
  cholesterol: Float
  sodium: Float
  potassium: Float
  vitaminA: Float
  vitaminC: Float
  vitaminB6: Float
  vitaminB12: Float
  vitaminD: Float
  vitaminE: Float
  calcium: Float
  iron: Float
  vitaminK: Float
  vitaminB1: Float
  vitaminB2: Float
  vitaminB3: Float
  vitaminB5: Float
  vitaminB7: Float
  vitaminB9: Float
  magnesium: Float
  zinc: Float
  selenium: Float
  phosphorus: Float
  choline: Float
  copper: Float
  manganese: Float
  molybdenum: Float
  iodine: Float
  netcarbs: Float
  omega3: Float
}

type NutritionEstimates {
  protein: Float
  carbs: Float
  fat: Float
  calories: Float
}

enum Operation {
  ADD
  REMOVE
  REPLACE
}

type OutoCompleteConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [OutoCompleteEdge]!
}

"""A Relay edge containing a `OutoComplete` and its cursor."""
type OutoCompleteEdge {
  """The item at the end of the edge"""
  node: Suggestion

  """A cursor for use in pagination"""
  cursor: String!
}

input OwnNutrients {
  enercKcal: Float
  procnt: Float!
  chocdf: Float!
  fat: Float!
  sugar: Float
  fibtg: Float
  fasat: Float
  fams: Float
  fapu: Float
  fatrn: Float
  chole: Float
  na: Float
  k: Float
  vitaIu: Float
  vitc: Float
  ca: Float
  fe: Float
}

input OwnRecipeIngredient {
  id: String!
  mealType: MealType!
  quantity: Float!
  serving: Int!
}

input OwnServing {
  name: String!
  equivalent: Float!
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Podcast implements Node {
  """The ID of the object"""
  id: ID!
  hostName: String!
  guestName: String!
  hostVoice: String!
  guestVoice: String!
  language: String!
  script: String!
  name: String
  outputValue: String
  audioStyle: String
  createdAt: DateTime!
  updatedAt: DateTime!
  status: PodcastStatus!
  outputType: PodcastOutputType
}

type PodcastConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PodcastEdge]!
}

"""A Relay edge containing a `Podcast` and its cursor."""
type PodcastEdge {
  """The item at the end of the edge"""
  node: Podcast

  """A cursor for use in pagination"""
  cursor: String!
}

input PodcastFiltersInput {
  id: ID
  message: ID
}

enum PodcastOutputType {
  AUDIO_URL
}

enum PodcastStatus {
  IN_PROGRESS
  COMPLETED
  ERROR
  CANCELLED
}

type Portion {
  modifier: String
  seqNum: Int
  amount: Float
  gramWeight: Float
  unit: String
  unitDescription: String
  portionWeight: Float
  modifierDescription: String
  mostCommon: Boolean
}

input PortionInput {
  modifier: String
  amount: Float!
  gramWeight: Float!
  unit: String!
}

scalar PositiveFloat

scalar PositiveInt

enum PostEventStatus {
  SCHEDULED
  COMPLETED
  MEMBER_NO_SHOW
  COACH_NO_SHOW
  RESCHEDULED_BY_MEMBER
  RESCHEDULED_BY_COACH
  RESCHEDULED_BY_ADMIN
  CANCELED_BY_MEMBER
  CANCELED_BY_COACH
  CANCELED_BY_ADMIN
}

enum PriceRate {
  """Filter restaurants by $"""
  RATE_0

  """Filter restaurants by $"""
  RATE_1

  """Filter restaurants by $$"""
  RATE_2

  """Filter restaurants by $$$"""
  RATE_3

  """Filter restaurants by $$$$"""
  RATE_4
}

type ProcessAIFood {
  success: Boolean!
  message: String!
  foodAnalysis: FoodAnalysis
}

input ProcessAIFoodInput {
  image: Upload
  foodDescription: String
}

type ProcessAppleReceipt {
  success: Boolean!
  message: String!
}

input ProcessAppleReceiptInput {
  receiptData: String!
  isInitial: Boolean
}

type ProcessChatFile {
  success: Boolean!
  message: String!
  chatFile: ChatFile
  errors: [FormError!]
}

input ProcessChatFileInput {
  pdfFile: Upload!
  user: ID!
  message: ID
}

type ProcessFoodImageAssistant {
  success: Boolean!
  message: String!
  foodLogAssistant: FoodLogAssistant
}

type ProductOption {
  name: String!
  values: [String!]
}

type ProductType implements Node {
  updatedAt: DateTime
  createdAt: DateTime
  name: String!
  isActive: Boolean!
  programs(offset: Int, before: String, after: String, first: Int, last: Int, isActive: Boolean, isPremium: Boolean): ProgramConnection!
  id: ID!
}

type ProductTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ProductTypeEdge]!
}

"""A Relay edge containing a `ProductType` and its cursor."""
type ProductTypeEdge {
  """The item at the end of the edge"""
  node: ProductType

  """A cursor for use in pagination"""
  cursor: String!
}

type ProductVariant {
  id: ID!
  title: String!
  availableForSale: Boolean!
  price: Money!
}

type ProfileBiomarker implements Node {
  date: DateTime!
  alert: Boolean
  alertText: String
  displayValue: String
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
  value: GenericScalar!
  stringValue: JSONString! @deprecated(reason: "Use value instead")
  biomarker: Biomarker!
  labTestReport: LabTestReport!
  biomarkerUnit: BiomarkerUnit
}

type ProfileBiomarkerConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ProfileBiomarkerEdge]!
}

"""A Relay edge containing a `ProfileBiomarker` and its cursor."""
type ProfileBiomarkerEdge {
  """The item at the end of the edge"""
  node: ProfileBiomarker

  """A cursor for use in pagination"""
  cursor: String!
}

type ProfileBiomarkerResult {
  biomarker: Biomarker!
  results(start: Date, end: Date, offset: Int, before: String, after: String, first: Int, last: Int): ProfileBiomarkerConnection
  articles(offset: Int, before: String, after: String, first: Int, last: Int): ContentLibraryTypeConnection
  supplements(offset: Int, before: String, after: String, first: Int, last: Int): SupplementConnection
}

type ProfileBiomarkers {
  profile: ProfileType!
  hba1c: Float
  totalCholesterol: Float
  cholesterolLdl: Float
  vitaminD: Float
  vitaminB12: Float
  cortisol: Float
  ferritin: Float
  updatedAt: DateTime!
  createdAt: DateTime!
}

input ProfileCustomAttribute {
  name: String!
  dataType: AttrDataType!
  value: GenericScalar!
  category: String
  timestamp: Float
}

enum ProfileField {
  BIOLOGICAL_SEX
  BIRTHDATE
  HEIGHT
  STARTING_WEIGHT
  TARGET_WEIGHT
  WEEKLY_WEIGHT_GOAL
  ACTIVITY_LEVEL
  FAVORITE_CUISINES
  RESTRICTIONS
  CUSTOM_ATTRIBUTES
  MALNUTRITION_RISK
  TUBE_FEEDING_ORAL_INTAKE
  PROGRAM
  IS_IMPERIAL
  PHONE
  FAMILY_SIZE
}

type ProfileMacroGoalsSettings {
  success: Boolean

  """Basal Metabolic Rate"""
  bmr: Int

  """Total Daily Energy Expenditure"""
  tdee: Int

  """Caloric Difference"""
  cd: Int

  """Daily Caloric Intake Goal"""
  dcig: Int

  """Body Mass Index Goal"""
  bmi: Int
  profile: ProfileType
}

type ProfileMealPlanSettings {
  success: Boolean
}

type ProfileRecommendationType {
  id: UUID!
  updatedAt: DateTime
  createdAt: DateTime
  profile: ProfileType!
  recommendation: RecommendationCatalogType
  databaseId: String
}

type ProfileRestrictionsUpdate {
  success: Boolean!
  message: String!
  restrictions: [ID!]
}

"""An enumeration."""
enum ProfilesProfileMpDiversityChoices {
  """HIGH"""
  HIGH

  """MEDIUM"""
  MEDIUM

  """LOW"""
  LOW
}

input ProfileTest {
  name: String!
  age: Int!
  biologicalSex: BiologicalSex!
  height: Float
  weight: Float
  activityLevel: ActivityLevel
  steps: Int
  goalWeight: Float
}

type ProfileType {
  id: UUID!
  appVersion: String!
  gender: String

  """kg"""
  startingWeight: Float

  """kg"""
  targetWeight: Float
  goalsOn: Boolean!
  birthdate: Date
  programName: String
  timezone: String!
  goal: UUID
  goals: [String!]!
  lat: String
  lon: String
  tags: [String!]
  hasNotifications: Boolean

  """kg"""
  weight: Float

  """cm"""
  height: Float
  bodyMassIndex: Float
  age: Int

  """mm Hg"""
  bloodPressureSystolic: Float

  """mm Hg"""
  bloodPressureDiastolic: Float
  cpcs: [UUID!]!
  adherenceScore: Float!
  country: String
  updatedAt: DateTime
  createdAt: DateTime
  glucoseLevel: Float
  hasOnboarded: Boolean!
  extraData: JSONString
  isImperial: Boolean!
  customAttributes: JSONString
  mpCalories: Int
  mpCarbsPerc: Float
  mpProteinPerc: Float
  mpFatPerc: Float
  mpSaturatedFatPerc: Float
  mpMonounsaturatedFatPerc: Float
  mpPolyunsaturatedFatPerc: Float
  mpTransFatPerc: Float
  mpOmega3Perc: Float
  mpDays: Int
  mpError: Float
  mpFormat: [String!]!
  language: String!
  mpDiversity: ProfilesProfileMpDiversityChoices
  malnutritionRisk: Boolean!
  tubeFeedingOralIntake: Int
  favoriteCuisines: [String!]
  dietPreferences: [DietPreference!]!
  externalId: String
  familySize: Int
  biomarkers: ProfileBiomarkers
  activityLevel: ActivityLevel
  weeklyWeightGoal: WeeklyWeightGoal
  restrictions: [Restriction]
  userId: String
  dailyCaloricIntakeGoal: Int
  caloricDifference: Int
  totalDailyEnergyExpenditure: Int
  basalMetabolicRate: Int
  program: Program
  isPremium: Boolean
  subscription: SubscriptionType
  journeyStarted: Boolean
  debugMealPlanVariables: DebugMealPlanVariables!
  email: String!
  thryvePartnerId: String!
  encodedAttributes: String
  sendbirdAccessToken: String
  sendbirdId: String!
  biologicalSex: BiologicalSex
  mealPlan(
    """
    If received, the response will include two week before this date. Default is today.
    """
    fromDate: Date
  ): [MealPlanDay!]!
  currentSource: SourceType
  phone: String
  preferredCommunicationChannel: CommunicationChannel!
  enabledTrackers: [TrackerComponent!]
}

type Program implements Node {
  """The ID of the object"""
  id: ID!
  order: Int!
  visibility: Boolean!
  name: String!
  slug: String
  author: String
  comment: String!
  tags: [String!]!
  isActive: Boolean!
  authors: [UUID!]
  isPremium: Boolean!
  descriptionShort: String
  descriptionLong: String
  defaultVideoThumnail: String
  showDefaultGoals: Boolean!
  image: String
  cover: String
  backgroundImage: String
  books: JSONString
  restrictions(encoded: Boolean): [String!]!
  createdAt: DateTime!
  energyNutrientEquation: CpcsProgramEnergyNutrientEquationChoices!
  ownerParty: ThirdParty
  videoUrl: String
  thirdParties(offset: Int, before: String, after: String, first: Int, last: Int): ThirdPartyConnection!
  thirdPartiesDefault(offset: Int, before: String, after: String, first: Int, last: Int): ThirdPartyConnection!
  contentlibrarySet(offset: Int, before: String, after: String, first: Int, last: Int): ContentLibraryTypeConnection!
  thirdpartydailyrecapquestionSet(offset: Int, before: String, after: String, first: Int, last: Int): ThirdPartyDailyRecapQuestionConnection!
  assistantSet: [Assistant!]!
  productSet(offset: Int, before: String, after: String, first: Int, last: Int): ProductTypeConnection!
  subscriptionSet(offset: Int, before: String, after: String, first: Int, last: Int): SubscriptionTypeConnection!
  transactionSet(offset: Int, before: String, after: String, first: Int, last: Int): SubscriptionTransactionConnection!
  databaseId: String
  authorAvatar: String
  cpcsIngredientGroups: CPCIngredientGroup
  cpcsRecipeTags: CPCRule
}

type ProgramConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ProgramEdge]!
}

"""A Relay edge containing a `Program` and its cursor."""
type ProgramEdge {
  """The item at the end of the edge"""
  node: Program

  """A cursor for use in pagination"""
  cursor: String!
}

input ProgramFiltersInput {
  hasSubscription: Boolean = false
}

input ProgramOrderBy {
  field: ProgramOrderByField = created_at
  order: SortOrder = ASC
}

enum ProgramOrderByField {
  name
  author
  created_at
}

type Protocol implements Node {
  name: String!
  length: Int!
  owner: Coach
  isPublic: Boolean!
  isActive: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  id: ID!
  group: ProtocolGroup!
  program: Program
  supplementProtocols: [SupplementProtocol!]
  bundle: Supplement
}

type ProtocolConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ProtocolEdge]!
}

"""A Relay edge containing a `Protocol` and its cursor."""
type ProtocolEdge {
  """The item at the end of the edge"""
  node: Protocol

  """A cursor for use in pagination"""
  cursor: String!
}

enum ProtocolGroup {
  PROTOCOL
  SINGLE_SUPPLEMENT
}

type PublishEvent {
  success: Boolean
  message: String
}

type PurchaseMealRecipe {
  success: Boolean
  message: String
}

type Query {
  podcasts(filters: PodcastFiltersInput, offset: Int, before: String, after: String, first: Int, last: Int): PodcastConnection
  webhookEndpoints(offset: Int, before: String, after: String, first: Int, last: Int): WebhookEndpointConnection
  symptomCategories(offset: Int, before: String, after: String, first: Int, last: Int): SymptomCategoryConnection
  symptoms(id: ID, offset: Int, before: String, after: String, first: Int, last: Int): SymptomConnection
  symptom(
    """The ID of the object"""
    id: ID!
  ): Symptom
  appUserActivities(coachId: ID!, start: DateTime, end: DateTime, filters: AppUserActivityLogFiltersInput, before: String, after: String, first: Int, last: Int): ActivityLogConnection
  coachActivitiesLogs(coachId: ID!, filters: CoachActivityLogFiltersInput, before: String, after: String, first: Int, last: Int): ActivityLogConnection
  journey(assistantId: ID!): JourneyAssistantTypeResponse
  knowledgeBase(id: ID!): KnowledgeBaseResponse
  knowledgeBases(assistantId: ID!, search: String): [KnowledgeBaseType]
  wellnessProfile(id: ID!): WellnessProfileResponse
  assistants(filters: AssistantFiltersInput): [Assistant!]
  conversationSummary: ConversationSummary!
  escalations(filters: EscalationFilters, before: String, after: String, first: Int, last: Int): EscalationConnection
  constraints(filters: ConstraintFilters, before: String, after: String, first: Int, last: Int): ConstraintConnection
  guardrails(id: ID, filters: GuardrailFilterInput, offset: Int, before: String, after: String, first: Int, last: Int): GuardrailConnection
  assistantAnalytics(assistant: ID!, filters: AssistantAnalyticFiltersInput): AssistantAnalytics
  kbSearch(query: String!): KBSearchResults
  chatMessages(filters: ChatMessagesFilterInput!, offset: Int, before: String, after: String, first: Int, last: Int): ChatMessageConnection
  subscriptions(id: UUID, offset: Int, before: String, after: String, first: Int, last: Int): SubscriptionTypeConnection
  googleTransaction(id: UUID, offset: Int, before: String, after: String, first: Int, last: Int): GooglePlayTransactionTypeConnection
  featureLimitations: [AppRestriction!]!
  purchases: UserPurchases
  foodLogAssistant(userInput: String!): FoodLogAssistant
  drugNutrientInteractions(filters: DrugNutrientInteractionsFilterInput, offset: Int, before: String, after: String, first: Int, last: Int): DrugGroupConnection
  currentJourneys(journeyId: ID, id: UUID, offset: Int, before: String, after: String, first: Int, last: Int): JourneyProfileTypeConnection
  supplementPlans(id: ID, offset: Int, before: String, after: String, first: Int, last: Int): SupplementPlanConnection
  supplements(id: ID, name: String, types: [SupplementType!], offset: Int, before: String, after: String, first: Int, last: Int): SupplementConnection
  supplementParent(supplementId: ID!): SupplementParent
  supplement(
    """The ID of the object"""
    id: ID!
  ): Supplement
  contentLibrary(
    id: ID

    """Filter by Categories IDs."""
    categories: [ID]

    """Search content by title or subtitle."""
    search: String

    """Return content library ordered by creation date or popularity."""
    order: ContentLibraryOrderBy

    """Filter by tags name."""
    tags: [String!]
    enablePersonalizedContent: Boolean = false

    """Fetch content read or not."""
    isRead: Boolean
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): ContentLibraryTypeConnection
  myFavoriteArticles(categories: [ID], search: String, order: ContentLibraryOrderBy, tags: [String!], offset: Int, before: String, after: String, first: Int, last: Int): ContentLibraryTypeConnection
  myCoaches(
    id: ID

    """Exclude the coaches that have had an appointment with the user"""
    excludeAppointmentCoaches: Boolean = false
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): CoachConnection
  contentCategories(id: ID, tags: [String!], offset: Int, before: String, after: String, first: Int, last: Int): ContentCategoryTypeConnection
  users(userUUIDs: [String!], profileUUIDs: [String!], subscriptionId: ID, userEmails: [String!], isTestUser: Boolean, filters: UsersFiltersInput, before: String, after: String, first: Int, last: Int): UserConnection
  notes(id: ID, offset: Int, before: String, after: String, first: Int, last: Int, eventId: ID): NoteConnection
  thirdPartyAppsCustomizations: ThirdPartyAppCustomization
  appointmentCredits: AppointmentCredits!
  coachAvailability(appointmentType: ID!, start: DateTime!, end: DateTime!, coaches: [ID!]): [TimePeriod!]!
  appointmentTypes(offset: Int, before: String, after: String, first: Int, last: Int): AppointmentTypeConnection
  myAppointments(start: DateTime, end: DateTime, timezone: String, labTestReportIds: [ID!], excludeAppointmentsCanceled: Boolean = true): [Appointment!]!
  upcomingAppointments(before: String, after: String, first: Int, last: Int): AppointmentConnection
  pastAppointments(start: DateTime, end: DateTime, before: String, after: String, first: Int, last: Int): AppointmentConnection
  trackingSources: [ConnectedSource!]!
  contentTags(name: String, offset: Int, before: String, after: String, first: Int, last: Int): ContentTagTypeConnection
  thirdPartyDailyRecapAnswers(answer: String, answerType: String): [DailyRecapAnswer!]
  thirdPartyDailyRecapQuestions(question: String, answers: [ID!], group: DailyRecapQuestionGroup, offset: Int, before: String, after: String, first: Int, last: Int): ThirdPartyDailyRecapQuestionConnection
  coachTypes(id: ID, filters: CoachTypesFilterInput, offset: Int, before: String, after: String, first: Int, last: Int): CoachTypeConnection
  coachTeams(id: ID, filters: CoachTeamsFilterInput, offset: Int, before: String, after: String, first: Int, last: Int): CoachTeamConnection
  thirdParty: ThirdParty
  thirdPartyGoals(id: ID, goal: TrackerComponent): [ThirdPartyGoal!]
  userConsent(profileId: ID, consentTypeId: ID): [UserConsentType!]
  consentTypes(name: String): [ConsentType!]
  emailCustomFields: EmailCustomFields

  """Meal planner by day"""
  mealPlannerByDay(mealPlannerQueryType: MealPlannerQueryType!): MealPlannerDays

  """List of recipes ordered using custom format"""
  mealPlannerByCustomFormat(format: [MealTime]!): MealCustomPlannerDays
  mealPlan(
    """
    If received, the response will include two week before this date. Default is today.
    """
    fromDate: Date

    """Complete the meal plan with empty days"""
    fillDays: Boolean = false
    numberDays: Int
  ): [MealPlanDay]
  mealPlanTemplate(
    """The ID of the object"""
    id: ID!
  ): MealPlanTemplate
  mealPlanTemplates(newerFirst: Boolean, byCoach: ID, excludeCoach: ID, isPublic: Boolean, search: String, coachTypes: [ID!], offset: Int, before: String, after: String, first: Int, last: Int): MealPlanTemplateConnection
  customMealPlan(
    program: ID
    calories: Int!
    protein: Float
    carbs: Float
    fat: Float
    omega3: Float
    days: Int
    error: Float
    format: [MealTime]!

    """Max preparation time in minutes per meal time"""
    maxTimeMinutes: IntValueByMealTime

    """Max num of ingredients in recipe per meal time"""
    maxIngredientsCount: IntValueByMealTime

    """Percentage of the daily kcal goal that each breakfast covers"""
    breakfastDistribution: Float

    """Percentage of the daily kcal goal that each lunch covers"""
    lunchDistribution: Float

    """Percentage of the daily kcal goal that each dinner covers"""
    dinnerDistribution: Float

    """Percentage of the daily kcal goal that each snack covers"""
    snackDistribution: Float
    skipRecipes: [ID!]
  ): [MealPlanDay]
  isUserProgramStarted: Boolean
  outocomplete(
    """query search term. Max: 3 words"""
    query: String
    mealType: MealType
    mealTypes: [MealType]
    enter: Boolean
    before: String
    after: String
    first: Int
    last: Int
  ): OutoCompleteConnection @deprecated(reason: "Deprecating soon.")
  autocomplete(
    """query search term. Max: 3 words"""
    query: String
    mealType: MealType
    mealTypes: [MealType]
    enter: Boolean
    before: String
    after: String
    first: Int
    last: Int
  ): OutoCompleteConnection
  locationAutocomplete(
    """Query search term"""
    query: String!

    """longitude user geolocation -122.1272552"""
    lon: Float!

    """latitude user geolocation 37.4476243"""
    lat: Float!
  ): [LocationAutocomplete]
  usdaFoodByNdbNumber(ndbNumber: String): UsdaFood
  shoppingList(offset: Int, before: String, after: String, first: Int, last: Int, recipe: ID): ListItemConnection
  shoppingListAggregate(id: UUID, offset: Int, before: String, after: String, first: Int, last: Int): AggregateConnection
  shoppingListBadge: Boolean

  """Is ingredient valid for users current program?"""
  serchForAllowedIngredient(
    """Ingredient to search"""
    ingredient: String!
  ): [CPCIngredient]
  brandedFoods(query: String, barcode: String, filter: FoodFilter, before: String, after: String, first: Int, last: Int): BrandedFoodConnection @deprecated(reason: "This query will soon be deprecated. Please use food_search with the parameter is_branded=True instead.")
  commonFoods(query: String, filter: FoodFilter, before: String, after: String, first: Int, last: Int): CommonFoodConnection @deprecated(reason: "This query will soon be deprecated. Please use food_search with the parameter is_common=True instead.")
  myBrandedFoods(id: String, before: String, after: String, first: Int, last: Int): MyBrandedFoodConnection
  myCommonFoods(id: String, before: String, after: String, first: Int, last: Int): MyCommonFoodConnection
  foodSearch(query: String, barcode: String, filter: FoodFilter, isCommon: Boolean, isBranded: Boolean, before: String, after: String, first: Int, last: Int): GenericFoodConnection
  searchProfile(email: String!): ProfileType
  mealLog(fromDate: Date!, toDate: Date!, before: String, after: String, first: Int, last: Int): MealLogConnection
  recentMealLogs: [MealLog]
  frequentMealLogs: [MealLog]
  flags: GenericScalar
  ownMealLogs: [MealLog]
  ownFoodItems(fromDate: Date, toDate: Date, before: String, after: String, first: Int, last: Int): MealLogConnection
  mealLogMacroAggs(start: DateTime, end: DateTime): MealLogMacroAggs
  ownMealLog(id: ID!): MealLog
  ownFoodItem(id: ID!): MealLog
  ownRecipes(fromDate: Date, toDate: Date, before: String, after: String, first: Int, last: Int): MealLogConnection
  ownRecipe(id: ID!): MealLog
  barcodeSearch(barcode: String!): FoodProduct
  macroGoals(date: Date!): MacroGoals
  myProfile: ProfileType
  profileRecommendations: [ProfileRecommendationType]
  foodLog(
    """The ID of the object"""
    id: ID!
  ): MealLog
  foodLogsByUser(fromDate: Date!, toDate: Date!, userId: String!, before: String, after: String, first: Int, last: Int): MealLogConnection
  labTestReports(id: ID, profile: ID, isVisible: Boolean, externalId: String, orderId: String, requisitionId: String, before: String, after: String, first: Int, last: Int): LabTestReportConnection
  countries: [GenericScalar]
  myChecklistItems(id: ID, offset: Int, before: String, after: String, first: Int, last: Int): MyChecklistItemConnection
  nutrientAggregationsByFoodLog(fromDate: Date!, toDate: Date!): NutrientAggregationsByFoodLog
  dietPreferences(id: ID): [DietPreference]
  zoomSessionRecordings(sessionId: String!): ZoomRecording
  zoomAccountRecordings(start: Date!, end: Date!, before: String, after: String, first: Int, last: Int): ZoomRecordingConnection
  userTrackers(id: ID, tracker: TrackerComponent): [UserTracker!]
  log(
    """The ID of the object"""
    id: ID!
  ): Logger

  """List and filter logs"""
  logs(
    """Filter by user email"""
    user: String

    """sorting field"""
    sortBy: SortBy = INDEXED_AT

    """sorting order"""
    sortOrder: SortOrder = ASC
    before: String
    after: String
    first: Int
    last: Int
  ): LoggerConnection
  recipe(
    """The ID of the object"""
    id: ID!
  ): Recipe

  """Search for recipes"""
  recipeSearch(
    """Query search term"""
    query: String

    """Minimum preparation time in minutes"""
    minPrepTime: Int = null

    """Maximum preparation time in minutes"""
    maxPrepTime: Int = null
    tags: [String]
    meals: [String]
    cuisines: [String]
    isPremium: Boolean
    totalTime: Float
    skillLevel: SkillLevel
    dietaryTag: DietaryTag

    """Optional program id"""
    program: String
    ingredients: [String]
    macroNutrientsRange: MacroNutrientsRangeInput
    mealTime: RecipeMealTime
    numberOfIngredients: Int
    hasImage: Boolean
    hasInstructions: Boolean
    servingQuantity: Int
    filter: FoodFilter
    before: String
    after: String
    first: Int
    last: Int
  ): RecipeConnection
  recipeMealTags: [String]
  recipeTags(name: String, offset: Int, before: String, after: String, first: Int, last: Int): RecipeTagConnection
  myFavoriteRecipes(before: String, after: String, first: Int, last: Int): RecipeConnection
  similarMacrosRecipes(recipeId: String, serving: Int, size: Int): [Recipe]
  similarCaloriesRecipes(recipeId: ID!, numberOfServings: Int, size: Int): [Recipe]
  recipeSwapOptions(recipeId: String, serving: Int): RecipeSwapOptions
  recommendedSwaps(
    mealTime: RecipeMealTime!
    forSimpleMealPlan: Boolean

    """Minimum number of servings"""
    minNumberOfServings: Int

    """Maximum number of servings"""
    maxNumberOfServings: Int
  ): RecommendedSwaps
  featuredRecipesByProgram(programId: String): [Recipe]
  searchRecipeByNameOrIngredient(
    """Query search term"""
    query: String
    cuisines: [String!]
    tags: [String!]
  ): RecipeSearchResult
  searchRecipesByIngredients(
    """List of ingredients recipe must contain"""
    mustIngredients: [String]!
    before: String
    after: String
    first: Int
    last: Int
  ): RecipeConnection

  """List users program recipes"""
  premiumProgramRecipes(before: String, after: String, first: Int, last: Int): RecipeConnection

  """Shows recipes with more historical likes/favorited"""
  popularRecipes(
    hidePurchasable: Boolean = true
    cuisines: [String!]
    tags: [String!]

    """Minimum number of servings"""
    minNumberOfServings: Int

    """Maximum number of servings"""
    maxNumberOfServings: Int
    before: String
    after: String
    first: Int
    last: Int
  ): RecipeConnection

  """Shows recipes with more new likes/favorited"""
  trendingRecipes(before: String, after: String, first: Int, last: Int): RecipeConnection
  recipesByMealTime(
    mealTime: RecipeMealTime
    dietaryTags: [DietaryTag]
    hidePurchasable: Boolean = true

    """Maximum preparation time in minutes"""
    maxPrepTime: Int = null
    cuisines: [String!]
    tags: [String!]

    """Minumum number of servings"""
    minNumberOfServings: Int

    """Maximum number of servings"""
    maxNumberOfServings: Int
    before: String
    after: String
    first: Int
    last: Int
  ): RecipeConnection
  recipesByTag(
    tag: String
    dietaryTags: [DietaryTag]
    hidePurchasable: Boolean = true

    """Maximum preparation time in minutes"""
    maxPrepTime: Int = null
    before: String
    after: String
    first: Int
    last: Int
  ): RecipeConnection
  myRecipes(id: ID, before: String, after: String, first: Int, last: Int): UserRecipeConnection
  cuisines(name: String, before: String, after: String, first: Int, last: Int): CuisineConnection
  restaurant(
    """The ID of the object"""
    id: ID!
  ): Restaurant

  """Search for restaurants"""
  restaurantSearch(
    """Query search term"""
    query: String

    """Distance in Kilometers, Default 1km"""
    distance: Int = 3

    """Filter by state. CA, TX"""
    stateProvince: String
    postalCode: String
    address: String

    """longitude geolocation -122.1272552"""
    lon: Float

    """latitude geolocation 37.4476243"""
    lat: Float
    gotAr: Boolean
    priceRating: [PriceRate]
    geoBoundingBox: GeoBoundingBox
    cuisines: [String]

    """show only open restaurants"""
    isOpen: Boolean

    """Optional program id"""
    program: String
    before: String
    after: String
    first: Int
    last: Int
  ): RestaurantConnection
  menuitems(
    """Restaurant database UUID"""
    restaurantId: String!
  ): [MenuItem]
  menuitem(
    """The ID of the object"""
    id: ID!
  ): MenuItem
  menuitemByProgram(
    """Menuitem database UUID"""
    databaseId: String!

    """Program database UUID"""
    programId: String!
  ): MenuItem
  menuitemsByProgram(
    """Restaurant database UUID"""
    restaurantId: String!

    """Program database UUID"""
    programId: String!
  ): [MenuItem]

  """Search for menu items"""
  menuitemSearch(
    """Query search term"""
    query: String
    restaurantId: String
    course: String
    menu: String
    tags: [String]
    meals: [String]
    before: String
    after: String
    first: Int
    last: Int
  ): MenuItemConnection
  menuitemMealTags: [String]
  menuitemTags: [String]
  myFavoriteRestaurants(before: String, after: String, first: Int, last: Int): RestaurantConnection
  myFavoriteMenuitems(before: String, after: String, first: Int, last: Int): MenuItemConnection
  restaurantsByLocation(
    """longitude geolocation -122.1272552"""
    lon: Float

    """latitude geolocation 37.4476243"""
    lat: Float
    before: String
    after: String
    first: Int
    last: Int
  ): RestaurantConnection
  restaurantSearchByLocation(
    """Query search term"""
    query: String
    cuisine: String

    """longitude user geolocation -122.1272552"""
    lon: Float!

    """latitude user geolocation 37.4476243"""
    lat: Float!
    geolon: Float
    geolat: Float

    """Optionally add a search bounding box"""
    geoBoundingBox: GeoBoundingBox
  ): RestaurantSearchResult
  recommendedMenuitems(
    """longitude user geolocation -122.1272552"""
    lon: Float!

    """latitude user geolocation 37.4476243"""
    lat: Float!
  ): [MenuItem]
  restaurantAutocomplete(
    """Query search term"""
    query: String!

    """longitude user geolocation -122.1272552"""
    lon: Float!

    """latitude user geolocation 37.4476243"""
    lat: Float!
  ): [Restaurant]
  restaurantRecommendedMenuitems(
    """Restaurant database UUID"""
    restaurantId: String!
  ): [MenuItem]
  onProgramPopularRestaurants(
    """longitude user geolocation -122.1272552"""
    lon: Float!

    """latitude user geolocation 37.4476243"""
    lat: Float!
  ): [Restaurant]
  program(
    """The ID of the object"""
    id: ID!
  ): Program
  programs(orderBy: ProgramOrderBy, filters: ProgramFiltersInput, offset: Int, before: String, after: String, first: Int, last: Int, isActive: Boolean, isPremium: Boolean): ProgramConnection
  quizPrograms: [QuizProgram]
  quizAnswers: [QuizAnswer!]!
  restriction(
    """The ID of the object"""
    id: ID!
  ): Restriction

  """All restrictions"""
  restrictions(before: String, after: String, first: Int, last: Int): RestrictionConnection
  assessment(id: ID!): Assessment
  assessments(filters: AssessmentsFilterInput, offset: Int, before: String, after: String, first: Int, last: Int): AssessmentConnection
  questions(filters: QuestionsFilterInput, offset: Int, before: String, after: String, first: Int, last: Int): AssessmentQuestionConnection
  question(id: ID!): AssessmentQuestion
  answer(id: ID!): AssessmentAnswer
  answers(filters: AnswersFilterInput, offset: Int, before: String, after: String, first: Int, last: Int): AssessmentAnswerConnection
  userAnswersByAssessment(
    """Assessment ID"""
    id: ID!
    filters: UserAnswersByAssessmentInput
  ): Assessment
  userAssessment(assessmentId: ID!): Assessment
  userAssessments(filters: UserAssessmentsFilterInput, offset: Int, before: String, after: String, first: Int, last: Int): AssessmentConnection
  usersProgress(filters: UsersProgressFilterInput, offset: Int, before: String, after: String, first: Int, last: Int): UserProgressConnection
  allUsersAnswersByAssessment(assessmentId: ID!, orderBy: UserAnswerOrderByInput, offset: Int, before: String, after: String, first: Int, last: Int): UserAnswerConnection
  questionAttributes(offset: Int, before: String, after: String, first: Int, last: Int): AssessmentQuestionAttributeConnection
  supplementRecommendations(assessmentId: ID!, top: Int = 3): [AssessmentAnswerSupplement!]
  nextQuestion(questionId: ID!): AssessmentQuestion
  userAssessmentHistory(assessmentId: ID!, offset: Int, before: String, after: String, first: Int, last: Int): UserAnswerHistoryConnection
  biomarkerCatalog(id: ID, filters: BiomarkerFilterInput, before: String, after: String, first: Int, last: Int): BiomarkerConnection
  biomarkers(id: ID, filters: BiomarkerFilterInput, before: String, after: String, first: Int, last: Int): BiomarkerConnection
  biomarkerCategories(id: ID, parentId: ID, filters: BiomarkerCategoryFilterInput, orderBy: BiomarkerCategoryOrderBy, offset: Int, before: String, after: String, first: Int, last: Int): BiomarkerCategoryConnection
  biomarkerUnits(id: ID, offset: Int, before: String, after: String, first: Int, last: Int): BiomarkerUnitConnection
  biomarkerResults(filters: BiomarkerResultsFilterInput): [ProfileBiomarker!]
  historicalBiomarkerResults(filters: HistoricalBiomarkerResultsFilterInput, offset: Int, before: String, after: String, first: Int, last: Int): ProfileBiomarkerConnection
  historicalResultsByBiomarker(
    """Biomarker ID"""
    id: ID!
  ): ProfileBiomarkerResult
  articlesRecommended(id: ID, offset: Int, before: String, after: String, first: Int, last: Int): ArticleRecommendedConnection
  supplementsRecommended(id: ID, offset: Int, before: String, after: String, first: Int, last: Int): SupplementRecommendedConnection
  dashboard: Dashboard
  dailyRecap(date: Date!, group: GroupQuestion): [DailyQuestion!]!
  dailyRecaps(startDate: Date!, endDate: Date!, group: GroupQuestion): [DailyRecap!]!
  dailyRecapQuestions(group: GroupQuestion): [DailyQuestion!]!
  streaks(startDate: Date!, endDate: Date!, source: SourceType): [Streak!]!
  streaksStats(startDate: Date!, endDate: Date!, source: SourceType): StreaksStats!
  dailyMoodSummary(startDate: Date!, endDate: Date!): DailyMoodSummary!
  weightTracker(startDate: Date!, endDate: Date!, source: SourceType): WeightTracker
  hydration(startDate: Date!, endDate: Date!, source: SourceType, toMl: Boolean): [Hydration!]!
  mealTracker(startDate: Date!, endDate: Date!): [MealTrack]!
  intakesChecklist(start: Date!, end: Date!, category: IntakeCategory!): IntakesChecklist
  foodLogs(start: Date!, end: Date!, first: Int, after: String, id: ID): FoodLogConnection!
  stepsCounter(start: DateTime!, end: DateTime!, first: Int, after: String, id: ID, source: SourceType): StepsCounterConnection!
  exerciseTracker(start: DateTime!, end: DateTime!, first: Int, after: String, id: ID, source: SourceType): ExerciseEntriesConnection!
  myChecklistLogs(start: Date!, end: Date!): MyChecklistLogs!
  sleepTimes(start: Date!, end: Date!, first: Int, after: String, id: ID, source: SourceType): SleepTimesConnnection!
  sleepQualityScores(start: Date!, end: Date!, first: Int, after: String, id: ID, source: SourceType): SleepQualityScoresConnnection!
  hrvLogs(start: DateTime!, end: DateTime!, first: Int, after: String, id: ID, source: SourceType): HrvLogsConnnection!
  heartRateLogs(start: DateTime!, end: DateTime!, first: Int, after: String, id: ID, source: SourceType): HeartRateLogsConnnection!

  """
  Returns the goals for each enabled third party's components. By Example: SLEEP_TIME_TRACKER: default is 480 minutes (8h)
  """
  trackingDailyGoals: TrackingDailyGoals!
  nextIntakes(category: IntakeCategory!): IntakesChecklistDay
  insights(date: Date!, category: InsightsCategory): [InsightsByCategory!]!
  wellnessScoreLastSevenDays(date: Date!, source: SourceType): WellnessScoreLastSevenDays!
  bloodPressureLogs(start: DateTime!, end: DateTime!, first: Int, after: String, id: ID, source: SourceType): BloodPressureLogsConnnection!
  expressMealTracks(start: DateTime!, end: DateTime!, first: Int, after: String, id: ID, mealTime: MealTime): ExpressMealTrackConnection!
  userSymptoms(start: DateTime!, end: DateTime!, first: Int, after: String, id: ID): SymptomLogsConnection!
  symptomStats(start: Date!, end: Date!): [SymptomStats]!
  recentSymptoms: [Symptom!]!
  todayFoods(startDate: Date!, endDate: Date!): Checklist @deprecated(reason: "No longer supported. Use intakesChecklist instead")
  todaySupplements(startDate: Date!, endDate: Date!): Checklist @deprecated(reason: "No longer supported. Use intakesChecklist instead")
  checkedIntakes(start: Date!, end: Date!, category: IntakeCategory!): DailyChecklist @deprecated(reason: "No longer supported. Use intakesChecklist instead. This query doesn't support supplements on plan")
}

input QuestionsFilterInput {
  assessmentId: ID
  canSkip: Boolean
  questionType: QuestionType
  text: String
}

enum QuestionType {
  SINGLE_SELECT
  MULTI_SELECT
  OPEN_TEXT
  OPEN_QUESTION
  OPEN_NUMBER
  DATE_PICKER
  TIME_PICKER
  DROPDOWN
}

type QuizAnswer {
  id: ID!
  answer: String!
  question: String!
  timestamp: DateTime!
  questionImage: String
  answerImage: String
}

type QuizInfo {
  isActive: Boolean
  label: String
}

type QuizProgram {
  name: String
  programId: String
  author: String
  authorAvatar: String
  backgroundImage: String
  description: String
  isPremium: String
  experience: QuizInfo
  health: QuizInfo
  preferences: QuizInfo
}

input Range {
  gte: Float!
  lte: Float!
}

input RangeByMealTimeInput {
  breakfast: RangeInput
  dinner: RangeInput
  lunch: RangeInput
  snack: RangeInput
}

input RangeFilter {
  gte: Float
  lte: Float
}

input RangeInput {
  min: Int
  max: Int
}

input RangeOperator {
  gt: Float
  lt: Float
  gte: Float
  lte: Float
}

type RawNutrientsFull {
  energy: Float
  fiber: Float
  saturatedFat: Float
  transFats: Float
  cholesterol: Float
  sodiumNa: Float
  potassiumK: Float
}

type ReassignChatConversation {
  success: Boolean!
  message: String!
}

input ReassignChatConversationInput {
  coachId: ID!
  conversationSid: String!
}

type Recipe implements Node {
  """The ID of the object"""
  id: ID!
  databaseId: String
  totalTime: String
  totalTimeInSeconds: Int
  tags: [String]
  name: String
  rating: Int
  numberOfServings: Int
  yieldText: String
  ingredientLines: [String]
  ingredients: [Ingredient]
  language: String
  url: String @deprecated(reason: "Use Source.recipeUrl instead")
  text: String
  logo: String
  instructions: [String]
  recipeType: String
  isActive: Boolean
  course: String @deprecated(reason: "Use courses instead")
  courses: [String]
  cuisine: String @deprecated(reason: "Use cuisines instead")
  cuisines: [String]
  sgCuisines: [String]
  source: Source
  hasTrainableIngredients: Boolean
  nutritionEstimates: NutritionEstimates @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  completeNutritionEstimates: GenericScalar @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  mainImage: String
  squareImage: String
  sourceUrl: String @deprecated(reason: "Use Source.recipeUrl instead")
  sgValidated: Boolean
  isIndexed: Boolean @deprecated(reason: "Not used, will be removed")
  isPremium: Boolean
  isFeatured: Boolean
  author: String
  authorAvatar: String
  authors: String @deprecated(reason: "Use author instead of this")
  programIds: [String]
  indexedAt: DateTime
  updatedAt: DateTime
  nameLowercase: String @deprecated(reason: "Not used, will be removed")
  cleanName: String
  ingredientsCount: Int
  sourceUrlNotWorks: Boolean @deprecated(reason: "Not used, will be removed")
  syntaxIngs: [String]
  mealTags: [String]
  adherence: Float @deprecated(reason: "Not used, will be removed")
  adherenceDetails: Adherence
  usersFavorite: [String]
  favoritesCount: Int
  isUserFavorite: Boolean
  usersShoppingList: [String]
  inUserShoppingList: Boolean
  nutrients: Nutrients @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutrientsFull: RawNutrientsFull @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  datasetType: String @deprecated(reason: "Not used, internal use only")
  weightInGrams: Float
  relativeCalories: RelativeCalories
  sgScores: SgScores @deprecated(reason: "Not used, internal use only")
  nutrientsPerServing: NutrientsPerServing

  """Weight in grams per recipe serving"""
  servingWeight: Float
  serving: Int
  servings: [Servings] @deprecated(reason: "Not used, will be removed")
  isRestricted: Boolean
  isLogged: Boolean
  nutritionalInfo: NutritionalInfo

  """A more structured version of the recipe ingredient lines."""
  parsedIngredientLines(preferredUnitSystem: UnitSystem): [IngredientLine] @deprecated(reason: "Not used, will be removed")
  caloriesPerServing: CaloriesPerServing
  isPurchasable: Boolean
  sourceUrlWorks: Boolean!
  externalId: String
  mealBalanceIndex: MealBalanceIndexScore
}

type RecipeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RecipeEdge]!
}

"""A Relay edge containing a `Recipe` and its cursor."""
type RecipeEdge {
  """The item at the end of the edge"""
  node: Recipe

  """A cursor for use in pagination"""
  cursor: String!
}

input RecipeInShoppingList {
  recipeId: String!
  servings: Int = 1
}

enum RecipeMealTime {
  BREAKFAST
  LUNCH
  DINNER
  SNACK
  TREAT_DESSERT
}

type RecipeProxy {
  recipe: Recipe!
}

type RecipeSearchResult {
  onPlan: [Recipe]
  otherResults: [Recipe]
}

"""typed returned by `recipeSwapOptions` query"""
type RecipeSwapOptions {
  onPlan(size: Int): [Recipe]
  similar(size: Int): [Recipe]
}

type RecipeTag implements Node {
  displayName: String!
  termName: String!
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
}

type RecipeTagConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RecipeTagEdge]!
}

"""A Relay edge containing a `RecipeTag` and its cursor."""
type RecipeTagEdge {
  """The item at the end of the edge"""
  node: RecipeTag

  """A cursor for use in pagination"""
  cursor: String!
}

type RecommendationCatalogType {
  id: UUID!
  updatedAt: DateTime
  createdAt: DateTime
  reference: String!
  title: String!
  image: String
  subtitle: String
  url: String
  textMain: String
  textAdditional1: String
  textAdditional2: String
  profilerecommendationSet: [ProfileRecommendationType!]!
  databaseId: String
}

type RecommendedSwaps {
  meals: [Recipe]
  recipes: [Recipe]
}

type RelativeCalories {
  carbs: Float
  fat: Float
  protein: Float
  dha: Float
  dpa: Float
  epa: Float
  ala: Float
  saturatedFat: Float
  monounsaturatedFat: Float
  polyunsaturatedFat: Float
  transFat: Float
  omega3: Float
}

type RemoveCoachChatConversation {
  success: Boolean!
  message: String!
}

input RemoveCoachChatConversationInput {
  coachId: ID!
  conversationSid: String!
}

type RemoveFavoriteArticle {
  success: Boolean!
  message: String!
}

type RemoveFromShoppingList {
  success: Boolean
  message: String
}

type RemoveMealLogMutation {
  success: Boolean
}

type RemoveMealPlan {
  success: Boolean
  message: String
}

type RemoveMealPlanRecipe {
  success: Boolean!
  message: String!
}

"""Removes users own `food` or own `recipe`"""
type RemoveOwnMeal {
  success: Boolean
  message: String
}

type RemoveUserConsent {
  success: Boolean!
  message: String!
}

type RemoveUserFromJourney {
  success: Boolean!
  message: String!
}

input RemoveUserFromJourneyInput {
  profile: ID!
  journey: ID!
}

type RequestAccountDeletion {
  success: Boolean!
  message: String!
}

type RequestResetPassword {
  success: Boolean!
  message: String!
  resetPasswordCode: String
}

type RequestUserDataDownload {
  success: Boolean!
  message: String!
}

type ResendAppointmentConfirmationEmail {
  success: Boolean!
  message: String!
}

type ResetPassword {
  success: Boolean!
  message: String!
}

type Restaurant implements Node {
  id: ID!
  databaseId: String
  locationId: String
  name: String
  shortName: String
  phone: String
  description: String
  location: [Float]
  hours: Hours
  cuisine: String @deprecated(reason: "Use cuisines instead of cuisine")
  cuisines: [String]
  businessType: String
  isActive: Boolean
  createdAt: DateTime
  updatedAt: DateTime
  minPriceRange: Float @deprecated(reason: "no longer used")
  maxPriceRange: Float @deprecated(reason: "no longer used")
  websiteUrl: String
  address1: String
  postalCode: String
  cityTown: String
  stateProvince: String
  country: String
  priceRating: String
  indexedAt: DateTime
  gotAr: Boolean
  isOwnerVerified: Boolean
  isRecomended: Boolean

  """Recommended menuitem"""
  recommendation: String

  """Number of recommendations if any"""
  recommendationsCount: Int
  photos: [String]
  isOpen: Boolean
  cuisineTag: String @deprecated(reason: "Use cuisines instead of cuisine_tag")
  usersFavorite: [String]
  favoritesCount: Int
  isUserFavorite: Boolean
  type: String
  isClosed: Boolean
  yelpReviewCount: Int
  yelpRating: Float
  suggest: String
  objectType: String
  googleMapsUrl: String
  restaurantDeliveryPlatformsUrls: GenericScalar
  restaurantImageUrls: GenericScalar
}

type RestaurantConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RestaurantEdge]!
  totalCount: Int
}

"""A Relay edge containing a `Restaurant` and its cursor."""
type RestaurantEdge {
  """The item at the end of the edge"""
  node: Restaurant

  """A cursor for use in pagination"""
  cursor: String!
  other: String
}

type RestaurantSearchResult {
  onPlan: [Restaurant]
  otherResults: [Restaurant]
}

type Restriction implements Node {
  """The ID of the object"""
  id: ID!
  name: String
  slugname: String
  databaseId: String @deprecated(reason: "use ID!")
  subcategory: String
  isOnProgram: Boolean
}

type RestrictionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RestrictionEdge]!
}

"""A Relay edge containing a `Restriction` and its cursor."""
type RestrictionEdge {
  """The item at the end of the edge"""
  node: Restriction

  """A cursor for use in pagination"""
  cursor: String!
}

type SaveAIFoodLog {
  success: Boolean!
  message: String!
}

input SaveAIFoodLogInput {
  id: ID!
  mealTime: MealTime!

  """Food name used for this log"""
  foodName: String

  """DateTime to log food on, defaults to now()"""
  datetime: DateTime

  """Previously uploaded image url"""
  imageUrl: String
}

type SaveZoomSessionForAppointment {
  success: Boolean!
  message: String!
}

input SaveZoomSessionForAppointmentInput {
  appointment: ID!
  sessionId: String!
}

type SelectDailyRecapQuestions {
  success: Boolean!
  message: String!
}

type SendFeedback {
  success: Boolean
  message: String
}

type SensitiveProfileAttributes {
  success: Boolean
  errors: [ErrorType]
}

type Servings {
  amount: Float
  description: String
  equivalent: Float
  unit: String
  selected: Boolean
}

type SetActiveSource {
  success: Boolean!
  message: String!
}

type SetMealPlanToTemplate {
  success: Boolean!
  message: String!
}

type SetThirdPartyAppUserAsTest {
  success: Boolean!
  message: String!
  errors: [FormError!]
  user: User
}

input SetThirdPartyAppUserAsTestInput {
  user: ID!
  isTest: Boolean!
}

type SetUserAnswers {
  success: Boolean!
  message: String!
  errors: [FormError!]
  userAnswers: [UserAnswer!]
  nextQuestion: AssessmentQuestion
}

input SetUserAnswersInput {
  assessmentId: ID!
  userAnswers: [UserAnswerInput!]!
}

type SgScores {
  keto: Float
}

input SimpleMPFiltersInput {
  kcalRange: RangeByMealTimeInput
  tags: TermValuesByMealTimeInput
  cuisines: [String]

  """Max preparation time in minutes per meal time"""
  maxTimeMinutes: IntValueByMealTime

  """Minimum number of servings"""
  minNumberOfServings: Int

  """Maximum number of servings"""
  maxNumberOfServings: Int
}

input SingleSupplementActivableProtocolInput {
  supplementId: ID!
  monday: Boolean
  tuesday: Boolean
  wednesday: Boolean
  thursday: Boolean
  friday: Boolean
  saturday: Boolean
  sunday: Boolean
  directionsOfUse: [DirectionsOfUseInput!]
  length: Int!
  isActive: Boolean
  frequency: SPFrequencyInput
}

type SitemapUrlType {
  id: ID
  knowledgeBase: ID
  url: String!
  lastCrawledAt: DateTime!
  sitemapUrl: String!
  taskStatus: WellnessgptSitemapURLTaskStatusChoices!
}

enum SkillLevel {
  EASY
  MEDIUM
  EXPERT
}

input SleepQualityEntryInput {
  value: PositiveInt!
  date: Date!
  source: SourceType!
}

type SleepQualityScore {
  id: ID!

  """
  sleep quality index scaling from 0 to 100, where the values above 77 signify
  good sleep quality, while those below 77 signify poor sleep quality.
  """
  value: Int! @deprecated
  floatValue: Float!
  source: SourceType!
  date: Date!

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
}

type SleepQualityScoreEdge {
  node: SleepQualityScore
  cursor: String!
}

type SleepQualityScoresConnnection {
  pageInfo: PageInfo!
  edges: [SleepQualityScoreEdge]!
  average: Int! @deprecated
  floatAverage: Float!
}

type SleepTime {
  id: ID!

  """Sleep duration in minutes"""
  value: Int! @deprecated
  floatValue: Float!
  source: SourceType!
  date: Date!
  createdAt: DateTime!

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
}

type SleepTimeEdge {
  node: SleepTime
  cursor: String!
}

input SleepTimeEntryInput {
  value: PositiveInt!
  date: Date!
  source: SourceType!
}

type SleepTimesConnnection {
  pageInfo: PageInfo!
  edges: [SleepTimeEdge]!
  dailyGoal: Int!
  totalTime: Int!
  latestEntry: DateTime
}

enum SortBy {
  """Orders logs by indexed_at field"""
  INDEXED_AT
}

enum SortOrder {
  """Sort in ascending order"""
  ASC

  """Sort in descending order"""
  DESC
}

type Source {
  siteUrl: String
  displayName: String
  recipeUrl: String!
}

enum SourceType {
  SUGGESTIC
  FITBIT
  GARMIN
  POLAR
  MISFIT
  WITHINGS
  STRAVA
  GOOGLEFIT_REST
  GOOGLEFIT_NATIVE
  SUUNTO
  OURA
  IHEALTH
  APPLE
  SAMSUNG
  OMRONCONNECT
  OMRONWELLNESS
  HUAWEIHEALTH
  HEALTHCONNECT
}

type SPFrequency {
  times: Int!
  periodicity: SPPeriodicity!
}

input SPFrequencyInput {
  times: Int!
  periodicity: SPPeriodicity!
}

enum SPPeriodicity {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

input SPProtocolInput {
  protocolId: ID!
  frequency: SPFrequencyInput
  isActive: Boolean
  monday: Boolean
  tuesday: Boolean
  wednesday: Boolean
  thursday: Boolean
  friday: Boolean
  saturday: Boolean
  sunday: Boolean
  directionsOfUse: [DirectionsOfUseInput!]!
}

input SPUpdateProtocolInput {
  protocolId: ID!
  frequency: SPFrequencyInput
  isActive: Boolean
  monday: Boolean
  tuesday: Boolean
  wednesday: Boolean
  thursday: Boolean
  friday: Boolean
  saturday: Boolean
  sunday: Boolean
  directionsOfUse: [DirectionsOfUseInput!]
}

input StartChatConversationInput {
  assistant: ID
  clientMutationId: String
}

type StartChatConversationPayload {
  success: Boolean!
  message: String!
  conversationSid: String
  clientMutationId: String
}

type StartJourneys {
  message: String
  success: Boolean
}

type StartOverMealPlan {
  """true if the meal plan was successfully restarted"""
  success: Boolean

  """
  error logs or info message. See "success"
  """
  message: String
}

type StepCount {
  id: ID!
  datetime: DateTime!
  createdAt: DateTime!
  steps: Int!
  source: SourceType!

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
}

input StepCountEntryInput {
  datetime: DateTime!
  steps: PositiveInt!
  source: SourceType!
}

type StepsCounterConnection {
  pageInfo: PageInfo!
  edges: [StepsCounterEdge]!
  dailyGoal: Int!
  distance: Float!
  latestEntry: DateTime
}

type StepsCounterEdge {
  node: StepCount
  cursor: String!
}

type StoreConversationSummary {
  success: Boolean!
  message: String!
}

input StoreConversationSummaryInput {
  text: String!
}

"""An enumeration."""
enum StoreSubscriptionBillingPeriodChoices {
  """Once"""
  ONCE

  """Month"""
  MONTH

  """3 Months"""
  TRI_MONTH

  """6 Months"""
  SEMESTER

  """Year"""
  YEAR
}

"""An enumeration."""
enum StoreSubscriptionDurationChoices {
  """Year"""
  YEAR

  """1 Month"""
  MONTH

  """3 Months"""
  TRI_MONTH

  """6 Months"""
  SEMESTER

  """Forever"""
  FOREVER
}

type Streak {
  isToday: Boolean
  dayStatus: DayStatus
  date: Date
  hasPreviousStreak: Boolean
  expectedActivities: [EntryType]
  activities: [EntryType] @deprecated
  empties: [EntryType]
  completed: [EntryType]
  longestPerfectDayStreakEver: Int
  longestStreakEver: Int! @deprecated
  totalPerfectDays: Int! @deprecated
}

type StreaksStats {
  totalPerfectDays: Int!
  longestStreak: Int!
}

type SubmitFeedback {
  success: Boolean!
  message: String!
  feedback: WorkflowExecutionLogComment
}

type SubscriptionTransaction implements Node {
  updatedAt: DateTime
  createdAt: DateTime
  transactionProvider: String!
  expirationDate: DateTime
  isDowngrade: Boolean!
  externalTransactionId: String
  parentId: String
  parentType: String
  program: Program
  cancellationDate: DateTime
  cancellationSource: String
  email: String
  livemode: Boolean!
  isActive: Boolean!
  isRenewal: Boolean!
  isProcess: Boolean!
  isTrialPeriod: Boolean!
  isInitial: Boolean!
  isCanceled: Boolean!
  hasRefund: Boolean!

  """The ID of the object"""
  id: ID!
  isExpired: Boolean
  subscription: SubscriptionType
  purchaseDate: DateTime
  programStat: String
  expiresStat: String
}

type SubscriptionTransactionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SubscriptionTransactionEdge]!
}

"""A Relay edge containing a `SubscriptionTransaction` and its cursor."""
type SubscriptionTransactionEdge {
  """The item at the end of the edge"""
  node: SubscriptionTransaction

  """A cursor for use in pagination"""
  cursor: String!
}

type SubscriptionType implements Node {
  id: ID!
  updatedAt: DateTime
  createdAt: DateTime
  permissions: [String!]
  name: String!
  isActive: Boolean!
  billingPeriod: StoreSubscriptionBillingPeriodChoices
  duration: StoreSubscriptionDurationChoices!

  """Amounts are in cents"""
  totalPrice: Int!

  """Amounts are in cents"""
  periodPrice: Int!
  appleId: String
  googleplaySku: String
  trialPeriodDays: Int!
  isRecurring: Boolean!
  databaseId: String
  product: ProductType
}

type SubscriptionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SubscriptionTypeEdge]!
}

"""A Relay edge containing a `SubscriptionType` and its cursor."""
type SubscriptionTypeEdge {
  """The item at the end of the edge"""
  node: SubscriptionType

  """A cursor for use in pagination"""
  cursor: String!
}

type Suggestion {
  name: String
  suggest: String
  mealType: MealType
  profileId: String
  location: GeoPoint
  mealTypeDisplayName: String
  databaseId: String
  indexedAt: DateTime
  updatedAt: DateTime
  extraInfo: String
  servings: [Servings]
  nutrients: Nutrients @deprecated(reason: "Use nutritionalInfo instead")
  unitOption: String
  courses: [String]
  brand: String
  servingWeight: Float
  serving: Int
  barcode: String
  manufacName: String
  foodBlockOrManufacturer: String
  author: String
  secondaryInfoText: String
  isVerified: Boolean
  nutritionalInfo: NutritionalInfo
  isRawIngredient: Boolean
}

type Supplement implements Node {
  id: ID!
  name: String!
  description: String
  category: String!
  mainImage: String!
  images: [String!]
  brand: String!
  directionsOfUse: [SupplementDirection!]!
  directionsOfUseText: String
  servingName: String!
  sizeCount: Int!
  externalId: String
  sku: String
  storeId: String
  shopifyVariantId: String
  shopifyParentId: String
  instructions: String
  ingredients: String
  supplementFacts: String
  productUrl: String
  ownerParty: ThirdParty
  type: SupplementType!
  conditions: [Condition!]
  createdAt: DateTime!
  updatedAt: DateTime!
  answerSet(offset: Int, before: String, after: String, first: Int, last: Int): AssessmentAnswerConnection!
  answersupplementSet(offset: Int, before: String, after: String, first: Int, last: Int): AssessmentAnswerSupplementConnection!
  supplementrecommendationSet(offset: Int, before: String, after: String, first: Int, last: Int): SupplementRecommendedConnection!
  protocolBundle(offset: Int, before: String, after: String, first: Int, last: Int): ProtocolConnection!
}

input SupplementCartItem {
  variantId: ID!
  quantity: Int!
}

type SupplementConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SupplementEdge]!
}

type SupplementDirection {
  quantity: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
  id: ID!
  timeOfDay: TimeOfDay!
}

"""A Relay edge containing a `Supplement` and its cursor."""
type SupplementEdge {
  """The item at the end of the edge"""
  node: Supplement

  """A cursor for use in pagination"""
  cursor: String!
}

type SupplementOnPlan {
  order: Int!
  planName: String!
  checked: Boolean!
  quantity: Float!
  timeOfDay: TimeOfDay
  supplement: Supplement!
}

type SupplementParent {
  id: ID!
  title: String!
  availableForSale: Boolean!
  options: [ProductOption!]
  variants: [ProductVariant!]!
  featuredImage: String
}

type SupplementPlan implements Node {
  name: String!
  overview: String
  nutrition: String
  exercise: String
  resources: String
  createdAt: DateTime!
  updatedAt: DateTime!
  startDate: Date!
  isActive: Boolean!
  visibility: Boolean!
  id: ID!
  protocols(group: ProtocolGroup, coachTypes: [ID!]): [SupplementPlanProtocol!]!
}

type SupplementPlanConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SupplementPlanEdge]!
}

"""A Relay edge containing a `SupplementPlan` and its cursor."""
type SupplementPlanEdge {
  """The item at the end of the edge"""
  node: SupplementPlan

  """A cursor for use in pagination"""
  cursor: String!
}

type SupplementPlanProtocol {
  id: ID!
  order: Int!
  monday: Boolean!
  tuesday: Boolean!
  wednesday: Boolean!
  thursday: Boolean!
  friday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  isActive: Boolean!
  protocol: Protocol!
  directionsOfUse: [SupplementDirection!]!
  startsAt: DateTime
  endsAt: DateTime
  frequency: SPFrequency
}

type SupplementProtocol {
  id: ID!
  supplement: Supplement!
  directionsOfUse: [SupplementDirection!]!
  monday: Boolean!
  tuesday: Boolean!
  wednesday: Boolean!
  thursday: Boolean!
  friday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
}

type SupplementRecommended implements Node {
  valueMax: Float
  valueMin: Float
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
  biomarker: Biomarker!
  supplement: Supplement!
  normalValues: [GenericScalar!]
}

type SupplementRecommendedConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SupplementRecommendedEdge]!
}

"""A Relay edge containing a `SupplementRecommended` and its cursor."""
type SupplementRecommendedEdge {
  """The item at the end of the edge"""
  node: SupplementRecommended

  """A cursor for use in pagination"""
  cursor: String!
}

enum SupplementType {
  PRODUCT
  INTERVENTION
  SUPPLEMENT
  MEDICATION
}

"""
Swaps a recipe from profile's MP, adding it to a specific day
or every day in the same meal_fmt position
"""
type SwapMealPlanRecipe {
  mealPlan: [MealPlanDay] @deprecated(reason: "Not used, will be removed")
  success: Boolean
  message: String
}

type Symptom implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
  categories: [SymptomCategory]
}

type SymptomCategory implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SymptomCategoryConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SymptomCategoryEdge]!
}

"""A Relay edge containing a `SymptomCategory` and its cursor."""
type SymptomCategoryEdge {
  """The item at the end of the edge"""
  node: SymptomCategory

  """A cursor for use in pagination"""
  cursor: String!
}

type SymptomConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SymptomEdge]!
}

"""A Relay edge containing a `Symptom` and its cursor."""
type SymptomEdge {
  """The item at the end of the edge"""
  node: Symptom

  """A cursor for use in pagination"""
  cursor: String!
}

type SymptomLog {
  id: ID!
  symptomId: ID!
  symptom: Symptom!
  intensity: Int!
  timestamp: DateTime!
  notes: String
  createdAt: DateTime
  updatedAt: DateTime
}

type SymptomLogs {
  node: SymptomLog
  cursor: String!
}

type SymptomLogsConnection {
  pageInfo: PageInfo!
  edges: [SymptomLogs]!
}

type SymptomStats {
  symptomId: ID!
  symptom: Symptom!
  count: Int!
  total: Float!
  average: Float!
  min: Float!
  max: Float!
}

type TaskItemType {
  id: ID!
  keyHash: String
  taskListId: String
  name: String
  isCompleted: Boolean
}

type TaskListType {
  id: ID!
  name: String!
  taskItems: [TaskItemType]
  databaseId: String
}

type Tendency {
  difference: Float
  type: TendencyType
}

enum TendencyType {
  DOWN
  UP
}

input TermValuesByMealTimeInput {
  breakfast: [String!]
  dinner: [String!]
  lunch: [String!]
  snack: [String!]
}

type ThirdParty implements Node {
  """The ID of the object"""
  id: ID!
  slug: String!
  clientId: UUID!
  widgetChatFlag: Boolean!
  chatMaintenanceFlag: Boolean!
  vellumMainWorkflow: String
  vellumJourneyWorkflow: String
  defaultAssistant: Assistant
}

type ThirdPartyAppCustomization implements Node {
  """The ID of the object"""
  id: ID!
  logo: String
  backgroundGradientColor1: String
  backgroundGradientColor2: String
  primaryColor: String
  secondaryColor: String
  selectedFeatures: [String!]!
}

type ThirdPartyConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ThirdPartyEdge]!
}

type ThirdPartyDailyRecapQuestion implements Node {
  """The ID of the object"""
  id: ID!
  imageUrl: String
  program: Program
  group: DailyRecapQuestionGroup
  isDefault: Boolean
  lang: JSONString!
  answers: [DailyRecapAnswer!]
  question: String
  title: String
}

type ThirdPartyDailyRecapQuestionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ThirdPartyDailyRecapQuestionEdge]!
}

"""
A Relay edge containing a `ThirdPartyDailyRecapQuestion` and its cursor.
"""
type ThirdPartyDailyRecapQuestionEdge {
  """The item at the end of the edge"""
  node: ThirdPartyDailyRecapQuestion

  """A cursor for use in pagination"""
  cursor: String!
}

"""A Relay edge containing a `ThirdParty` and its cursor."""
type ThirdPartyEdge {
  """The item at the end of the edge"""
  node: ThirdParty

  """A cursor for use in pagination"""
  cursor: String!
}

type ThirdPartyGoal implements Node {
  """The ID of the object"""
  id: ID!
  goal: ClientApiThirdPartyGoalGoalChoices!
  value: Float!
}

"""
The `Time` scalar type represents a Time value as
specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Time

enum TimeOfDay {
  AT_WAKING
  WITH_BREAKFAST
  WITH_LUNCH
  WITH_DINNER
  AT_BEDTIME
  ANYTIME
}

type TimePeriod {
  """These are the coaches available in this TimePeriod"""
  coaches: [Coach!]!
  start: DateTime!
  end: DateTime!
}

type ToggleShoppingListItem {
  success: Boolean
  message: String
}

type ToggleShoppingListItems {
  success: Boolean
  message: String
}

type ToggleTaskCompleted {
  message: String
  success: Boolean
}

enum TrackerComponent {
  DAILY_RECAP
  DAILY_MOOD
  WEIGHT_TRACKER
  MP_MEAL_TRACKER
  HYDRATION_TRACKER
  TODAY_FOOD
  TODAY_SUPPLEMENT
  FOOD_LOGS
  STEPS_TRACKER
  EXERCISE_TRACKER
  PLAN_SUPPLEMENT
  MY_CHECKLIST_TRACKER
  SLEEP_TIME_TRACKER
  SLEEP_QUALITY_SCORE_TRACKER
  HRV_TRACKER
  HEART_RATE_TRACKER
  PLAN_SUPPLEMENTS_MY_CHECKLIST
  FOOD_LOG_MEAL_TRACKER
  BLOOD_PRESSURE_TRACKER
  SYMPTOM_TRACKER
}

type TrackingDailyGoal {
  entryType: EntryType!
  goal: Int
}

type TrackingDailyGoals {
  dailyGoals: [TrackingDailyGoal!]!
}

type UncheckIntake {
  success: Boolean!
  message: String!
}

type UncheckTodayFood {
  success: Boolean!
  message: String!
}

type UncheckTodaySupplement {
  success: Boolean!
  message: String!
}

enum UnitSystem {
  IMPERIAL
  METRIC
}

type UnlinkUserAssessment {
  success: Boolean!
  message: String!
}

type UpdateAnswer {
  success: Boolean!
  message: String!
  errors: [FormError!]
  answer: AssessmentAnswer
}

input UpdateAnswerInput {
  id: ID!
  text: String
  value: String
  isCorrect: Boolean
  score: Int
  nextQuestionId: ID
  attribute: AttributeInput
  assessmentEnded: Boolean = false
  blockOtherAnswers: Boolean = false
  supplements: [AnswerSupplementInput!]
  icon: Upload
  triggerEvent: String
}

type UpdateAppointment {
  success: Boolean!
  message: String!
  appointment: Appointment
}

type UpdateAppointmentCredits {
  success: Boolean!
  message: String!
  credits: AppointmentCredit
}

input UpdateAppointmentInput {
  appointment: ID!
  appointmentType: ID
  datetime: DateTime
  contactType: CalendarContactType
  postEventStatus: PostEventStatus
}

type UpdateArticleRecommended {
  success: Boolean!
  message: String!
  errors: [FormError!]
  articleRecommended: ArticleRecommended
}

input UpdateArticleRecommendedInput {
  id: ID!
  biomarkerId: ID
  range: BiomarkerRangeInput = null
  normalValues: [GenericScalar!]
  articleId: ID
}

type UpdateAssessment {
  success: Boolean!
  message: String!
  errors: [FormError!]
  assessment: Assessment
}

input UpdateAssessmentInput {
  id: ID!
  title: String
  description: String
  assessmentType: AssessmentType = null
  icon: Upload
  order: Int
  interval: Int
  weight: Int
  isDraft: Boolean
  isPublic: Boolean
  progressBar: Boolean
  hasScore: Boolean
  bottomProgressBar: Boolean
  progressMaxCount: Int
  closeButton: Boolean
  style: GenericScalar
  disableLoader: Boolean
  relativeButtonPosition: Boolean
  resultsImageUrl: String
}

type UpdateAssistant {
  success: Boolean!
  message: String!
  errors: [FormError!]
  assistant: Assistant
}

input UpdateAssistantInput {
  id: ID!
  name: String
  mainGoal: String
  programId: ID
  mode: AssistantMode
  voice: String
  onboarding: Boolean
  onboardingPrompt: String
  welcomeMessage: String
  initialSuggestedReplies: [String!]
  chatAvatar: Upload
  chatName: String
}

type UpdateBiomarker {
  success: Boolean!
  message: String!
  errors: [FormError!]
  biomarker: Biomarker
}

type UpdateBiomarkerCategory {
  success: Boolean!
  message: String!
  errors: [FormError!]
  biomarkerCategory: BiomarkerCategory
}

input UpdateBiomarkerCategoryInput {
  id: ID!
  name: String
  parent: ID
  order: Int
}

input UpdateBiomarkerInput {
  id: ID!
  name: String
  category: ID
  method: String
  description: String
  order: Int = 0
  isVisible: Boolean = true
  range: BiomarkerRangeInput
  optimalRange: BiomarkerRangeInput
  borderlineRange: BiomarkerRangeInput
  units: [ID!]
  aliases: [BiomarkerAliasInput!]
  normalValues: [GenericScalar!] = ["{}"]
  displayRange: Boolean = true
}

type UpdateBloodPressureLog {
  success: Boolean!
  message: String!
}

type UpdateCoachTeam {
  success: Boolean!
  message: String!
  errors: [FormError!]
  coachTeam: CoachTeam
}

input UpdateCoachTeamInput {
  id: ID!
  name: String
  description: String
  coaches: [ID!]
}

type UpdateCoachType {
  success: Boolean!
  message: String!
  errors: [FormError!]
  coachType: CoachType
}

input UpdateCoachTypeInput {
  id: ID!
  name: String
  description: String
  coaches: [ID!]
}

type UpdateContentCategory {
  success: Boolean!
  message: String!
  contentCategory: ContentCategoryType
  errors: [FormError!]
}

input UpdateContentCategoryInput {
  id: ID!
  name: String
  order: Int

  """Subcategories IDs."""
  subcategories: [ID]
  image: Upload

  """Content tags IDs."""
  tags: [ID]
  lang: GenericScalar
  subtitle: String
}

type UpdateContentLibrary {
  success: Boolean!
  message: String!
  contentLibrary: ContentLibraryType
  errors: [FormError!]
}

input UpdateContentLibraryInput {
  id: ID!
  title: String
  imageUrl: String
  subTitle: String
  isBlocked: Boolean
  isFeatured: Boolean
  order: Int

  """Categories IDs."""
  categories: [ID]
  sourceUrl: String

  """Content tags IDs."""
  tags: [ID]
  lang: GenericScalar = "{}"

  """Programs IDs."""
  programs: [ID!]
}

type UpdateContentTag {
  success: Boolean!
  message: String!
  contentTag: ContentTagType
  errors: [FormError!]
}

type UpdateDailyRecapAnswer {
  success: Boolean!
  message: String!
  dailyRecapAnswer: DailyRecapAnswer
  errors: [FormError!]
}

input UpdateDailyRecapAnswerInput {
  id: ID!
  answer: String
  type: String
  lang: GenericScalar
}

type UpdateDailyRecapQuestion {
  success: Boolean!
  message: String!
  dailyRecapQuestion: ThirdPartyDailyRecapQuestion
  errors: [FormError!]
}

input UpdateDailyRecapQuestionInput {
  id: ID!
  question: String
  imageUrl: String
  program: ID

  """Answer IDs."""
  answers: [ID]
  lang: GenericScalar
}

type UpdateDietPreference {
  success: Boolean!
  message: String!
  errors: [FormError!]
  dietPreference: DietPreference
}

input UpdateDietPreferenceInput {
  id: ID!
  name: String
  restrictions: [ID!]
  operationOverRestrictions: Operation = null
}

type UpdateDynamicQuestion {
  success: Boolean!
  message: String!
  errors: [FormError!]
  dynamicQuestion: AssessmentDynamicQuestion
}

input UpdateDynamicQuestionInput {
  id: ID!
  questionId: ID
  dependsOnAnswers: [ID!]
  order: Int
  parentQuestionId: ID
}

type UpdateEmailCustomFields {
  success: Boolean!
  message: String!
  emailCustomFields: EmailCustomFields
}

input UpdateEmailCustomFieldsInput {
  inviteCoachSubject: String
  inviteCoachSignature: String
  inviteCoachHtml: String
  inviteCoachText: String
  inviteMemberSubject: String
  inviteMemberHtml: String
  inviteMemberText: String
  coachingBaseUrl: String
  appointmentConfirmationSubject: String
  appointmentConfirmationHtml: String
  appointmentConfirmationText: String
  appointmentUpdatedSubject: String
  appointmentUpdatedHtml: String
  appointmentUpdatedText: String
  appointmentCanceledSubject: String
  appointmentCanceledHtml: String
  appointmentCanceledText: String
  magicLinkSubject: String
  magicLinkHtml: String
  magicLinkText: String
  resetPasswordSubject: String
  resetPasswordText: String
  resetPasswordHtml: String
  autoReplyFeedbackSubject: String
  autoReplyFeedbackText: String
  autoReplyFeedbackHtml: String
}

type UpdateExpressTrack {
  success: Boolean!
  message: String!
}

type UpdateGuardrail {
  success: Boolean!
  message: String!
  errors: [FormError!]
  guardrail: Guardrail
}

input UpdateGuardrailInput {
  id: ID!
  name: String
  description: String
  message: String
  assistant: ID
}

type UpdateHydration {
  success: Boolean
  message: String
}

type UpdateInteraction {
  success: Boolean!
  message: String!
  interaction: InteractionType
}

type UpdateJourney {
  success: Boolean!
  message: String!
  journey: JourneyAssistantType
}

input UpdateJourneyInput {
  id: ID!
  sendWelcomeMessage: Boolean
  welcomeMessage: String
}

type UpdateJourneyStatus {
  success: Boolean
  message: String
}

type UpdateLabTestReport {
  success: Boolean!
  message: String!
  errors: [FormError!]
  report: LabTestReport
}

type UpdateMealLogMutation {
  success: Boolean
}

type UpdateMealPlanSettings {
  success: Boolean!
  message: String!
}

type UpdateMealPlanTemplate {
  success: Boolean!
  message: String!
  mealPlan: MealPlanTemplate
}

input UpdateMPSettingsInput {
  """Daily goal in kcal"""
  calories: Int

  """Percentage, from 0 to 100"""
  carbs: Int

  """Percentage, from 0 to 100"""
  protein: Int

  """Percentage, from 0 to 100"""
  fat: Int

  """Percentage, from 0 to 100"""
  omega3: Float
  format: [MealTime!]
}

type UpdateMyBrandedFood {
  success: Boolean!
  message: String!
}

input UpdateMyBrandedFoodInput {
  brandName: String
  brandOwner: String
  servingSizeUnit: String
  servingSize: Float
  gtinUpc: String
  name: String
  description: String
  nutrients: [NutrientInput]
  householdServingFulltext: String
  brandedFoodCategory: String
}

type UpdateMyChecklistItem {
  success: Boolean!
  message: String!
  myChecklistItem: MyChecklistItem
}

type UpdateMyCommonFood {
  success: Boolean!
  message: String!
}

input UpdateMyCommonFoodInput {
  name: String
  description: String
  nutrients: [NutrientInput]
  portions: [PortionInput]
}

type UpdateMyRecipe {
  success: Boolean!
  message: String!
  recipe: UserRecipe
}

input UpdateMyRecipeInput {
  ingredientLines: [String!]
  name: String
  numberOfServings: Int
  instructions: [String!]
  ingredients: [IngredientAmount!]
  mealTimes: [MealTime!]
  courses: [String!]
  cuisines: [String!]
  language: Language
  mainImage: String
  squareImage: String
  tags: [String]
  text: String
  totalTime: String
  totalTimeInSeconds: Int
}

type UpdateNote {
  success: Boolean!
  message: String!
  note: Note
  errors: [FormError!]
}

type UpdateOwnMealMutation {
  success: Boolean
  message: String
}

type UpdateOwnRecipe {
  success: Boolean!
  message: String!
}

type UpdateProfile {
  success: Boolean
  errors: [ErrorType]
}

type UpdateProfileBiomarkers {
  success: Boolean
}

type UpdateProtocol {
  success: Boolean!
  message: String!
  protocol: Protocol
}

input UpdateProtocolInput {
  id: ID!
  isActive: Boolean
  group: ProtocolGroup
}

type UpdateQuestion {
  success: Boolean!
  message: String!
  errors: [FormError!]
  question: AssessmentQuestion
}

input UpdateQuestionInput {
  id: ID!
  assessmentId: ID
  text: String
  questionType: QuestionType = null
  htmlElement: FormHtmlElement = null
  isInitialQuestion: Boolean
  isFinalQuestion: Boolean
  canSkip: Boolean
  nextQuestionId: ID
  information: String
  helpText: String
  profileField: ProfileField = null
  answers: [CreateQuestionAnswerInput!]
  attributes: [ID!]
  finalText: String
  helpTitle: String
  informationTitle: String
  maxOptionsSelected: Int
  minOptionsSelected: Int
  collapsibleHelpText: Boolean
  finalButton: String
  finalTitle: String
  comment: String
  isExit: Boolean = false
  hasDynamicAnswers: Boolean = false
}

type UpdateRefreshRateKnowledgeBase {
  success: Boolean!
  message: String!
  knowledgeBase: KnowledgeBaseType
}

input UpdateRefreshRateKnowledgeBaseInput {
  knowledgeBase: ID!
  refreshRate: KnowledgeBaseRefreshRate!
}

type UpdateShoppingListRecipeServings {
  success: Boolean
}

input UpdateSPInput {
  id: ID!
  name: String
  startDate: Date
  overview: String
  nutrition: String
  exercise: String
  resources: String
  visibility: Boolean
  isActive: Boolean
  coach: ID
  setProtocols: [SPProtocolInput!]
  setSupplements: [SingleSupplementActivableProtocolInput!]
  updateProtocols: [SPUpdateProtocolInput!]
}

type UpdateStartWeight {
  success: Boolean
  message: String
}

type UpdateSubscription {
  success: Boolean
  message: String
}

type UpdateSupplement {
  success: Boolean!
  message: String!
  supplement: Supplement
}

input UpdateSupplementInput {
  description: String
  images: [String!]
  directionsOfUseText: String
  sizeCount: Int
  externalId: String
  sku: String
  storeId: String
  shopifyVariantId: String
  shopifyParentId: String
  instructions: String
  ingredients: String
  supplementFacts: String
  id: ID!
  name: String
  category: String
  mainImage: String
  brand: String
  servingName: String
  directionsOfUse: [DirectionsOfUseInput!]
  type: SupplementType
  conditions: [ID!]
  createConditions: [CreateSupplementConditionInput!]
}

type UpdateSupplementPlan {
  success: Boolean!
  message: String!
  supplementPlan: SupplementPlan
}

type UpdateSupplementRecommended {
  success: Boolean!
  message: String!
  errors: [FormError!]
  supplementRecommended: SupplementRecommended
}

input UpdateSupplementRecommendedInput {
  id: ID!
  biomarkerId: ID
  range: BiomarkerRangeInput = null
  normalValues: [GenericScalar!]
  supplementId: ID
}

type UpdateSymptomLog {
  success: Boolean!
  message: String!
}

type UpdateThirdPartyGoal {
  success: Boolean!
  message: String!
  goal: ThirdPartyGoal
}

input UpdateThirdPartyGoalInput {
  id: ID!
  value: Float!
}

type UpdateThirdPartyTrackerComponent {
  success: Boolean!
  message: String!
  enabledComponents: [TrackerComponent!]
}

input UpdateThirdPartyTrackerComponentInput {
  components: [TrackerComponent!]!
  operation: Operation!
}

type UpdateUserAssessmentScore {
  success: Boolean!
  message: String!
  errors: [FormError!]
  userProgress: UserProgress
}

input UpdateUserAssessmentScoreInput {
  assessmentId: ID!
  profileId: ID!
  score: Int
}

type UpdateUserProgram {
  success: Boolean
  message: String
}

type UpdateUserProgress {
  success: Boolean!
  message: String!
  errors: [FormError!]
  userProgress: UserProgress
}

input UpdateUserProgressInput {
  id: ID!
  score: Int
}

type UpdateUserTracker {
  success: Boolean!
  message: String!
  tracker: UserTracker
  errors: [FormError!]
}

input UpdateUserTrackerInput {
  id: ID!
  goal: Float
  source: SourceType = null
}

type UpdateWebhookEndpoint {
  success: Boolean!
  message: String!
  endpoint: WebhookEndpoint
}

input UpdateWebhookEndpointInput {
  id: String!
  url: String
  eventTypes: [WebhookEventType!]
}

"""
Create scalar that ignores normal serialization/deserialization, since
that will be handled by the multipart request spec
https://github.com/lmcgartland/graphene-file-upload/blob/master/graphene_file_upload/scalars.py
"""
scalar Upload

type UploadAppointmentAttachment {
  success: Boolean!
  message: String!
  attachment: AppointmentAttachment
}

input UploadAppointmentAttachmentInput {
  appointment: ID!
  attachment: Upload!
  name: String!
}

type UsdaFood implements Node {
  """The ID of the object"""
  id: ID!
  foodDataId: String
  description: String
  dataType: String
  commonNames: [String]
  portions: [Portion]
  nutrients: [Nutrients]
}

type User implements Node {
  email: String
  name: String
  phone: String
  isActive: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  organizationId: UUID
  userSource: String
  appleUserSource: String
  appleUserSourceJson: JSONString
  isArUser: Boolean!
  avatar: String
  isTest: Boolean!

  """The ID of the object"""
  id: ID!
  databaseId: String
  profileId: String
  subscription: SubscriptionType
}

type UserAnswer implements Node {
  profile: ProfileType!
  question: AssessmentQuestion!
  answer: AssessmentAnswer
  answerText: String
  rankingOrder: Int
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
}

type UserAnswerConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserAnswerEdge]!
}

"""A Relay edge containing a `UserAnswer` and its cursor."""
type UserAnswerEdge {
  """The item at the end of the edge"""
  node: UserAnswer

  """A cursor for use in pagination"""
  cursor: String!
}

type UserAnswerHistory implements Node {
  question: AssessmentQuestion!
  answer: AssessmentAnswer
  answerText: String
  rankingOrder: Int
  attempts: Int!
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
}

type UserAnswerHistoryConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserAnswerHistoryEdge]!
}

"""A Relay edge containing a `UserAnswerHistory` and its cursor."""
type UserAnswerHistoryEdge {
  """The item at the end of the edge"""
  node: UserAnswerHistory

  """A cursor for use in pagination"""
  cursor: String!
}

input UserAnswerInput {
  questionId: ID!
  answerId: ID
  answerText: String
  rankingOrder: Int
}

enum UserAnswerOrderByField {
  id
  profile
  answer
  question
  answer_text
  created_at
  updated_at
}

input UserAnswerOrderByInput {
  field: UserAnswerOrderByField = profile
  order: SortOrder = ASC
}

input UserAnswersByAssessmentInput {
  questionIds: [ID!]
}

input UserAssessmentsFilterInput {
  title: String
  description: String
  status: AssessmentStatus
}

type UserConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserEdge]!
}

type UserConsentType implements Node {
  profile: ProfileType!
  consentType: ConsentType!
  consentedAt: DateTime!

  """The ID of the object"""
  id: ID!
}

"""A Relay edge containing a `User` and its cursor."""
type UserEdge {
  """The item at the end of the edge"""
  node: User

  """A cursor for use in pagination"""
  cursor: String!
}

type UserFavoriteMenuItem {
  success: Boolean
  isUserFavorite: Boolean
}

type UserFavoriteRecipe {
  success: Boolean
  message: String!
  isUserFavorite: Boolean
}

type UserFavoriteRestaurant {
  success: Boolean
  isUserFavorite: Boolean
}

type UserProgress implements Node {
  profile: ProfileType!
  assessment: Assessment!
  currentQuestion: AssessmentQuestion!
  startDate: DateTime!
  endDate: DateTime!
  score: Float
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
}

type UserProgressConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserProgressEdge]!
}

"""A Relay edge containing a `UserProgress` and its cursor."""
type UserProgressEdge {
  """The item at the end of the edge"""
  node: UserProgress

  """A cursor for use in pagination"""
  cursor: String!
}

type UserPurchases {
  activeSubscriptionTransaction: SubscriptionTransaction
}

type UserRecipe implements Node {
  id: ID!
  ingredientLines: [String!]!
  name: String!
  numberOfServings: Int!
  servingWeight: Float!
  weightInGrams: Float!
  ingredients: [IngredientFoodFormat!]!
  mealTimes: [RecipeMealTime!]
  courses: [String!]
  cuisines: [String!]
  instructions: String
  language: Language!
  mainImage: String
  squareImage: String
  tags: [String]
  text: String
  totalTime: String
  totalTimeInSeconds: Int
  nutrients: [Nutrient!]
  nutrientsPerServing: [Nutrient!]
}

type UserRecipeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserRecipeEdge]!
  count: Int
}

"""A Relay edge containing a `UserRecipe` and its cursor."""
type UserRecipeEdge {
  """The item at the end of the edge"""
  node: UserRecipe

  """A cursor for use in pagination"""
  cursor: String!
}

type UserRecipeProxy {
  userRecipe: UserRecipe!
}

input UsersFiltersInput {
  createdAt: CreatedAtRangeInput
}

input UsersProgressFilterInput {
  assessmentId: ID
  profileId: ID
  currentQuestionId: ID
  scoreRange: RangeOperator
}

type UserTracker implements Node {
  """The ID of the object"""
  id: ID!
  goal: Float
  createdAt: DateTime!
  updatedAt: DateTime!
  tracker: TrackerComponent!
  source: SourceType
}

"""
Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

enum VideoZoomRole {
  PARTICIPANT
  HOST
}

type WebhookEndpoint implements Node {
  url: String!

  """The ID of the object"""
  id: ID!
  eventTypes: [WebhookEventType]
}

type WebhookEndpointConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [WebhookEndpointEdge]!
}

"""A Relay edge containing a `WebhookEndpoint` and its cursor."""
type WebhookEndpointEdge {
  """The item at the end of the edge"""
  node: WebhookEndpoint

  """A cursor for use in pagination"""
  cursor: String!
}

enum WebhookEventType {
  PROFILE_CREATED
  PROFILE_UPDATED
  PROFILE_DELETED
  APPOINTMENT_CREATED
  APPOINTMENT_UPDATED
  APPOINTMENT_CANCELLED
  EXERCISE_TRACKER_CREATED
  EXERCISE_TRACKER_UPDATED
  EXERCISE_TRACKER_DELETED
  STEPS_TRACKER_CREATED
  STEPS_TRACKER_UPDATED
  STEPS_TRACKER_DELETED
  SLEEP_TIME_TRACKER_CREATED
  SLEEP_TIME_TRACKER_UPDATED
  SLEEP_TIME_TRACKER_DELETED
  WEIGHT_TRACKER_CREATED
  WEIGHT_TRACKER_UPDATED
  WEIGHT_TRACKER_DELETED
  HYDRATION_TRACKER_UPDATED
  HYDRATION_TRACKER_CREATED
  TRACKER_GOAL_CREATED
  TRACKER_GOAL_UPDATED
  USER_SUBSCRIPTION_UPDATED
  MY_RECIPE_CREATED
  MY_RECIPE_UPDATED
  MY_RECIPE_DELETED
  MY_BRANDED_FOOD_CREATED
  MY_BRANDED_FOOD_UPDATED
  MY_BRANDED_FOOD_DELETED
  MY_COMMON_FOOD_CREATED
  MY_COMMON_FOOD_UPDATED
  MY_COMMON_FOOD_DELETED
  EXPRESS_TRACK_CREATED
  EXPRESS_TRACK_UPDATED
  EXPRESS_TRACK_DELETED
  FOOD_LOG_CREATED
  FOOD_LOG_UPDATED
  FOOD_LOG_DELETED
}

enum WeeklyWeightGoal {
  """Mantain"""
  MAINTAIN

  """Lose 0.5 lb per week"""
  GOAL_1

  """Lose 1 lb per week"""
  GOAL_2

  """Lose 1.5 lb per week"""
  GOAL_3

  """Lose 2 lb per week"""
  GOAL_4
}

input WeightEntryInput {
  date: Date!
  value: PositiveFloat!
  source: SourceType
}

type WeightTracker {
  start: Float
  today: Float
  tendency: Tendency
  entries: [Entry]
  latestEntry: DateTime
}

"""An enumeration."""
enum WellnessgptEscalationRedirectToChoices {
  """None"""
  NONE

  """Support"""
  SUPPORT

  """Concierge"""
  CONCIERGE
}

"""An enumeration."""
enum WellnessgptKnowledgeBaseTaskStatusChoices {
  """CREATED"""
  CREATED

  """PROCESSING"""
  PROCESSING

  """DONE"""
  DONE

  """ERROR"""
  ERROR
}

"""An enumeration."""
enum WellnessgptSitemapURLTaskStatusChoices {
  """CREATED"""
  CREATED

  """PROCESSING"""
  PROCESSING

  """DONE"""
  DONE

  """ERROR"""
  ERROR
}

type WellnessProfileResponse {
  success: Boolean!
  message: String!
  profile: WellnessProfileType
}

type WellnessProfileType {
  id: ID
  age: Int
  biologicalSex: String
  height: Float
  weight: Float
  activityLevel: String
  programName: String
  dailyCaloricIntakeGoal: Int
  birthdate: Date
  targetWeight: Float
  startingWeight: Float
  restrictions: [Restriction]
  hasOnboarded: Boolean!
  phone: String
}

type WellnessScoreLastSevenDays {
  dailyStreakScore: [DailyStreakScore!]
  wellnessScore: Float!
}

type WorkflowExecutionLogComment implements Node {
  """The ID of the object"""
  id: ID!
  comment: String
  executionId: UUID!
  rating: WorkflowExecutionLogRating!
  createdAt: DateTime!
}

enum WorkflowExecutionLogRating {
  THUMBS_UP
  THUMBS_DOWN
}

type ZoomParticipantAudioFile {
  id: String!
  recordingStart: String!
  recordingEnd: String!
  fileName: String!
  fileType: String!
  fileExtension: String!
  fileSize: Int!
  downloadUrl: String!
  status: String!
}

type ZoomParticipantVideoFile {
  id: String!
  recordingStart: String!
  recordingEnd: String!
  fileName: String!
  fileType: String!
  fileExtension: String!
  fileSize: Int!
  downloadUrl: String!
  status: String!
  recordingType: String!
}

type ZoomRecodingFile {
  id: String!
  status: String!
  recordingStart: String!
  recordingEnd: String!
  fileType: String!
  fileSize: Float!
  downloadUrl: String!
  recordingType: String!
  deletedTime: String
  fileExtension: String!
}

type ZoomRecording {
  timezone: String
  duration: Int!
  sessionName: String!
  sessionId: String!
  startTime: String!
  totalSize: Int!
  recordingCount: Int!
  recordingFiles: [ZoomRecodingFile!]
  participantAudioFiles: [ZoomParticipantAudioFile!]
  participantVideoFiles: [ZoomParticipantVideoFile!]
  downloadAccessToken: String
}

type ZoomRecordingConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ZoomRecordingEdge]!
}

"""A Relay edge containing a `ZoomRecording` and its cursor."""
type ZoomRecordingEdge {
  """The item at the end of the edge"""
  node: ZoomRecording

  """A cursor for use in pagination"""
  cursor: String!
}

