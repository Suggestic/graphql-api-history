"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type AcknowledgeConversationMessage {
  message: String!
  success: Boolean!
}

input AcknowledgeConversationMessageInput {
  coachId: ID!
  conversationSid: String!
  messageSid: String!
}

enum ActionType {
  DECREASE
  INCREASE
}

enum ActivityLevel {
  EXERCISE_1
  EXERCISE_1_2
  EXERCISE_2
  EXERCISE_3_MORE
  NOT_ACTIVE
}

type ActivityLog implements Node {
  appUser: ProfileType
  createdAt: DateTime!
  eventName: String!
  id: ID!
  payload: GenericScalar
  userEmail: String
  userName: String
}

type ActivityLogConnection {
  edges: [ActivityLogEdge]!
  pageInfo: PageInfo!
}

type ActivityLogEdge {
  cursor: String!
  node: ActivityLog
}

type AddBiomarker {
  biomarker: Biomarker
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input AddBiomarkerInput {
  aliases: [BiomarkerAliasInput!]
  borderlineRange: BiomarkerRangeInput
  category: ID!
  description: String
  isVisible: Boolean = true
  method: String
  name: String!
  normalValues: [GenericScalar!] = ["{}"]
  optimalRange: BiomarkerRangeInput
  order: Int = 0
  range: BiomarkerRangeInput
  units: [ID!]!
}

type AddBiomarkerResults {
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input AddBiomarkerResultsInput {
  biomarkers: [BiomarkerResultInput!]!
  labTestReportId: ID!
}

type AddBloodPressureLog {
  message: String!
  success: Boolean!
}

type AddCoachChatConversation {
  message: String!
  success: Boolean!
}

input AddCoachChatConversationInput {
  coachId: ID!
  conversationSid: String!
}

type AddExerciseEntry {
  message: String!
  success: Boolean!
}

type AddFavoriteArticle {
  message: String!
  success: Boolean!
}

type AddFoodLog {
  foodLog: FoodLog
  message: String!
  success: Boolean!
}

type AddHeartRateLog {
  message: String!
  success: Boolean!
}

type AddHRVLog {
  message: String!
  success: Boolean!
}

type AddRecipesToShoppingList {
  message: String
  success: Boolean
}

type AddSleepQualityScore {
  message: String!
  success: Boolean!
}

type AddSleepTime {
  message: String!
  success: Boolean!
}

type AddStepsCount {
  message: String!
  success: Boolean!
}

type AddToShoppingList {
  message: String
  success: Boolean
}

type AddUserConsent {
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input AddUserConsentInput {
  consentTypeId: ID!
}

type AddUserToJourney {
  message: String!
  success: Boolean!
}

input AddUserToJourneyInput {
  journey: ID!
  portalUser: ID
  profile: ID!
}

type Adherence {
  color: AdherenceColor
  icon: Icon
  isRecommended: Boolean
  reason: String
  score: Float
  title: String
}

enum AdherenceColor {
  BLUE
  GREEN
  GREY
  RED
  YELLOW
}

type Aggregate implements Node {
  aggregateMeta: AggregateMeta
  aisleName: String
  comment: String
  createdAt: DateTime!
  databaseId: String
  grams: Float
  id: ID!
  ingredient: String
  isCleared: Boolean!
  isDone: Boolean!
  listitemSet(after: String, before: String, first: Int, last: Int, offset: Int, recipe: ID): ListItemConnection!
  meta: JSONString!
  profile: ProfileType!
  quantity: Int
  servingEquivalent: Float
  unit: String
  updatedAt: DateTime!
}

type AggregateConnection {
  edges: [AggregateEdge]!
  pageInfo: PageInfo!
}

type AggregateEdge {
  cursor: String!
  node: Aggregate
}

type AggregateMeta {
  aisle: String
  grams: Float @deprecated(reason: "Not used, will be removed")
  ids: [String]
  idsContribution: [Contribution]
  name: String
  qty: Int
  rawQty: Float
}

enum AlertAction {
  ATTEMPTED_FAILED
  CONTACTED
}

enum AlertStatus {
  COMPLETED
  FOLLOW_UP
  IN_REVIEW
  NO_FOLLOW_UP
  OTHER
  OUT_OF_RANGE
  REVIEWED
}

type Answer {
  answer: String
  id: ID
  imageUrl: String
  selected: Boolean
  type: HabitAnswerType!
}

type AnswerCounter {
  answer: Answer!
  total: Int!
}

input AnswersFilterInput {
  questionId: ID
  text: String
}

input AnswerSupplementInput {
  score: Float!
  supplementId: ID!
}

type Appointment {
  appointmentType: AppointmentType!
  attendees: [Attendee!]!
  coach: Coach
  contactType: CalendarContactType!
  description: String
  end: DateTime!
  id: ID!
  labTestReports(after: String, before: String, first: Int, last: Int): LabTestReportConnection
  meetingUrl: String
  postEventStatus: PostEventStatus
  sendbirdRoomId: String @deprecated(reason: "Soon it will be removed")
  start: DateTime!
  status: EventStatus!
  title: String!
  zoomSessionName: String
  zoomSessionPassword: String
}

type AppointmentConnection {
  edges: [AppointmentEdge]!
  pageInfo: PageInfo!
}

type AppointmentCredit {
  appointmentType: AppointmentType!
  id: ID!
  labTestReports(after: String, before: String, first: Int, last: Int): LabTestReportConnection
  value: Int!
}

type AppointmentCredits {
  credits: [AppointmentCredit!]!
}

type AppointmentEdge {
  cursor: String!
  node: Appointment
}

enum AppointmentMultiCoachType {
  ANY_COACH_AVAILABLE
  COLLECTIVE
  INDIVIDUAL
}

type AppointmentType implements Node {
  contactType: [String!]!
  durationMin: Int!
  id: ID!
  multiCoachType: AppointmentMultiCoachType!
  numberOfMember: Int!
  refundableBeforeHours: Int!
  title: String!
}

type AppointmentTypeConnection {
  edges: [AppointmentTypeEdge]!
  pageInfo: PageInfo!
}

type AppointmentTypeEdge {
  cursor: String!
  node: AppointmentType
}

type AppRestriction {
  feature: String!
  limitations: [Limitation!]!
}

input AppUserActivityLogFiltersInput {
  eventName: String
  profileId: ID
}

type ArticleRecommended implements Node {
  article: ContentLibraryType!
  biomarker: Biomarker!
  createdAt: DateTime!
  id: ID!
  normalValues: [GenericScalar!]
  updatedAt: DateTime!
  valueMax: Float
  valueMin: Float
}

type ArticleRecommendedConnection {
  edges: [ArticleRecommendedEdge]!
  pageInfo: PageInfo!
}

type ArticleRecommendedEdge {
  cursor: String!
  node: ArticleRecommended
}

type Assessment implements Node {
  assessmentType: AssessmentType!
  bottomProgressBar: Boolean!
  closeButton: Boolean!
  createdAt: DateTime!
  description: String
  disableLoader: Boolean!
  finalQuestion: AssessmentQuestion
  hasScore: Boolean!
  icon: String
  id: ID!
  initialQuestion: AssessmentQuestion
  interval: Int
  isDraft: Boolean!
  isPublic: Boolean!
  lastAnsweredQuestion: AssessmentQuestion
  order: Int!
  progressBar: Boolean!
  progressMaxCount: Int!
  questions(after: String, before: String, first: Int, last: Int, offset: Int): AssessmentQuestionConnection
  relativeButtonPosition: Boolean!
  resultsImageUrl: String
  score: Float
  status: AssessmentStatus
  style: GenericScalar
  title: String!
  updatedAt: DateTime!
  url: String
  weight: Int
}

type AssessmentAnswer implements Node {
  assessmentEnded: Boolean!
  attribute: GenericScalar
  blockOtherAnswers: Boolean!
  createdAt: DateTime!
  id: ID!
  isCorrect: Boolean!
  isSelected: Boolean
  nextQuestion: AssessmentQuestion
  question: AssessmentQuestion
  rankingOrder: Int
  score: Float
  supplements: [AssessmentAnswerSupplement]
  text: String!
  updatedAt: DateTime!
  value: String
}

type AssessmentAnswerConnection {
  edges: [AssessmentAnswerEdge]!
  pageInfo: PageInfo!
}

type AssessmentAnswerEdge {
  cursor: String!
  node: AssessmentAnswer
}

type AssessmentAnswerSupplement implements Node {
  createdAt: DateTime!
  id: ID!
  score: Float!
  supplement: Supplement!
  updatedAt: DateTime!
}

type AssessmentAnswerSupplementConnection {
  edges: [AssessmentAnswerSupplementEdge]!
  pageInfo: PageInfo!
}

type AssessmentAnswerSupplementEdge {
  cursor: String!
  node: AssessmentAnswerSupplement
}

type AssessmentConnection {
  edges: [AssessmentEdge]!
  pageInfo: PageInfo!
}

type AssessmentDynamicQuestion implements Node {
  dependsOnAnswers: [AssessmentAnswer!]
  id: ID!
  order: Int!
  parentQuestion: AssessmentQuestion
}

type AssessmentEdge {
  cursor: String!
  node: Assessment
}

type AssessmentQuestion implements Node {
  answerText: String
  answers: [AssessmentAnswer!]
  assessment: Assessment
  attributes: [AssessmentQuestionAttribute!]
  canSkip: Boolean!
  collapsibleHelpText: Boolean!
  comment: String
  createdAt: DateTime!
  dynamicQuestion: AssessmentDynamicQuestion
  finalButton: String
  finalText: String
  finalTitle: String
  hasDynamicAnswers: Boolean!
  helpText: String
  helpTitle: String
  htmlElement: FormHtmlElement
  id: ID!
  information: String
  informationTitle: String
  isExit: Boolean!
  isFinalQuestion: Boolean!
  isInitialQuestion: Boolean!
  maxOptionsSelected: Int
  minOptionsSelected: Int
  nextQuestion: AssessmentQuestion
  profileField: QuestionProfileField
  questionType: QuestionType!
  text: String!
  updatedAt: DateTime!
}

type AssessmentQuestionAttribute implements Node {
  createdAt: DateTime!
  id: ID!
  name: String!
  updatedAt: DateTime!
  value: String!
}

type AssessmentQuestionAttributeConnection {
  edges: [AssessmentQuestionAttributeEdge]!
  pageInfo: PageInfo!
}

type AssessmentQuestionAttributeEdge {
  cursor: String!
  node: AssessmentQuestionAttribute
}

type AssessmentQuestionConnection {
  edges: [AssessmentQuestionEdge]!
  pageInfo: PageInfo!
}

type AssessmentQuestionEdge {
  cursor: String!
  node: AssessmentQuestion
}

input AssessmentsFilterInput {
  description: String
  isDraft: Boolean
  isPublic: Boolean
  title: String
}

enum AssessmentStatus {
  DONE
  IN_PROGRESS
  NEEDS_UPDATE
  TODO
}

enum AssessmentType {
  COMMON
  DIET_ID
  ON_BOARDING
}

type Assistant {
  id: ID!
  journey: JourneyAssistantType
  mainGoal: String!
  mode: AssistantMode!
  name: String!
  onboarding: Boolean!
  onboardingPrompt: String
  program: ID
  voice: String
}

input AssistantAnalyticFiltersInput {
  endDate: Date
  startDate: Date
}

type AssistantAnalytics {
  currentNumberUserSubscribed: Int!
  totalMessagesSent: Int!
}

input AssistantConversationInput {
  hasConstraints: Boolean!
  hasEscalations: Boolean!
  hasKnowledgeBase: Boolean!
  interactionId: ID
  userProfile: ProfileTest!
  usingInteractionGoal: Boolean!
}

type AssistantConversationResponse {
  chat: [ChatResponse]
  escalations: [EscalationConversationResponse]
  id: ID!
}

input AssistantFiltersInput {
  ids: [String]!
}

type AssistantIngredient {
  grams: Float
  name: String
  quantity: Float
  unit: String
}

enum AssistantMode {
  AUTO
  MANUAL
}

type Attendee {
  displayName: String
  email: String!
  status: EventParticipationStatus!
}

enum AttrDataType {
  BOOLEAN
  FLOAT
  INT
  STRING
}

input AttributeInput {
  dataType: AttrDataType!
  name: String!
  value: GenericScalar
}

type AutoGenerateConversationMessage {
  generatedMessage: String
  message: String!
  success: Boolean!
}

input AutoGenerateConversationMessageInput {
  assistantId: ID
  coachId: ID!
  conversationSid: String!
}

union AvailableChecklistItems = ChecklistItem | MyChecklistItemOnPlan | SupplementOnPlan

enum BiologicalSex {
  FEMALE
  MALE
  PREFER_NOT_TO_DISCLOSE
  UNCERTAIN
  UNKNOWN
}

type Biomarker {
  aliases: [BiomarkerAlias!]
  borderlineRange: BiomarkerRange
  category: BiomarkerCategory!
  createdAt: DateTime!
  description: String
  id: ID!
  method: String
  name: String!
  normalStringValues: JSONString
  normalValues: [GenericScalar!]
  optimalRange: BiomarkerRange
  order: Int
  range: BiomarkerRange
  units: [BiomarkerUnit!]!
  updatedAt: DateTime!
}

type BiomarkerAlias {
  language: String!
  name: String!
}

input BiomarkerAliasInput {
  language: BiomarkerLanguage!
  name: String!
}

type BiomarkerCategory implements Node {
  createdAt: DateTime!
  id: ID!
  name: String!
  order: Int
  parent: BiomarkerCategory
  updatedAt: DateTime!
}

type BiomarkerCategoryConnection {
  edges: [BiomarkerCategoryEdge]!
  pageInfo: PageInfo!
}

type BiomarkerCategoryEdge {
  cursor: String!
  node: BiomarkerCategory
}

input BiomarkerCategoryFilterInput {
  isOwned: Boolean
}

input BiomarkerCategoryOrderBy {
  field: BiomarkerCategoryOrderByField!
  order: SortOrder = ASC
}

enum BiomarkerCategoryOrderByField {
  created_at
  name
  order
  updated_at
}

type BiomarkerConnection {
  edges: [BiomarkerEdge]!
  pageInfo: PageInfo!
}

type BiomarkerEdge {
  cursor: String!
  node: Biomarker
}

input BiomarkerFilterInput {
  categoryId: ID
  name: String
}

enum BiomarkerIntervalRange {
  ALL
  IN_OPTIMAL_RANGE
  IN_RANGE
  OUT_RANGE
}

enum BiomarkerLanguage {
  AFRIKAANS
  ALBANIAN
  ARABIC
  CATALAN
  CHINESE
  CROATIAN
  CZECH
  DANISH
  DUTCH
  ENGLISH
  ESTONIAN
  FRENCH
  GERMAN
  HEBREW
  HINDI
  INDONESIAN
  ITALIAN
  JAPANESE
  KOREAN
  POLISH
  PORTUGUESE
  ROMANIAN
  RUSSIAN
  SERBIAN
  SPANISH
  SWEDISH
  THAI
  TURKISH
  UKRAINIAN
  VIETNAMESE
  ZULU
}

type BiomarkerRange {
  max: Float!
  min: Float!
}

input BiomarkerRangeInput {
  max: Float!
  min: Float!
}

input BiomarkerResultInput {
  alert: Boolean
  alertText: String
  biomarkerId: ID!
  biomarkerUnitId: ID!
  date: DateTime!
  displayValue: String
  result: BiomarkerValueInput!
}

input BiomarkerResultsFilterInput {
  biomarkerId: ID
  biomarkerName: String
  categoryId: ID
  intervalRange: BiomarkerIntervalRange
}

type BiomarkerUnit implements Node {
  alias: String
  createdAt: DateTime!
  factor: Float!
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type BiomarkerUnitConnection {
  edges: [BiomarkerUnitEdge]!
  pageInfo: PageInfo!
}

type BiomarkerUnitEdge {
  cursor: String!
  node: BiomarkerUnit
}

enum BiomarkerValueDatatype {
  BOOLEAN
  NUMBER
  STRING
}

input BiomarkerValueInput {
  type: BiomarkerValueDatatype!
  value: GenericScalar!
}

type BloodPressureLog {
  createdAt: DateTime!
  datetime: DateTime!
  diastolicValue: Int!
  id: ID!
  source: SourceType!
  systolicValue: Int!
}

type BloodPressureLogs {
  cursor: String!
  node: BloodPressureLog
}

type BloodPressureLogsConnnection {
  edges: [BloodPressureLogs]!
  pageInfo: PageInfo!
}

type BrandedFoodConnection {
  count: Int
  edges: [BrandedFoodEdge]!
  pageInfo: PageInfo!
}

type BrandedFoodEdge {
  cursor: String!
  node: BrandedFoodNode
}

type BrandedFoodNode implements Node {
  brandName: String
  brandOwner: String
  brandedFoodCategory: String
  calories: Float
  dataType: String
  description: String
  foodDataId: String
  gtinUpc: String
  householdServingFulltext: String
  id: ID!
  isActive: Boolean!
  isCore: Boolean!
  isGeneric: Boolean!
  name: String!
  nutrients: [Nutrient!]!
  servingSize: Float!
  servingSizeUnit: String!
  tags: [String!]!
}

type BrandedFoodNodeProxy {
  brandedFood: BrandedFoodNode!
}

type BulkCreateEntries {
  message: String!
  success: Boolean!
}

enum CalendarContactType {
  GOOGLE_MEET
  PHONE_CALL
  VIDEO_CALL
  ZOOM
}

type CaloriesPerServing {
  ala: Float
  carbs: Float
  dha: Float
  dpa: Float
  epa: Float
  fat: Float
  monounsaturatedFat: Float
  omega3: Float
  polyunsaturatedFat: Float
  protein: Float
  saturatedFat: Float
  transFat: Float
}

type CancelAppointment {
  appointment: Appointment
  message: String!
  success: Boolean!
}

type ChangeMealPlannerDayMeal {
  recipe: Recipe
  success: Boolean
}

type ChatResponse {
  content: String!
  createdAt: DateTime!
  id: ID!
  sender: String!
}

type CheckIntake {
  message: String!
  success: Boolean!
}

type CheckItemDirections {
  createdAt: DateTime!
  friday: Boolean!
  id: ID!
  mealTime: TimeOfDay!
  monday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
  thursday: Boolean!
  tuesday: Boolean!
  updatedAt: DateTime!
  wednesday: Boolean!
}

type Checklist {
  icon: String
  items: [ChecklistItem!]!
  name: String!
}

type ChecklistItem {
  category: String
  checked: Boolean!
  id: ID!
  image: String!
  subtitle: String
  title: String!
}

type CheckoutCreate {
  message: String!
  success: Boolean!
  webUrl: String
}

input CheckoutCreateInput {
  supplementsInCart: [SupplementCartItem!]!
}

type CheckTodayFoodEntry {
  message: String!
  success: Boolean!
}

type CheckTodaySupplementEntry {
  message: String!
  success: Boolean!
}

type ClearShoppingList {
  success: Boolean
}

type ClearShoppingListCheckedItems {
  success: Boolean
}

type Coach implements Node {
  appointments(end: DateTime, start: DateTime, timezone: String): [Appointment!]!
  avatarUrl: String
  coachTeams(after: String, before: String, first: Int, last: Int, offset: Int): CoachTeamConnection
  coachTypes(after: String, before: String, first: Int, last: Int, offset: Int): CoachTypeConnection
  email: String!
  id: ID!
  irad: String
  irmp: String
  isPrimary: Boolean
  name: String!
  sendbirdId: String
  showAllMembers: Boolean!
}

type CoachConnection {
  count: Int
  edges: [CoachEdge]!
  pageInfo: PageInfo!
}

type CoachEdge {
  cursor: String!
  node: Coach
}

type CoachTeam implements Node {
  coaches: [Coach!]
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type CoachTeamConnection {
  edges: [CoachTeamEdge]!
  pageInfo: PageInfo!
}

type CoachTeamEdge {
  cursor: String!
  node: CoachTeam
}

input CoachTeamsFilterInput {
  name: String
}

type CoachType implements Node {
  coaches: [Coach!]
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type CoachTypeConnection {
  edges: [CoachTypeEdge]!
  pageInfo: PageInfo!
}

type CoachTypeEdge {
  cursor: String!
  node: CoachType
}

input CoachTypesFilterInput {
  mealPlanTemplateId: ID
  name: String
}

type CommonFoodAPIConnection {
  count: Int
  edges: [CommonFoodAPIEdge]!
  pageInfo: PageInfo!
}

type CommonFoodAPIEdge {
  cursor: String!
  node: CommonFoodNode
}

type CommonFoodNode implements Node {
  dataType: String
  description: String
  foodDataId: String
  id: ID!
  isActive: Boolean!
  isCore: Boolean!
  isGeneric: Boolean!
  name: String!
  nutrients: [Nutrient!]!
  portions: [Portion]
  tags: [String!]!
}

type CommonFoodNodeProxy {
  commonFood: CommonFoodNode!
}

enum CommunicationChannel {
  CHAT
  SMS
  WHATSAPP
}

type ComponentGoal {
  component: EntryType!
  goal: Int!
}

type ConfirmFoodLogAssistant {
  message: String!
  success: Boolean!
}

input ConfirmFoodLogAssistantInput {
  date: Date
  id: ID!
  mealTime: MealTime!
  recipeName: String
  text: String
}

type ConnectedSource {
  createdAt: DateTime!
  currentActive: Boolean!
  id: ID!
  sourceId: Int!
  sourceName: SourceType!
}

type ConsentType implements Node {
  id: ID!
  name: String!
}

type ConstraintConnection {
  count: Int
  edges: [ConstraintEdge]!
  pageInfo: PageInfo!
}

type ConstraintEdge {
  cursor: String!
  node: ConstraintType
}

input ConstraintFilters {
  assistant: ID
}

type ConstraintType implements Node {
  assistant: Assistant!
  description: String!
  id: ID!
  name: String!
}

type ContentCategoryType implements Node {
  contentLibrary(after: String, before: String, first: Int, last: Int, offset: Int): ContentLibraryTypeConnection!
  contentlibrarySet(after: String, before: String, first: Int, last: Int, offset: Int): ContentLibraryTypeConnection! @deprecated(reason: "Not used. Renamed to contentLibrary")
  databaseId: String
  id: ID!
  image: String
  lang: JSONString
  name: String
  order: Int!
  slug: String!
  subcategories: [ContentCategoryType!]
  subtitle: String
  tags: [ContentTagType!]
}

type ContentCategoryTypeConnection {
  edges: [ContentCategoryTypeEdge]!
  pageInfo: PageInfo!
}

type ContentCategoryTypeEdge {
  cursor: String!
  node: ContentCategoryType
}

input ContentLibraryOrderBy {
  field: ContentLibraryOrderByField!
  order: SortOrder
}

enum ContentLibraryOrderByField {
  created_at
  popularity
}

type ContentLibraryType implements Node {
  categories: [ContentCategoryType]
  createdAt: DateTime
  databaseId: String
  id: ID!
  imageUrl: String
  isBlocked: Boolean!
  isFavorite: Boolean!
  isFeatured: Boolean!
  isRead: Boolean
  lang: JSONString!
  order: Int!
  personalizedContent: Boolean
  programs: [Program!]
  sourceUrl: String
  subTitle: String
  tags: [ContentTagType!]
  title: String
  updatedAt: DateTime
}

type ContentLibraryTypeConnection {
  edges: [ContentLibraryTypeEdge]!
  pageInfo: PageInfo!
}

type ContentLibraryTypeEdge {
  cursor: String!
  node: ContentLibraryType
}

type ContentTagType implements Node {
  id: ID!
  name: String!
}

type ContentTagTypeConnection {
  edges: [ContentTagTypeEdge]!
  pageInfo: PageInfo!
}

type ContentTagTypeEdge {
  cursor: String!
  node: ContentTagType
}

type Contribution {
  databaseId: String
  eqv: Float
}

type ConversationSummary {
  text: String
}

type CPC {
  benefits: String
  description: String
  matchCustomAttribute: Boolean
  name: String
  simpleExamples: [String]
}

type CPCIngredient {
  cpcName: String
  priority: String
  softmax: String
  type: String
}

type CPCIngredientGroup {
  avoid: [CPC]
  decrease: [CPC]
  increase: [CPC]
}

type CPCRule {
  avoid: [CPC]
  decrease: [CPC]
  increase: [CPC]
}

type CreateAnswer {
  answer: AssessmentAnswer
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateAnswerInput {
  assessmentEnded: Boolean = false
  attribute: AttributeInput
  blockOtherAnswers: Boolean = false
  isCorrect: Boolean
  nextQuestionId: ID
  questionId: ID!
  score: Int
  supplements: [AnswerSupplementInput!]
  text: String!
  value: String
}

type CreateAppointment {
  appointment: Appointment
  message: String!
  success: Boolean!
}

input CreateAppointmentInput {
  appointmentType: ID!
  coach: ID
  contactType: CalendarContactType
  datetime: DateTime!
  note: String
  postEventStatus: PostEventStatus
  timezone: String
}

type CreateArticleRecommended {
  articleRecommended: ArticleRecommended
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateArticleRecommendedInput {
  articleId: ID!
  biomarkerId: ID!
  normalValues: [GenericScalar!]
  range: BiomarkerRangeInput
}

type CreateAssessment {
  assessment: Assessment
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateAssessmentInput {
  assessmentType: AssessmentType = COMMON
  bottomProgressBar: Boolean = false
  closeButton: Boolean = true
  description: String
  disableLoader: Boolean
  hasScore: Boolean = true
  icon: Upload
  interval: Int
  isDraft: Boolean = true
  isPublic: Boolean = true
  order: Int = 0
  progressBar: Boolean = true
  progressMaxCount: Int = 0
  relativeButtonPosition: Boolean
  resultsImageUrl: String
  style: GenericScalar
  title: String!
  weight: Int
}

type CreateAssistant {
  assistant: Assistant
  errors: [FormError!]
  message: String!
  success: Boolean!
}

type CreateAssistantConversationMessage {
  message: String!
  response: AssistantConversationResponse
  success: Boolean!
}

input CreateAssistantInput {
  mainGoal: String!
  mode: AssistantMode = MANUAL
  name: String!
  onboarding: Boolean
  onboardingPrompt: String
  program: ID
  voice: String
}

type CreateBiomarkerCategory {
  biomarkerCategory: BiomarkerCategory
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateBiomarkerCategoryInput {
  name: String!
  order: Int
  parent: ID
}

type CreateCoachTeam {
  coachTeam: CoachTeam
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateCoachTeamInput {
  coaches: [ID!]
  description: String
  name: String!
}

type CreateCoachType {
  coachType: CoachType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateCoachTypeInput {
  coaches: [ID!]
  description: String
  name: String!
}

type CreateContentCategory {
  contentCategory: ContentCategoryType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateContentCategoryInput {
  image: Upload
  lang: GenericScalar
  name: String!
  order: Int!
  subcategories: [ID]
  subtitle: String
  tags: [ID]
}

type CreateContentLibrary {
  contentLibrary: ContentLibraryType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateContentLibraryInput {
  categories: [ID]
  imageUrl: String!
  isBlocked: Boolean
  isFeatured: Boolean
  lang: GenericScalar = "{}"
  order: Int
  programs: [ID]
  sourceUrl: String
  subTitle: String
  tags: [ID]
  title: String!
}

type CreateContentTag {
  contentTag: ContentTagType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

type CreateDailyRecapAnswer {
  dailyRecapAnswer: DailyRecapAnswer
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateDailyRecapAnswerInput {
  answer: String!
  lang: GenericScalar = "{}"
  type: String!
}

type CreateDailyRecapEntry {
  message: String!
  success: Boolean!
}

type CreateDailyRecapQuestion {
  dailyRecapQuestion: ThirdPartyDailyRecapQuestion
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateDailyRecapQuestionInput {
  answers: [ID]!
  imageUrl: String
  lang: GenericScalar
  program: ID
  question: String!
}

input CreatedAtRangeInput {
  end: Date!
  start: Date!
}

type CreateDayJourney {
  dayJourney: DayJourneyType
  message: String!
  success: Boolean!
}

type CreateDietPreference {
  dietPreference: DietPreference
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateDietPreferenceInput {
  name: String!
  restrictions: [ID!]
}

input CreateDynamicQuestionInput {
  dependsOnAnswers: [ID!]!
  order: Int = 0
  parentQuestionId: ID
}

type CreateExpressTrack {
  message: String!
  success: Boolean!
}

type CreateGooglePlayTransaction {
  message: String
  success: Boolean
}

type CreateGuardrail {
  errors: [FormError!]
  guardrail: Guardrail
  message: String!
  success: Boolean!
}

input CreateGuardrailInput {
  assistant: ID!
  description: String!
  message: String!
  name: String!
}

type CreateInteraction {
  interaction: InteractionType
  message: String!
  success: Boolean!
}

type CreateJourney {
  journey: JourneyAssistantType
  message: String!
  success: Boolean!
}

type CreateJourneyChat {
  message: String!
  response: JourneyChatResponse
  success: Boolean!
}

type CreateKnowledgeBase {
  errors: [FormError!]
  knowledgeBase: KnowledgeBaseType
  message: String!
  success: Boolean!
}

type CreateKnowledgeBaseChat {
  message: String!
  response: KnowledgeBaseChatResponse
  success: Boolean!
}

type CreateLabTestReport {
  message: String!
  report: LabTestReport
  success: Boolean!
}

type CreateMealEntry {
  message: String!
  success: Boolean!
}

type CreateMealLogMutation {
  databaseId: String
  success: Boolean
}

type CreateMealPlanTemplate {
  mealPlan: MealPlanTemplate
  message: String!
  success: Boolean!
}

type CreateMyBrandedFood {
  message: String!
  success: Boolean!
}

input CreateMyBrandedFoodInput {
  brandName: String
  brandOwner: String!
  brandedFoodCategory: String
  description: String
  gtinUpc: String!
  householdServingFulltext: String
  name: String!
  nutrients: [NutrientInput!]!
  servingSize: Float!
  servingSizeUnit: String!
}

type CreateMyChecklistItem {
  message: String!
  myChecklistItem: MyChecklistItem
  success: Boolean!
}

type CreateMyChecklistItemLog {
  message: String!
  success: Boolean!
}

type CreateMyCommonFood {
  message: String!
  success: Boolean!
}

input CreateMyCommonFoodInput {
  description: String
  name: String
  nutrients: [NutrientInput]
  portions: [PortionInput!]!
}

type CreateMyRecipe {
  message: String!
  recipe: UserRecipe
  success: Boolean!
}

input CreateMyRecipeInput {
  courses: [String!]!
  cuisines: [String!]!
  ingredientLines: [String!]!
  ingredients: [IngredientAmount!]!
  instructions: [String!]
  language: Language
  mainImage: String
  mealTimes: [MealTime!]!
  name: String!
  numberOfServings: Int!
  squareImage: String
  tags: [String!]
  text: String
  totalTime: String
  totalTimeInSeconds: Int
}

type CreateNote {
  message: String!
  note: Note
  success: Boolean!
}

type CreateOwnMealLogMutation {
  databaseId: String
  message: String
  success: Boolean
}

type CreateOwnRecipe {
  databaseId: String
  success: Boolean
}

type CreateProfileBiomarkers {
  success: Boolean
}

type CreateProfileCustomAttributes {
  errors: [ErrorType]
  success: Boolean
}

type CreateQuestion {
  errors: [FormError!]
  message: String!
  question: AssessmentQuestion
  success: Boolean!
}

input CreateQuestionAnswerInput {
  attribute: AttributeInput
  isCorrect: Boolean = false
  nextQuestionId: ID
  score: Int
  text: String!
  value: String
}

input CreateQuestionInput {
  answers: [CreateQuestionAnswerInput!]
  assessmentId: ID!
  attributes: [ID!]
  canSkip: Boolean = false
  collapsibleHelpText: Boolean = false
  comment: String
  dynamicQuestion: CreateDynamicQuestionInput
  finalButton: String
  finalText: String
  finalTitle: String
  hasDynamicAnswers: Boolean = false
  helpText: String
  helpTitle: String
  htmlElement: FormHtmlElement
  information: String
  informationTitle: String
  isExit: Boolean = false
  isFinalQuestion: Boolean
  isInitialQuestion: Boolean
  maxOptionsSelected: Int
  minOptionsSelected: Int
  nextQuestionId: ID
  profileField: ProfileField
  questionType: QuestionType = SINGLE_SELECT
  text: String!
}

type CreateQuizResult {
  errors: [ErrorType]
  success: Boolean
}

input CreateSPInput {
  coach: ID
  exercise: String
  isActive: Boolean
  name: String!
  nutrition: String
  overview: String
  protocols: [SPProtocolInput!]
  resources: String
  startDate: Date!
  supplements: [SingleSupplementActivableProtocolInput!]
  visibility: Boolean
}

type CreateSupplement {
  message: String!
  success: Boolean!
  supplement: Supplement
}

input CreateSupplementInput {
  brand: String!
  category: String!
  description: String
  directionsOfUse: [DirectionsOfUseInput!]
  directionsOfUseText: String
  externalId: String
  images: [String!]
  ingredients: String
  instructions: String
  mainImage: String!
  name: String!
  servingName: String!
  shopifyParentId: String
  shopifyVariantId: String
  sizeCount: Int
  sku: String
  storeId: String
  supplementFacts: String
}

type CreateSupplementPlan {
  message: String!
  success: Boolean!
  supplementPlan: SupplementPlan
}

type CreateSupplementRecommended {
  errors: [FormError!]
  message: String!
  success: Boolean!
  supplementRecommended: SupplementRecommended
}

input CreateSupplementRecommendedInput {
  biomarkerId: ID!
  normalValues: [GenericScalar!]
  range: BiomarkerRangeInput
  supplementId: ID!
}

type CreateThirdPartyGoal {
  goal: ThirdPartyGoal
  message: String!
  success: Boolean!
}

input CreateThirdPartyGoalInput {
  goal: TrackerComponent!
  value: Float!
}

type CreateTwilioAccessToken {
  jwt: String
  message: String!
  success: Boolean!
}

type CreateUser {
  message: String!
  success: Boolean!
  user: User
}

type CreateWeightEntry {
  message: String
  success: Boolean
}

type Cuisine implements Node {
  id: ID!
  name: String!
}

type CuisineConnection {
  edges: [CuisineEdge]!
  pageInfo: PageInfo!
}

type CuisineEdge {
  cursor: String!
  node: Cuisine
}

type DailyChecklist {
  days: [DayChecklistItems!]!
  icon: String
  name: String!
}

type DailyExerciseTime {
  floatTotalTime: Float!
  totalTime: Int! @deprecated
  type: String
}

type DailyMoodSummary {
  answersStats: [AnswerCounter!]!
  question: DailyQuestion
}

type DailyQuestion {
  answers: [Answer]
  done: Boolean
  group: GroupQuestion
  id: ID
  imageUrl: String
  isDefault: Boolean!
  question: String
  title: String
}

type DailyRecap {
  date: Date!
  questions: [DailyQuestion!]!
}

type DailyRecapAnswer implements Node {
  answer: String
  id: ID!
  imageUrl: String
  lang: JSONString!
  type: String!
}

enum DailyRecapQuestionGroup {
  MOOD
}

type DailyStreakScore {
  date: Date!
  score: Float!
}

type Dashboard {
  components: [EntryType!]!
  goals: [ComponentGoal!]!
}

type DashboardPDFType {
  databaseId: String
  id: ID!
  name: String!
  pdfUrl: String
}

scalar Date

scalar DateTime

type Day {
  closing: String
  description: String
  opening: String
}

type DayChecklistItems {
  date: Date!
  items: [ChecklistItem!]!
}

input DayJourneyInput {
  interactions: [InteractionInput]!
  journeyId: ID
  order: Int!
  skipped: Boolean!
}

type DayJourneyType {
  id: ID
  interactions: [InteractionType]
  order: Int!
  skipped: Boolean!
}

enum DayStatus {
  EMPTY_DAY
  GOOD_DAY
  PERFECT_DAY
  REGULAR_DAY
}

type DebugMealPlanVariables {
  conditions: DebugMPConditions
  format: [String!]
  kcal: Int!
  restrictions: [String!]
  skipIds: [String!]
}

type DebugMPConditions {
  chocdf: Int
  decrease: [String!]
  distribution: DebugMPMealTimeValues
  fat: Int
  include: [String!]
  increase: [String!]
  maxEnercKcal: Int
  maxIngredientsCount: DebugMPMealTimeValues
  maxNumOfServings: Int
  maxPrepTimeMinutes: DebugMPMealTimeValues
  maxServingWeight: Int
  minServingWeight: Int
  omega3: Int
  procnt: Int
}

type DebugMPMealTimeValues {
  breakfast: Int
  dinner: Int
  lunch: Int
  snack: Int
}

type DeleteAnswer {
  answer: AssessmentAnswer
  message: String!
  success: Boolean!
}

type DeleteArticleRecommended {
  articleRecommended: ArticleRecommended
  message: String!
  success: Boolean!
}

type DeleteAssessment {
  assessment: Assessment
  message: String!
  success: Boolean!
}

type DeleteAssistant {
  message: String!
  success: Boolean!
}

type DeleteBiomarker {
  biomarker: Biomarker
  message: String!
  success: Boolean!
}

type DeleteBiomarkerCategory {
  biomarkerCategory: BiomarkerCategory
  message: String!
  success: Boolean!
}

type DeleteBloodPressureLog {
  message: String!
  success: Boolean!
}

type DeleteCoachTeam {
  coachTeam: CoachTeam
  message: String!
  success: Boolean!
}

type DeleteCoachType {
  coachType: CoachType
  message: String!
  success: Boolean!
}

type DeleteContentCategory {
  contentCategory: ContentCategoryType
  message: String!
  success: Boolean!
}

type DeleteContentLibrary {
  contentLibrary: ContentLibraryType
  message: String!
  success: Boolean!
}

type DeleteContentTag {
  contentTag: ContentTagType
  message: String!
  success: Boolean!
}

type DeleteDailyRecapAnswer {
  dailyRecapAnswer: DailyRecapAnswer
  message: String!
  success: Boolean!
}

type DeleteDailyRecapEntry {
  message: String!
  success: Boolean!
}

type DeleteDailyRecapQuestion {
  dailyRecapQuestion: ThirdPartyDailyRecapQuestion
  message: String!
  success: Boolean!
}

type DeleteDayJourney {
  message: String!
  success: Boolean!
}

type DeleteDietPreference {
  dietPreference: DietPreference
  message: String!
  success: Boolean!
}

type DeleteDynamicQuestion {
  dynamicQuestion: AssessmentDynamicQuestion
  message: String!
  success: Boolean!
}

type DeleteExerciseEntry {
  message: String!
  success: Boolean!
}

type DeleteExpressTrack {
  message: String!
  success: Boolean!
}

type DeleteFoodLog {
  message: String!
  success: Boolean!
}

type DeleteGuardrail {
  guardrail: Guardrail
  message: String!
  success: Boolean!
}

type DeleteHeartRateLog {
  message: String!
  success: Boolean!
}

type DeleteHRVLog {
  message: String!
  success: Boolean!
}

type DeleteInteraction {
  interaction: InteractionType
  message: String!
  success: Boolean!
}

type DeleteKnowledgeBase {
  message: String!
  success: Boolean!
}

type DeleteLabTestReport {
  message: String!
  report: LabTestReport
  success: Boolean!
}

type DeleteMealPlanTemplate {
  mealPlan: MealPlanTemplate
  message: String!
  success: Boolean!
}

type DeleteMyBrandedFood {
  message: String!
  success: Boolean!
}

type DeleteMyChecklistItem {
  message: String!
  myChecklistItem: MyChecklistItem
  success: Boolean!
}

type DeleteMyChecklistItemLog {
  message: String!
  success: Boolean!
}

type DeleteMyCommonFood {
  message: String!
  success: Boolean!
}

type DeleteMyRecipe {
  message: String!
  success: Boolean!
}

type DeleteNote {
  message: String!
  note: Note
  success: Boolean!
}

type DeleteQuestion {
  message: String!
  question: AssessmentQuestion
  success: Boolean!
}

type DeleteSleepQualityScore {
  message: String!
  success: Boolean!
}

type DeleteSleepTime {
  message: String!
  success: Boolean!
}

type DeleteStepsCount {
  message: String!
  success: Boolean!
}

type DeleteSupplementRecommended {
  message: String!
  success: Boolean!
  supplementRecommended: SupplementRecommended
}

type DeleteThirdPartyGoal {
  message: String!
  success: Boolean!
}

type DeleteWeightEntry {
  message: String!
  success: Boolean!
}

type Depletion implements Node {
  createdAt: DateTime!
  description: String
  foods: String
  foodsSourceUrl: String
  id: ID!
  ingredient: DrugIngredient
  referenceUrl: String
  restrictions: [Restriction!]
  updatedAt: DateTime!
}

type DepletionConnection {
  edges: [DepletionEdge]!
  pageInfo: PageInfo!
}

type DepletionEdge {
  cursor: String!
  node: Depletion
}

enum DialogCollectionType {
  BOOL
  CHAR
  DATETIME
  INT
}

type DialogType {
  action: String!
  attachment: GenericScalar
  catalog: String!
  collectionType: DialogCollectionType
  databaseId: String
  defaultJump: String!
  deviceAction: String!
  endpoint: String!
  field: String!
  htmlUrl: String
  id: ID!
  jumpFalse: String!
  messages: [String!]
  name: String!
  taskList: TaskListType
  title: String
  type: String!
  uploadedVideo: String
  valueType: DialogValueType
  video: String!
  videoThumbnail: String
}

enum DialogValueType {
  DATE
  DATETIME
  FLOAT
  INTEGER
  NULL
  STRING
}

enum DietaryTag {
  DAIRY_FREE
  GLUTEN_FREE
  PLANT_BASED
  VEGAN
  VEGETARIAN
}

type DietPreference {
  id: ID!
  name: String!
  restrictions: [UUID!]!
}

input DirectionsOfUseInput {
  quantity: Float!
  timeOfDay: TimeOfDay!
}

type Drug implements Node {
  createdAt: DateTime!
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type DrugGroup implements Node {
  createdAt: DateTime!
  depletions(after: String, before: String, first: Int, last: Int, offset: Int): DepletionConnection
  drugs: [Drug!]
  id: ID!
  interactions(after: String, before: String, first: Int, last: Int, offset: Int): InteractionConnection
  name: String!
  updatedAt: DateTime!
}

type DrugGroupConnection {
  edges: [DrugGroupEdge]!
  pageInfo: PageInfo!
}

type DrugGroupEdge {
  cursor: String!
  node: DrugGroup
}

type DrugIngredient {
  groups: [String!]
  id: ID!
  name: String!
}

input DrugNutrientInteractionsFilterInput {
  name: String
}

type DuplicateMealPlanTemplate {
  mealPlan: MealPlanTemplate
  message: String!
  success: Boolean!
}

type Entry {
  createdAt: DateTime
  date: Date
  source: SourceType
  value: Float
}

enum EntryType {
  BLOOD_PRESSURE_TRACKER
  DAILY_MOOD
  DAILY_RECAP
  EXERCISE_TRACKER
  FOOD_LOGS
  FOOD_LOG_MEAL_TRACKER
  HEART_RATE_TRACKER
  HRV_TRACKER
  HYDRATION_TRACKER
  MP_MEAL_TRACKER
  MY_CHECKLIST_TRACKER
  PLAN_SUPPLEMENT
  PLAN_SUPPLEMENTS_MY_CHECKLIST
  SLEEP_QUALITY_SCORE_TRACKER
  SLEEP_TIME_TRACKER
  STEPS_TRACKER
  TODAY_FOOD
  TODAY_SUPPLEMENT
  WEIGHT_TRACKER
}

type ErrorType {
  field: String!
  messages: [String!]!
}

type EscalationConnection {
  count: Int
  edges: [EscalationEdge]!
  pageInfo: PageInfo!
}

type EscalationConversationResponse {
  flagged: Boolean
  name: String
}

type EscalationEdge {
  cursor: String!
  node: EscalationType
}

input EscalationFilters {
  assistant: ID
}

enum EscalationRedirectTo {
  CONCIERGE
  NONE
  SUPPORT
}

type EscalationType implements Node {
  alertCoach: Boolean!
  assistant: Assistant!
  autoRespond: Boolean!
  autoRespondText: String
  description: String!
  flagMessage: Boolean!
  id: ID!
  name: String!
  redirectTo: EscalationRedirectTo!
}

enum EventParticipationStatus {
  ACCEPTED
  DECLINED
  NEEDS_ACTION
  TENTATIVE
  UNKNOWN
}

enum EventStatus {
  CANCELLED
  CONFIRMED
  TENTATIVE
  UNKNOWN
}

enum EventType {
  SESSION
}

type ExerciseEntriesConnection {
  dailyGoal: Int!
  edges: [ExerciseEntryEdge]!
  floatTotalTime: Float!
  latestEntry: DateTime
  pageInfo: PageInfo!
  totalTime: Int! @deprecated
  totalTimePerType: [DailyExerciseTime!]!
}

type ExerciseEntry {
  calories: Int
  createdAt: DateTime!
  datetime: DateTime!
  durationMinutes: Int! @deprecated
  floatDurationMinutes: Float!
  id: ID!
  intensity: ExerciseIntensity
  source: SourceType

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
  type: ExerciseType
}

type ExerciseEntryEdge {
  cursor: String!
  node: ExerciseEntry
}

input ExerciseEntryInput {
  datetime: DateTime!
  durationMinutes: PositiveInt!
  intensity: ExerciseIntensity
  source: SourceType
  type: ExerciseType
}

enum ExerciseIntensity {
  LOW
  MODERATE
  VIGOROUS
}

enum ExerciseType {
  ACTIVE
  BREATHWORK
  CARDIO
  CYCLE
  DANCE
  HIKE
  HOUSEHOLD_CHORES
  IN_BED_EXERCIES
  JOG_OR_RUN
  OTHER
  PHYSICAL_THERAPY_EXERCISES
  PILATES
  RECOVERY
  STRENGTH
  STRETCH
  SWIM
  WALK
  WORKOUT_ROUTINE
  YARD_WORK
  YOGA
}

type ExpressMealTrack {
  calories: Float!
  carbs: Float!
  createdAt: DateTime!
  datetime: DateTime!
  fats: Float!
  id: ID!
  mealTime: MealTime!
  proteins: Float!
}

type ExpressMealTrackConnection {
  edges: [ExpressMealTrackEdge]!
  pageInfo: PageInfo!
}

type ExpressMealTrackEdge {
  cursor: String!
  node: ExpressMealTrack
}

union Food = BrandedFoodNodeProxy | CommonFoodNodeProxy | GenericFoodNodeProxy | MealProxy | MyBrandedFoodProxy | MyCommonFoodProxy | RecipeProxy | UserRecipeProxy

enum FoodCategory {
  BRANDED
  COMMON
  COMMON_NCC
  GENERIC_FOOD
  MEAL_PLAN_MEAL
  MY_BRANDED
  MY_COMMON
  RECIPE
  USER_RECIPE
}

input FoodFilter {
  barcode: String
  externalId: String
  id: ID
  ingredients: [String!]
  mealTime: MealTime
  must: [FoodFilter!]
  name: String
  nutrients: [NutrientFilterInput!]
  should: [FoodFilter!]
  tags: [String]
}

type FoodLog {
  date: Date!
  food: Food!
  foodId: ID!
  grams: Float
  id: ID!
  mealTime: MealTime!
  portionModifier: String
  servings: Float
  time: Time
  type: FoodCategory!
}

type FoodLogAssistant {
  id: ID!
  ingredients: [AssistantIngredient]
}

type FoodLogConnection {
  edges: [FoodLogEdge]!
  macros: [MacroNutrientLogged!]!
  pageInfo: PageInfo!
}

type FoodLogEdge {
  cursor: String!
  node: FoodLog
}

type FoodProduct {
  brand: String
  databaseId: String
  displayName: String
  isIncomplete: Boolean
  isVerified: Boolean
  longDesc: String
  mealType: MealType
  name: String
  nutritionalInfo: NutritionalInfo
  serving: Int
  servings: [Servings]
}

type FormError {
  field: String
  messages: [String!]
}

enum FormHtmlElement {
  CHECKBOX
  INPUT
  RADIO_BUTTON
  SELECT
  TEXTAREA
}

type GenerateMagicLink {
  magicLink: String
  message: String!
  success: Boolean!
}

type GenerateMealPlan {
  mealPlan: [MealPlanDay!]
  message: String
  success: Boolean
}

type GenerateShopifyMultipassUrl {
  message: String!
  success: Boolean!
  url: String
}

input GenerateShopifyMultipassUrlInput {
  returnTo: String
}

type GenerateSimpleMealPlan {
  message: String
  success: Boolean
}

input GenerateVideoZoomTokenInput {
  clientMutationId: String
  password: String
  role: VideoZoomRole
  sessionKey: String
  sessionName: String!
  userIdentity: String
}

type GenerateVideoZoomTokenPayload {
  clientMutationId: String
  message: String!
  success: Boolean!
  token: String
}

type GenericFoodConnection {
  count: Int
  edges: [GenericFoodEdge]!
  pageInfo: PageInfo!
}

type GenericFoodEdge {
  cursor: String!
  node: GenericFoodNode
}

type GenericFoodNode implements Node {
  barcode: String
  brandName: String
  brandOwner: String
  brandedFoodCategory: String
  calories: Float
  dataType: String
  description: String
  foodDataId: String
  id: ID!
  isActive: Boolean!
  isBranded: Boolean
  isCommon: Boolean
  isCore: Boolean!
  isGeneric: Boolean!
  name: String!
  nutrients: [Nutrient!]!
  portions: [Portion]
  servingSize: Float!
  servingSizeUnit: String!
  tags: [String!]!
}

type GenericFoodNodeProxy {
  genericFood: GenericFoodNode!
}

scalar GenericScalar

input GeoBoundingBox {
  bottomRightLat: Float
  bottomRightLon: Float
  topLeftLat: Float
  topLeftLon: Float
}

type GeoPoint {
  lat: Float
  lon: Float
}

type GooglePlayTransactionType implements Node {
  createdAt: DateTime
  databaseId: String
  id: ID!
  rawData: GenericScalar
}

type GooglePlayTransactionTypeConnection {
  edges: [GooglePlayTransactionTypeEdge]!
  pageInfo: PageInfo!
}

type GooglePlayTransactionTypeEdge {
  cursor: String!
  node: GooglePlayTransactionType
}

enum GroupQuestion {
  MOOD
}

type Guardrail implements Node {
  assistant: Assistant!
  createdAt: DateTime!
  description: String!
  id: ID!
  message: String!
  name: String!
  updatedAt: DateTime!
}

type GuardrailConnection {
  edges: [GuardrailEdge]!
  pageInfo: PageInfo!
}

type GuardrailEdge {
  cursor: String!
  node: Guardrail
}

input GuardrailFilterInput {
  assistant: ID
}

enum HabitAnswerType {
  NEGATIVE
  NEUTRAL
  POSITIVE
}

type HardDeleteAppUserProfile {
  email: String
  message: String
  success: Boolean
}

type HardDeleteMyProfileMutation {
  email: String
  success: Boolean
}

input HeartRateEntryInput {
  datetime: DateTime!
  source: SourceType!
  value: PositiveInt!
}

type HeartRateLog {
  createdAt: DateTime!
  id: ID!
  source: SourceType!
  timestamp: DateTime!

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
  value: Float!
}

type HeartRateLogs {
  cursor: String!
  node: HeartRateLog
}

type HeartRateLogsConnnection {
  average: Float!
  edges: [HeartRateLogs]!
  latestEntry: DateTime
  maximum: Float!
  minimum: Float!
  pageInfo: PageInfo!
}

input HistoricalBiomarkerResultsFilterInput {
  biomarkerId: ID
  biomarkerName: String
  categoryId: ID
  intervalRange: BiomarkerIntervalRange
  labTestReportId: ID
}

type Hours {
  friday: Day
  monday: Day
  saturday: Day
  sunday: Day
  thursday: Day
  tuesday: Day
  wednesday: Day
}

input HRVEntryInput {
  datetime: DateTime!
  source: SourceType!
  value: PositiveFloat!
}

type HrvLog {
  createdAt: DateTime!
  id: ID!
  source: SourceType!
  timestamp: DateTime!

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
  value: Float!
}

type HrvLogs {
  cursor: String!
  node: HrvLog
}

type HrvLogsConnnection {
  average: Float!
  edges: [HrvLogs]!
  latestEntry: DateTime
  pageInfo: PageInfo!
}

type Hydration {
  date: Date
  goal: Int
  isToday: Boolean
  quantity: Int
  source: SourceType

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
}

input HydrationEntryInput {
  date: Date!
  quantity: Float!
  source: SourceType
}

enum Icon {
  ALERT
  CROSS
  UNKNOWN
}

type Ingredient {
  confirmed: Boolean
  cpc: String
  name: String
  priority: Float
  type: String
}

input IngredientAmount {
  foodId: ID!
  grams: Float
  milliliters: Float
}

type IngredientFoodFormat {
  foodId: String!
  grams: Float
  milliliters: Float
  name: String!
}

type IngredientLine {
  comment: String
  ingredient: String
  ingredientLine: String
  other: String
  quantity: String
  unit: String
}

type insightFields {
  description: String!
  highlight: String!
  text: String!
}

type InsightsByCategory {
  category: InsightsCategory!
  fields: insightFields
}

enum InsightsCategory {
  SLEEP
  STEPS
}

enum IntakeCategory {
  FOOD
  MY_CHECKLIST_ITEM
  PLAN_SUPPLEMENT
  SUPPLEMENT
}

type IntakesChecklist {
  days: [IntakesChecklistDay!]!
  icon: String
  name: String!
}

type IntakesChecklistDay {
  date: Date!
  items: [AvailableChecklistItems!]!
}

type Interaction implements Node {
  createdAt: DateTime!
  description: String
  foods: String
  foodsSourceUrl: String
  id: ID!
  ingredient: DrugIngredient
  referenceUrl: String
  restrictions: [Restriction!]
  updatedAt: DateTime!
}

type InteractionConnection {
  edges: [InteractionEdge]!
  pageInfo: PageInfo!
}

type InteractionEdge {
  cursor: String!
  node: Interaction
}

input InteractionInput {
  deliveryTime: Time
  goal: String!
  interaction: String!
  order: Int!
}

type InteractionType {
  dayJourneyId: ID
  deliveryTime: Time!
  goal: String!
  id: ID
  interaction: String!
  order: Int!
}

input IntValueByMealTime {
  breakfast: Int
  dinner: Int
  lunch: Int
  snack: Int
}

input ItemDirectionsOfUseInput {
  friday: Boolean
  mealTime: TimeOfDay!
  monday: Boolean
  saturday: Boolean
  sunday: Boolean
  thursday: Boolean
  tuesday: Boolean
  wednesday: Boolean
}

type JourneyAssistantType {
  dayJourney: [DayJourneyType]
  id: ID
  sendWelcomeMessage: Boolean!
  welcomeMessage: String
}

type JourneyAssistantTypeResponse {
  journey: JourneyAssistantType
  message: String!
  success: Boolean!
}

type JourneyChatResponse {
  id: ID!
  response: String!
  userMessage: String!
}

type JourneyDialogType {
  dashboard: JourneyType!
  databaseId: String
  dialog: DialogType!
  id: ID!
  sortIndex: Int!
}

input JourneyInput {
  assistantId: ID!
  dayJourney: [DayJourneyInput]!
  sendWelcomeMessage: Boolean
  welcomeMessage: String
}

type JourneyProfileType implements Node {
  createdAt: DateTime
  dashboard: JourneyType!
  databaseId: String
  id: ID!
  profile: ProfileType!
  status: JourneyStatus
  subJourneys: [JourneyProfileType!]!
  updatedAt: DateTime
}

type JourneyProfileTypeConnection {
  edges: [JourneyProfileTypeEdge]!
  pageInfo: PageInfo!
}

type JourneyProfileTypeEdge {
  cursor: String!
  node: JourneyProfileType
}

enum JourneyStatus {
  CLOSE
  FINISH
  OPEN
}

type JourneyType {
  dashboardDialogs: [JourneyDialogType!]!
  databaseId: String
  daysIntoProgram: Int!
  externalUrl: String!
  header: String!
  id: ID!
  pdfs: [String!]!
  pdfsRel: [DashboardPDFType!]!
  program: Program
  subJourneys: [JourneyType!]!
  subTitle: String
  title: String
}

scalar JSONString

enum KnowledgeBaseCategory {
  GENERAL
  PRODUCT
  SUPPORT
}

type KnowledgeBaseChatResponse {
  id: ID!
  response: String!
  userMessage: String!
}

type KnowledgeBaseResponse {
  knowledgeBase: KnowledgeBaseType
  message: String!
  success: Boolean!
}

enum KnowledgeBaseTaskStatus {
  CREATED
  DONE
  ERROR
  PROCESSING
}

type KnowledgeBaseType {
  category: KnowledgeBaseCategory
  id: ID
  name: String!
  pdfFile: String
  pdfUrl: String
  sitemapUrl: String
  sitemapUrls: [SitemapUrlType]
  taskStatus: KnowledgeBaseTaskStatus!
  txt: String
  url: String!
}

type LabTestReport {
  alert: Boolean
  alertAction: AlertAction
  alertStatus: AlertStatus
  alertText: String
  createdAt: DateTime!
  description: String
  externalId: String
  id: ID!
  image: String
  imageUrl: String
  isVisible: Boolean!
  labName: String!
  orderId: String
  orderingPhysician: String
  productId: String
  reportPdf: String
  requisitionId: String
  sampleCollectionDate: Date
  status: LabTestReportStatus
  testDate: DateTime
  testName: String!
  title: String
  updatedAt: DateTime!
  userEmail: String
  videoUrl: String
}

type LabTestReportConnection {
  edges: [LabTestReportEdge]!
  pageInfo: PageInfo!
}

type LabTestReportEdge {
  cursor: String!
  node: LabTestReport
}

enum LabTestReportStatus {
  CREATED
  ERROR
  FULFILLED
  ORDERED
  PROCESS_COMPLETE
  RESULTS_DELIVERED
  RESULTS_READY
  RETURNED_TO_LAB
}

enum Language {
  AR
  EN
  EN_GB
  ES
  NL
}

type Limitation {
  level: String!
  limit: Int!
  periodicity: String!
  subscriptionId: ID!
}

type LinkUserAssessment {
  message: String!
  success: Boolean!
  userAssessment: Assessment
}

input LinkUserAssessmentInput {
  assessmentId: ID!
}

type ListItem implements Node {
  aggregation(after: String, before: String, first: Int, last: Int, offset: Int): AggregateConnection!
  aisleName: String
  comment: String
  createdAt: DateTime!
  databaseId: String
  errors: [String]
  floatQuantity: Float
  grams: Float
  id: ID!
  ingredient: String!
  ingredientLine: String
  isCleared: Boolean!
  isDone: Boolean!
  numberOfServings: Int
  parse: JSONString!
  profile: ProfileType!
  quantity: String
  quantityMetric: String
  recipeId: String
  recipeName: String
  recipeServings: Int
  unit: String
  unitMetric: String
  updatedAt: DateTime!
}

type ListItemConnection {
  edges: [ListItemEdge]!
  pageInfo: PageInfo!
}

type ListItemEdge {
  cursor: String!
  node: ListItem
}

type LocationAutocomplete {
  city: String
  daylightSavingsTimeFlag: Boolean
  location: GeoPoint
  state: String
  suggest: String
  timezone: Int
  zipcode: String
}

type Logger implements Node {
  adherenceScore: Float
  host: String
  id: ID!
  indexedAt: DateTime
  isPremium: Boolean
  location: [Float]
  method: String
  path: String
  profileId: String
  program: String
  requestBody: String
  requestGet: GenericScalar
  requestPost: GenericScalar
  response: GenericScalar
  restrictions: [String]
  statusCode: String
  uri: String
  user: String
  userId: String
}

type LoggerConnection {
  edges: [LoggerEdge]!
  pageInfo: PageInfo!
}

type LoggerEdge {
  cursor: String!
  node: Logger
}

type LoginUser {
  accessToken: String
  refreshToken: String
}

type LogRecipeIngredient {
  id: String!
  mealType: MealType!
  name: String
  quantity: Float!
  serving: Int!
}

type MacroGoals {
  bmi: Int
  bmr: Int
  carbs: MacroNutrientGoal
  cd: Int
  dcig: Int
  fat: MacroNutrientGoal
  isUserGoal: Boolean
  name: String
  netcarbs: MacroNutrientGoal
  protein: MacroNutrientGoal
  tdee: Int
}

type MacroNutrientGoal {
  color: String
  goal: Float
  left: Float
  logged: Float
  lowerLimit: Float
  upperLimit: Float
}

type MacroNutrientLogged {
  goal: Int
  name: String!
  value: Int!
}

input MacroNutrientsRangeInput {
  ala: Range
  calcium: Range
  calories: Range
  carbs: Range
  carbsCalories: Range
  cholesterol: Range
  dha: Range
  dpa: Range
  epa: Range
  fat: Range
  fatCalories: Range
  fiber: Range
  iron: Range
  monounsaturatedFat: Range
  netcarbs: Range
  polyunsaturatedFat: Range
  potassium: Range
  protein: Range
  proteinCalories: Range
  saturatedFat: Range
  sodium: Range
  sugar: Range
  transFat: Range
  vitaminA: Range
  vitaminB6: Range
  vitaminB12: Range
  vitaminC: Range
  vitaminD: Range
  vitaminE: Range
}

type MarkContentAsReadOrUnread {
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input MarkContentAsReadOrUnreadInput {
  contentLibraryId: ID!
  markAsRead: Boolean!
}

type Meal {
  calories: Float
  id: String
  maxNumOfServings: Int
  meal: String
  numOfServings: Int
  recipe: Recipe
}

type MealBalanceIndexScore {
  errors: [String!]
  message: String
  score: Int
}

type MealCustomPlannerDays {
  day1: [MealPlanDayRecipe]
  day2: [MealPlanDayRecipe]
  day3: [MealPlanDayRecipe]
  day4: [MealPlanDayRecipe]
  day5: [MealPlanDayRecipe]
  day6: [MealPlanDayRecipe]
  day7: [MealPlanDayRecipe]
  day8: [MealPlanDayRecipe]
}

type MealLog implements Node {
  adherence: Float
  barcode: String
  brand: String
  createdAt: DateTime
  databaseId: String
  date: Date
  extraInfo: String
  id: ID!
  ingredients: [LogRecipeIngredient]
  isNew: Boolean
  isVerified: Boolean
  macrosLog: Nutrients
  mealDatabaseId: String
  mealTime: MealTime
  mealType: MealType
  mealTypeDisplayName: String
  name: String
  nutrients: Nutrients @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutrientsFull: NutrientsFull @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutritionalInfo: NutritionalInfo
  quantity: Float
  recipe: Recipe
  secondaryInfoText: String
  serving: Int
  servingWeight: Float
  servings: [Servings]
  timestamp: DateTime
  updatedAt: DateTime
  userPid: String
}

type MealLogConnection {
  edges: [MealLogEdge]!
  pageInfo: PageInfo!
}

type MealLogEdge {
  cursor: String!
  node: MealLog
}

type MealLogMacroAggs {
  calories: Float
  chocdf: Float
  fat: Float
  fibtg: Float
  netcarbs: Float
  procnt: Float
  sugar: Float
}

type MealPlanDay {
  calories: Float
  carbs: Float
  date(useDatetime: Boolean): String
  day: Int
  fat: Float
  id: ID!
  meals: [Meal]
  protein: Float
}

type MealPlanDayRecipe {
  mealTime: String
  programDate: Date
  recipe: Recipe
}

enum MealPlanDiversity {
  HIGH
  LOW
  MEDIUM
}

type MealPlannerDays {
  day1: MealPlannerDayTime
  day2: MealPlannerDayTime
  day3: MealPlannerDayTime
  day4: MealPlannerDayTime
  day5: MealPlannerDayTime
  day6: MealPlannerDayTime
  day7: MealPlannerDayTime
  day8: MealPlannerDayTime
}

type MealPlannerDayTime {
  breakfast: [Recipe]
  dinner: [Recipe]
  lunch: [Recipe]
  programDate: Date
  snack: [Recipe]
}

enum MealPlannerQueryType {
  DAY_AGGREGATE
  RAW
  SUGGESTIONS
}

type MealPlanTemplate implements Node {
  coachId: ID
  coachName: String
  coachTypes(after: String, before: String, first: Int, last: Int, offset: Int): CoachTypeConnection
  createdAt: DateTime!
  days: [MealPlanDay!]!
  description: String!
  id: ID!
  isPublic: Boolean!
  name: String!
}

type MealPlanTemplateConnection {
  edges: [MealPlanTemplateEdge]!
  pageInfo: PageInfo!
}

type MealPlanTemplateEdge {
  cursor: String!
  node: MealPlanTemplate
}

type MealProxy {
  meal: Meal!
}

enum MealTime {
  BREAKFAST
  DINNER
  LUNCH
  SNACK
}

type MealTrack {
  date: Date!
  meal: Meal!
  mealId: ID!
  value: MealTrackStatus!
}

enum MealTrackStatus {
  ATE
  DELETE
  OTHER_FOLLOWING
  OTHER_NOT_FOLLOWING
  SKIPPED
}

enum MealType {
  BRANDED_FOOD
  COMMON_FOOD
  COMMON_NCC
  GENERIC_FOOD
  MEAL_PLAN_MEAL
  MENU_ITEM
  MY_BRANDED_FOOD
  MY_COMMON_FOOD
  OWN_ITEM
  OWN_RECIPE
  RECIPE
  USDA_MEAL
  USER_RECIPE
}

type MenuItem implements Node {
  adherence: Adherence
  annotation: GenericScalar
  confirmedIngredients: [String]
  course: String @deprecated(reason: "use `courses` a menu item can have more than one course")
  courses: [String]
  createdAt: DateTime
  databaseId: String
  deciderSource: String
  deciderVersion: Int
  description: String
  favoritesCount: Int
  hasNutrients: Boolean
  id: ID!
  indexedAt: DateTime
  ingredients: [Ingredient]
  isActive: Boolean
  isAnnotated: Boolean
  isIndexed: Boolean
  isRecommended: Boolean
  isSourceActive: Boolean
  isUserFavorite: Boolean
  isValidated: Boolean
  language: String
  maxPrice: Float
  mayHave: [Ingredient]
  mealTags: [String]
  menu: String
  minPrice: Float
  name: String
  nutrients: Nutrients @deprecated(reason: "use `nutritional_info`")
  nutritionalInfo: NutritionalInfo
  parent: String
  portionSize: String
  programScore: Float
  programs: [String]
  programsIds: [String]
  restaurant: Restaurant
  restaurantId: String
  restaurantName: String
  sectionName: String
  tags: [String]
  trustMe: Boolean
  type: String
  updatedAt: DateTime
  usersFavorite: [String]
}

type MenuItemConnection {
  edges: [MenuItemEdge]!
  pageInfo: PageInfo!
}

type MenuItemEdge {
  cursor: String!
  node: MenuItem
}

type MergeUser {
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input MergeUserInput {
  userOrigin: ID!
  userTarget: ID!
}

input MessageInput {
  assistantId: ID!
  userMessage: String!
}

type Money {
  amount: Float!
  currencyCode: String!
}

input MPTCustomOptionsInput {
  calories: Int
  carbsPerc: Int
  fatPerc: Int
  format: [MealTime!]
  program: ID
  proteinPerc: Int
}

input MPTFromDaysInput {
  fromDate: Date!
  profileId: ID!
  toDate: Date!
}

input MPTFromScratchDayInput {
  meals: [MPTFromScratchMealInput!]!
}

input MPTFromScratchInput {
  days: [MPTFromScratchDayInput!]!
}

input MPTFromScratchMealInput {
  mealType: MealTime!
  recipeId: ID!
  servings: Int
}

enum MPVariety {
  HIGH
  LOW
  MEDIUM
}

type Mutation {
  acknowledgeConversationMessage(input: AcknowledgeConversationMessageInput!): AcknowledgeConversationMessage
  addBiomarker(input: AddBiomarkerInput!): AddBiomarker
  addBiomarkerResults(input: AddBiomarkerResultsInput!): AddBiomarkerResults
  addBloodPressureLog(datetime: DateTime!, diastolicValue: PositiveInt!, source: SourceType, systolicValue: PositiveInt!): AddBloodPressureLog!
  addCoachChatConversation(input: AddCoachChatConversationInput!): AddCoachChatConversation
  addExerciseEntry(calories: Int, datetime: DateTime!, durationMinutes: Int!, intensity: ExerciseIntensity!, source: SourceType, type: ExerciseType!): AddExerciseEntry!
  addFavoriteArticle(articleId: ID!): AddFavoriteArticle

  """
  addFoodLog logs that the user ate specific food, like a recipe, a personal recipe, a meal plan's meal, etc
  """
  addFoodLog(date: Date!, foodId: ID!, grams: Int, gramsFloat: Float, mealTime: MealTime!, milligrams: Int, portionModifier: String, servings: Float, time: Time): AddFoodLog!

  """addHRVLog add HRV log"""
  addHRVLog(source: SourceType, timestamp: DateTime, value: PositiveFloat!): AddHRVLog!

  """addHeartRateLog add Heart Rate Log log"""
  addHeartRateLog(source: SourceType, timestamp: DateTime, value: PositiveInt!): AddHeartRateLog!
  addRecipesToShoppingList(recipeIds: [String]!): AddRecipesToShoppingList

  """addSleepQualityScore add sleep quality score log"""
  addSleepQualityScore(date: Date, source: SourceType, value: Int!): AddSleepQualityScore!

  """
  addSleepTime add sleep time log | Args: value: Sleep duration in minutes
  """
  addSleepTime(date: Date, source: SourceType, value: Int!): AddSleepTime!
  addStepsCount(datetime: DateTime!, source: SourceType, steps: Int!): AddStepsCount!
  addToShoppingList(recipeId: String!, servings: Int): AddToShoppingList
  addUserConsent(input: AddUserConsentInput!): AddUserConsent
  addUserToJourney(input: AddUserToJourneyInput!): AddUserToJourney
  autoGenerateConversationMessage(input: AutoGenerateConversationMessageInput!): AutoGenerateConversationMessage
  bulkCreateEntries(exerciseEntries: [ExerciseEntryInput!], heartRateEntries: [HeartRateEntryInput!], hrvEntries: [HRVEntryInput!], hydrationEntries: [HydrationEntryInput!], sleepQualityScoreEntries: [SleepQualityEntryInput!], sleepTimeEntries: [SleepTimeEntryInput!], stepsCountEntries: [StepCountEntryInput!], weightEntries: [WeightEntryInput!]): BulkCreateEntries!
  cancelAppointment(appointment: ID!): CancelAppointment
  changeMealPlannerDayMeal(day: Int!, mealTime: MealTime!, recipeId: String!): ChangeMealPlannerDayMeal

  """
  checkIntake creates a log checking that the user ate food that they was supposed to eat as part of a plan
  """
  checkIntake(category: IntakeCategory!, date: Date!, itemId: ID!, timeOfDay: TimeOfDay): CheckIntake!
  checkTodayFood(date: Date!, itemId: ID!): CheckTodayFoodEntry @deprecated(reason: "No longer supported. Use checkIntake instead")
  checkTodaySupplement(date: Date!, itemId: ID!): CheckTodaySupplementEntry @deprecated(reason: "No longer supported. Use checkIntake instead")
  checkoutCreate(input: CheckoutCreateInput!): CheckoutCreate
  clearShoppingList: ClearShoppingList
  clearShoppingListCheckedItems: ClearShoppingListCheckedItems
  confirmFoodLogAssistant(input: ConfirmFoodLogAssistantInput!): ConfirmFoodLogAssistant
  createAnswer(input: CreateAnswerInput!): CreateAnswer
  createAppointment(input: CreateAppointmentInput!): CreateAppointment
  createArticleRecommended(input: CreateArticleRecommendedInput!): CreateArticleRecommended
  createAssessment(input: CreateAssessmentInput!): CreateAssessment
  createAssistant(input: CreateAssistantInput!): CreateAssistant
  createAssistantConversationMessage(assistantConversationInput: AssistantConversationInput!, assistantId: ID!, isInitial: Boolean!, language: String, profileId: ID!, toneOfVoice: String, useLongTermMemory: Boolean, userMessage: String!): CreateAssistantConversationMessage
  createBiomarkerCategory(input: CreateBiomarkerCategoryInput!): CreateBiomarkerCategory
  createCoachTeam(input: CreateCoachTeamInput!): CreateCoachTeam
  createCoachType(input: CreateCoachTypeInput!): CreateCoachType
  createContentCategory(input: CreateContentCategoryInput!): CreateContentCategory
  createContentLibrary(input: CreateContentLibraryInput!): CreateContentLibrary
  createContentTag(name: String!): CreateContentTag
  createDailyRecapAnswer(input: CreateDailyRecapAnswerInput!): CreateDailyRecapAnswer
  createDailyRecapEntry(answerId: String!, date: Date!, questionId: String!): CreateDailyRecapEntry
  createDailyRecapQuestion(input: CreateDailyRecapQuestionInput!): CreateDailyRecapQuestion
  createDayJourney(input: DayJourneyInput!): CreateDayJourney
  createDietPreference(input: CreateDietPreferenceInput!): CreateDietPreference
  createExpressTrack(calories: Float!, carbs: Float!, datetime: DateTime, fats: Float!, mealTime: MealTime!, proteins: Float!): CreateExpressTrack!
  createGooglePlayTransaction(acknowledged: Boolean!, autoRenewing: Boolean!, orderId: String!, packageName: String!, productId: String!, purchaseState: Int!, purchaseTime: Float!, purchaseToken: String!, subscriptionSku: String!): CreateGooglePlayTransaction
  createGuardrail(input: CreateGuardrailInput!): CreateGuardrail
  createInteraction(dayJourneyId: ID!, deliveryTime: Time!, goal: String!, interaction: String!, order: Int!): CreateInteraction
  createJourney(input: JourneyInput!): CreateJourney
  createJourneyChat(assistantId: ID!, interactionId: ID!, userMessage: String!): CreateJourneyChat
  createKnowledgeBase(assistantId: ID!, category: KnowledgeBaseCategory, name: String!, pdfFile: Upload, sitemapUrl: String, txt: String, url: String): CreateKnowledgeBase
  createKnowledgeBaseChat(input: MessageInput!): CreateKnowledgeBaseChat
  createLabTestReport(alert: Boolean, alertAction: AlertAction, alertStatus: AlertStatus, alertText: String, description: String, externalId: String, image: Upload, imageUrl: String, isVisible: Boolean, labName: String!, orderId: String, orderingPhysician: String, productId: String, reportPdf: Upload, requisitionId: String, sampleCollectionDate: Date, status: LabTestReportStatus, testDate: DateTime, testName: String!, title: String, userEmail: String, videoUrl: String): CreateLabTestReport
  createMealEntry(date: Date, mealId: ID!, timezone: String, value: MealTrackStatus): CreateMealEntry
  createMealLog(customServingEquivalent: Float, date: Date, mealDatabaseId: String!, mealTime: MealTime!, mealType: MealType!, quantity: Float!, serving: Float, time: Time): CreateMealLogMutation
  createMealPlanTemplate(coach: ID, customOptions: MPTCustomOptionsInput, description: String!, fromDays: MPTFromDaysInput, fromScratch: MPTFromScratchInput, isPublic: Boolean, name: String!): CreateMealPlanTemplate
  createMyBrandedFoods(input: CreateMyBrandedFoodInput!): CreateMyBrandedFood
  createMyChecklistItem(directionsOfUse: [ItemDirectionsOfUseInput!], header: String!, tags: [String!], text: String): CreateMyChecklistItem

  """
  checkIntake creates a log checking that the user fulfilled the action in one of their personal MyChecklistItem
  """
  createMyChecklistItemLog(date: Date!, itemId: ID!, timeOfDay: TimeOfDay!): CreateMyChecklistItemLog!
  createMyCommonFoods(input: CreateMyCommonFoodInput!): CreateMyCommonFood
  createMyRecipe(input: CreateMyRecipeInput!): CreateMyRecipe
  createNote(coach: ID, eventId: ID, text: String!, title: String!): CreateNote
  createOwnMealLog(barcode: String, brand: String, date: Date, logAfterCreation: Boolean, mealTime: MealTime, mealTimes: [MealTime], mealType: MealType!, name: String!, ownNutrients: OwnNutrients!, ownServing: OwnServing!): CreateOwnMealLogMutation
  createOwnRecipe(ingredients: [OwnRecipeIngredient], logAfterCreation: Boolean, quantity: Float!, recipeName: String!): CreateOwnRecipe
  createProfileBiomarkers(cholesterolLdl: Float, cortisol: Float, ferritin: Float, hba1c: Float, totalCholesterol: Float, vitaminB12: Float, vitaminD: Float): CreateProfileBiomarkers
  createProfileCustomAttributes(append: Boolean, attributes: [ProfileCustomAttribute!]!): CreateProfileCustomAttributes
  createQuestion(input: CreateQuestionInput!): CreateQuestion
  createQuizResult(answers: [String]!, result: String!): CreateQuizResult
  createSupplement(input: CreateSupplementInput!): CreateSupplement
  createSupplementPlan(fromTemplate: ID, input: CreateSPInput): CreateSupplementPlan
  createSupplementRecommended(input: CreateSupplementRecommendedInput!): CreateSupplementRecommended
  createThirdPartyGoal(input: CreateThirdPartyGoalInput!): CreateThirdPartyGoal
  createTwilioAccessToken: CreateTwilioAccessToken
  createUser(birthdate: Date, email: String!, emailPasswordNotification: Boolean, extraData: JSONString, name: String!, password: String, phone: String, program: String, restrictions: [ID!], subscription: ID): CreateUser
  createWeightEntry(date: Date!, source: SourceType, value: Float!): CreateWeightEntry
  deleteAnswer(id: ID!): DeleteAnswer
  deleteAppUserProfile(id: ID!): HardDeleteAppUserProfile
  deleteArticleRecommended(id: ID!): DeleteArticleRecommended
  deleteAssessment(id: ID!): DeleteAssessment
  deleteAssistant(id: ID!): DeleteAssistant
  deleteBiomarker(id: ID!): DeleteBiomarker
  deleteBiomarkerCategory(id: ID!): DeleteBiomarkerCategory
  deleteBloodPressureLog(id: ID!): DeleteBloodPressureLog!
  deleteCoachTeam(id: ID!): DeleteCoachTeam
  deleteCoachType(id: ID!): DeleteCoachType
  deleteContentCategory(id: ID!): DeleteContentCategory
  deleteContentLibrary(id: ID!): DeleteContentLibrary
  deleteContentTag(id: ID!): DeleteContentTag
  deleteDailyRecapAnswer(id: ID!): DeleteDailyRecapAnswer
  deleteDailyRecapEntry(date: Date!, questionId: String!): DeleteDailyRecapEntry
  deleteDailyRecapQuestion(id: ID!): DeleteDailyRecapQuestion
  deleteDayJourney(id: ID!): DeleteDayJourney
  deleteDietPreference(id: ID!): DeleteDietPreference
  deleteDynamicQuestion(id: ID!): DeleteDynamicQuestion
  deleteExerciseEntry(id: ID!): DeleteExerciseEntry!
  deleteExpressTrack(id: ID!): DeleteExpressTrack!

  """deleteFoodLog deletes a food log by ID"""
  deleteFoodLog(id: ID!): DeleteFoodLog!
  deleteGuardrail(id: ID!): DeleteGuardrail

  """deleteHRVLog delete hrv log entry"""
  deleteHRVLog(id: ID!): DeleteHRVLog!

  """deleteHeartRateLog delete Heart Rate Log"""
  deleteHeartRateLog(id: ID!): DeleteHeartRateLog!
  deleteInteraction(interactionId: ID!): DeleteInteraction
  deleteKnowledgeBase(assistantId: ID!, id: ID!): DeleteKnowledgeBase
  deleteLabTestReport(id: ID!): DeleteLabTestReport
  deleteMealPlanTemplate(coach: ID, id: ID!): DeleteMealPlanTemplate
  deleteMyBrandedFood(id: ID!): DeleteMyBrandedFood
  deleteMyChecklistItem(id: ID!): DeleteMyChecklistItem

  """deleteMyChecklistItemLog deletes a MyChecklistItem log by ID"""
  deleteMyChecklistItemLog(date: Date!, itemId: ID!, timeOfDay: TimeOfDay!): DeleteMyChecklistItemLog!
  deleteMyCommonFood(id: ID!): DeleteMyCommonFood
  deleteMyProfile: HardDeleteMyProfileMutation
  deleteMyRecipe(id: ID!): DeleteMyRecipe
  deleteNote(noteId: ID!): DeleteNote
  deleteQuestion(id: ID!): DeleteQuestion

  """deleteSleepQualityScore delete sleep quality score entry"""
  deleteSleepQualityScore(id: ID!): DeleteSleepQualityScore!

  """deleteSleepTime delete sleep time entry"""
  deleteSleepTime(id: ID!): DeleteSleepTime!
  deleteStepsCount(id: ID!): DeleteStepsCount!
  deleteSupplementRecommended(id: ID!): DeleteSupplementRecommended
  deleteThirdPartyGoal(id: ID!): DeleteThirdPartyGoal
  deleteWeightEntry(date: Date!): DeleteWeightEntry
  duplicateMealPlanTemplate(id: ID!): DuplicateMealPlanTemplate
  generateMagicLink(email: String!): GenerateMagicLink
  generateMealPlan(addDays: Boolean, appendDays: Int = 7, breakfastDistribution: Float, dinnerDistribution: Float, fromTemplate: ID, ignoreLock: Boolean, includeFavorites: Boolean, isAppend: Boolean = false, isCache: Boolean, kcalLimit: Float, lunchDistribution: Float, maxIngredientsCount: IntValueByMealTime, maxNumOfServings: Int, maxServingWeight: Int, maxTimeMinutes: IntValueByMealTime, minServingWeight: Int, repeat: DateTime, snackDistribution: Float, startDate: Date, variety: MPVariety): GenerateMealPlan
  generateShopifyMultipassUrl(input: GenerateShopifyMultipassUrlInput): GenerateShopifyMultipassUrl
  generateSimpleMealPlan(addDays: Boolean, appendDays: Int = 7, boostAdherence: Boolean, filters: SimpleMPFiltersInput, format: [MealTime!], ignoreLock: Boolean, isAppend: Boolean = false, repeat: DateTime, variety: MPVariety): GenerateSimpleMealPlan
  generateVideoZoomToken(input: GenerateVideoZoomTokenInput!): GenerateVideoZoomTokenPayload
  linkUserAssessment(input: LinkUserAssessmentInput!): LinkUserAssessment
  login(userId: String!): LoginUser
  markContentAsReadOrUnread(input: MarkContentAsReadOrUnreadInput!): MarkContentAsReadOrUnread
  mergeUser(input: MergeUserInput!): MergeUser
  newUserAssessments(input: NewUserAssessmentsInput!): NewUserAssessments
  processAppleReceipt(input: ProcessAppleReceiptInput!): ProcessAppleReceipt
  profileMacroGoalsSettings(activityLevel: ActivityLevel!, biologicalSex: BiologicalSex!, birthdate: Date!, goalsOn: Boolean!, height: Float!, isImperial: Boolean, startingWeight: Float!, targetWeight: Float!, weeklyWeightGoal: WeeklyWeightGoal!): ProfileMacroGoalsSettings
  profileMealPlanSettings(calories: Int!, carbsPerc: Float!, error: Float!, fatPerc: Float!, format: [MealTime], omega3Perc: Float, proteinPerc: Float!): ProfileMealPlanSettings @deprecated(reason: "This doesn't allow doing settings reset. Use updateMealPlanSettings instead.")
  profileRestrictionsUpdate(replace: Boolean, restrictions: [ID]): ProfileRestrictionsUpdate
  publishEvent(appVersion: String!, client: String!, eventType: EventType!, location: GenericScalar, timezone: String!): PublishEvent
  purchaseMealRecipe(externalId: String, profileId: String!, recipeId: ID!): PurchaseMealRecipe
  reassignChatConversation(input: ReassignChatConversationInput!): ReassignChatConversation
  removeCoachChatConversation(input: RemoveCoachChatConversationInput!): RemoveCoachChatConversation
  removeFavoriteArticle(articleId: ID!): RemoveFavoriteArticle
  removeFromShoppingList(recipeId: String!): RemoveFromShoppingList
  removeMealLog(databaseId: String!): RemoveMealLogMutation
  removeMealPlan: RemoveMealPlan
  removeMealPlanRecipe(mealId: ID!): RemoveMealPlanRecipe
  removeOwnMeal(databaseId: String!): RemoveOwnMeal
  removeUserConsent(consentType: ID!): RemoveUserConsent
  removeUserFromJourney(input: RemoveUserFromJourneyInput!): RemoveUserFromJourney
  requestAccountDeletion: RequestAccountDeletion
  requestResetPassword(email: String!): RequestResetPassword
  requestUserDataDownload: RequestUserDataDownload
  resendAppointmentConfirmationEmail(appointment: ID!, profile: ID): ResendAppointmentConfirmationEmail
  resetPassword(code: String!, newPassword: String!): ResetPassword
  saveZoomSessionForAppointment(input: SaveZoomSessionForAppointmentInput!): SaveZoomSessionForAppointment
  selectDailyRecapQuestions(questions: [ID!]!): SelectDailyRecapQuestions!
  sendFeedback(message: String!, subject: String!): SendFeedback
  sensitiveProfileAttributes(attributes: String, signingPublicKey: String): SensitiveProfileAttributes
  setActiveSource(source: SourceType!): SetActiveSource
  setMealPlanToTemplate(profileId: ID!, templateId: ID!): SetMealPlanToTemplate
  setThirdPartyAppUserAsTest(input: SetThirdPartyAppUserAsTestInput!): SetThirdPartyAppUserAsTest
  setUserAnswers(input: SetUserAnswersInput!): SetUserAnswers
  startChatConversation(input: StartChatConversationInput!): StartChatConversationPayload
  startJourneys(daysUnlocked: Int, override: Boolean): StartJourneys
  startOverMealPlan: StartOverMealPlan
  storeConversationSummary(input: StoreConversationSummaryInput!): StoreConversationSummary
  swapMealPlanRecipe(mealId: String, mealTag: MealTime, recipeId: String!, serving: Int): SwapMealPlanRecipe
  toggleShoppingListItem(isAggregate: Boolean!, itemId: String!): ToggleShoppingListItem
  toggleShoppingListItems(isAggregate: Boolean!, itemIds: [String!]!): ToggleShoppingListItems
  toggleTaskCompleted(keysHash: String!): ToggleTaskCompleted

  """uncheckIntake is the opposite of checkIntake. It undoes the check"""
  uncheckIntake(category: IntakeCategory!, date: Date!, itemId: ID!, timeOfDay: TimeOfDay): UncheckIntake!
  uncheckTodayFood(date: Date!, itemId: ID!): UncheckTodayFood @deprecated(reason: "No longer supported. Use uncheckIntake instead")
  uncheckTodaySupplement(date: Date!, itemId: ID!): UncheckTodaySupplement @deprecated(reason: "No longer supported. Use uncheckIntake instead")
  unlinkUserAssessment(input: LinkUserAssessmentInput!): UnlinkUserAssessment
  updateAnswer(input: UpdateAnswerInput!): UpdateAnswer
  updateAppointment(input: UpdateAppointmentInput!): UpdateAppointment
  updateAppointmentCredits(appointmentType: ID!, decrease: Int, increase: Int, labTestReports: [ID], profile: ID!, value: Int): UpdateAppointmentCredits
  updateArticleRecommended(input: UpdateArticleRecommendedInput!): UpdateArticleRecommended
  updateAssessment(input: UpdateAssessmentInput!): UpdateAssessment
  updateAssistant(input: UpdateAssistantInput!): UpdateAssistant
  updateBiomarker(input: UpdateBiomarkerInput!): UpdateBiomarker
  updateBiomarkerCategory(input: UpdateBiomarkerCategoryInput!): UpdateBiomarkerCategory
  updateBloodPressureLog(diastolicValue: PositiveInt, id: ID!, systolicValue: PositiveInt): UpdateBloodPressureLog!
  updateCoachTeam(input: UpdateCoachTeamInput!): UpdateCoachTeam
  updateCoachType(input: UpdateCoachTypeInput!): UpdateCoachType
  updateContentCategory(input: UpdateContentCategoryInput!): UpdateContentCategory
  updateContentLibrary(input: UpdateContentLibraryInput!): UpdateContentLibrary
  updateContentTag(id: ID!, name: String!): UpdateContentTag
  updateDailyRecapAnswer(input: UpdateDailyRecapAnswerInput!): UpdateDailyRecapAnswer
  updateDailyRecapQuestion(input: UpdateDailyRecapQuestionInput!): UpdateDailyRecapQuestion
  updateDietPreference(input: UpdateDietPreferenceInput!): UpdateDietPreference
  updateDynamicQuestion(input: UpdateDynamicQuestionInput!): UpdateDynamicQuestion
  updateExpressTrack(calories: Float, carbs: Float, datetime: DateTime, fats: Float, id: ID!, mealTime: MealTime, proteins: Float): UpdateExpressTrack!
  updateGuardrail(input: UpdateGuardrailInput!): UpdateGuardrail
  updateHydration(action: ActionType!, date: Date!, source: SourceType): UpdateHydration
  updateInteraction(deliveryTime: Time!, goal: String!, id: ID!, interaction: String!, order: Int!): UpdateInteraction
  updateJourney(input: UpdateJourneyInput!): UpdateJourney
  updateJourneyStatus(journeyId: String!, status: JourneyStatus!): UpdateJourneyStatus
  updateLabTestReport(alert: Boolean, alertAction: AlertAction, alertStatus: AlertStatus, alertText: String, description: String, externalId: String, id: ID!, image: Upload, imageUrl: String, isVisible: Boolean, labName: String, orderId: String, orderingPhysician: String, productId: String, reportPdf: Upload, requisitionId: String, sampleCollectionDate: Date, status: LabTestReportStatus, testDate: DateTime, testName: String, title: String, userEmail: String, videoUrl: String): UpdateLabTestReport
  updateMealLog(customServingEquivalent: Float, databaseId: String!, date: Date, mealTime: MealTime, quantity: Float, serving: Float, time: Time): UpdateMealLogMutation
  updateMealPlanSettings(overwrite: UpdateMPSettingsInput, update: UpdateMPSettingsInput): UpdateMealPlanSettings
  updateMealPlanTemplate(coach: ID, coachTypes: [ID!], description: String, id: ID!, isPublic: Boolean, mealPlanDays: MPTFromScratchInput, name: String): UpdateMealPlanTemplate
  updateMyBrandedFood(id: ID!, input: UpdateMyBrandedFoodInput!): UpdateMyBrandedFood
  updateMyChecklistItem(directionsOfUse: [ItemDirectionsOfUseInput!], header: String, id: ID!, tags: [String!], text: String): UpdateMyChecklistItem
  updateMyCommonFood(id: ID!, input: UpdateMyCommonFoodInput!): UpdateMyCommonFood
  updateMyRecipe(id: ID!, input: UpdateMyRecipeInput!): UpdateMyRecipe
  updateNote(coach: ID, noteId: ID!, text: String, title: String): UpdateNote
  updateOwnMeal(barcode: String, brand: String, databaseId: String!, date: Date, mealTime: MealTime, mealType: MealType, name: String, ownNutrients: OwnNutrients!, ownServing: OwnServing!): UpdateOwnMealMutation
  updateOwnRecipe(databaseId: String!, ingredients: [OwnRecipeIngredient], quantity: Float, recipeName: String): UpdateOwnRecipe
  updateProfile(birthdate: Date, country: String, currentSource: SourceType, dietPreferences: [ID!], email: String, favoriteCuisines: [String!], hasOnboarded: Boolean, isImperial: Boolean, language: Language, mpDiversity: MealPlanDiversity, name: String, operationDietPreferences: Operation, phone: String, preferredCommunicationChannel: CommunicationChannel, thryveAuthenticationToken: String, timezone: String): UpdateProfile
  updateProfileBiomarkers(cholesterolLdl: Float, cortisol: Float, ferritin: Float, hba1c: Float, totalCholesterol: Float, vitaminB12: Float, vitaminD: Float): UpdateProfileBiomarkers
  updateProtocol(input: UpdateProtocolInput!): UpdateProtocol
  updateQuestion(input: UpdateQuestionInput!): UpdateQuestion
  updateShoppingListRecipeServings(numberOfServings: Int!, recipeId: String!): UpdateShoppingListRecipeServings
  updateSubscription(profileId: String, subscriptionId: String!, userId: String): UpdateSubscription
  updateSupplement(input: UpdateSupplementInput!): UpdateSupplement
  updateSupplementPlan(input: UpdateSPInput!): UpdateSupplementPlan
  updateSupplementRecommended(input: UpdateSupplementRecommendedInput!): UpdateSupplementRecommended
  updateThirdPartyGoal(input: UpdateThirdPartyGoalInput!): UpdateThirdPartyGoal
  updateThirdPartyTrackerComponent(input: UpdateThirdPartyTrackerComponentInput!): UpdateThirdPartyTrackerComponent
  updateUserAssessmentScore(input: UpdateUserAssessmentScoreInput!): UpdateUserAssessmentScore
  updateUserProgram(programId: String!): UpdateUserProgram
  updateUserProgress(input: UpdateUserProgressInput!): UpdateUserProgress
  userFavoriteMenuitem(menuitemId: String!): UserFavoriteMenuItem
  userFavoriteRecipe(recipeId: String!): UserFavoriteRecipe
  userFavoriteRestaurant(restaurantId: String!): UserFavoriteRestaurant
}

type MyBrandedFood implements Node {
  brandName: String
  brandOwner: String!
  brandedFoodCategory: String
  calories: Float
  dataType: String
  description: String
  foodDataId: String
  gtinUpc: String!
  householdServingFulltext: String
  id: ID!
  isActive: Boolean!
  isCore: Boolean!
  isGeneric: Boolean!
  name: String!
  nutrients: [Nutrient!]!
  profileId: String!
  servingSize: Float!
  servingSizeUnit: String!
  tags: [String!]!
}

type MyBrandedFoodConnection {
  count: Int!
  edges: [MyBrandedFoodEdge]!
  pageInfo: PageInfo!
}

type MyBrandedFoodEdge {
  cursor: String!
  node: MyBrandedFood
}

type MyBrandedFoodProxy {
  myBrandedFood: MyBrandedFood!
}

type MyChecklistItem implements Node {
  createdAt: DateTime!
  directionsOfUse: [CheckItemDirections!]
  header: String!
  id: ID!
  tags: [String!]!
  text: String
  updatedAt: DateTime!
}

type MyChecklistItemConnection {
  edges: [MyChecklistItemEdge]!
  pageInfo: PageInfo!
}

type MyChecklistItemEdge {
  cursor: String!
  node: MyChecklistItem
}

type MyChecklistItemOnPlan {
  checked: Boolean!
  myChecklistItem: MyChecklistItem!
  timeOfDay: TimeOfDay
}

type MyChecklistLog {
  id: ID!
  myChecklistItem: MyChecklistItem!
  myChecklistItemId: ID!
  timeOfDay: TimeOfDay!
}

type MyChecklistLogs {
  dates: [MyChecklistLogsDay!]!
}

type MyChecklistLogsDay {
  date: Date!
  logs: [MyChecklistLog!]!
}

type MyCommonFood implements Node {
  dataType: String
  description: String
  foodDataId: String
  id: ID!
  isActive: Boolean!
  isCore: Boolean!
  isGeneric: Boolean!
  name: String!
  nutrients: [Nutrient!]!
  portions: [Portion]
  profileId: String!
  tags: [String!]!
}

type MyCommonFoodConnection {
  count: Int!
  edges: [MyCommonFoodEdge]!
  pageInfo: PageInfo!
}

type MyCommonFoodEdge {
  cursor: String!
  node: MyCommonFood
}

type MyCommonFoodProxy {
  myCommonFoodProxy: MyCommonFood!
}

type NewUserAssessments {
  assessments(after: String, before: String, first: Int, last: Int, offset: Int): AssessmentConnection
  externalId: String
  message: String!
  success: Boolean!
  userId: String
}

input NewUserAssessmentsInput {
  assessment: ID
  email: String!
  externalId: String
}

interface Node {
  id: ID!
}

type Note implements Node {
  createdAt: DateTime!
  createdBy: Coach
  id: ID!
  text: String
  title: String!
  updatedAt: DateTime!
  updatedBy: Coach
}

type NoteConnection {
  edges: [NoteEdge]!
  pageInfo: PageInfo!
}

type NoteEdge {
  cursor: String!
  node: Note
}

type Nutrient {
  amount: Float
  id: Int
  name: String
  type: NutrientEnum!
  unit: String
}

type NutrientAggregationsByFoodLog {
  alphaLinolenicacid: NutrientGoalComparison
  biotin: NutrientGoalComparison
  calcium: NutrientGoalComparison
  chloride: NutrientGoalComparison
  chocdf: NutrientGoalComparison
  choline: NutrientGoalComparison
  chromium: NutrientGoalComparison
  copper: NutrientGoalComparison
  fat: NutrientGoalComparison
  fluoride: NutrientGoalComparison
  folate: NutrientGoalComparison
  iodine: NutrientGoalComparison
  iron: NutrientGoalComparison
  linoleicacid: NutrientGoalComparison
  magnesium: NutrientGoalComparison
  manganese: NutrientGoalComparison
  molybdenum: NutrientGoalComparison
  netcarbs: NutrientGoalComparison
  niacin: NutrientGoalComparison
  pantothenicacid: NutrientGoalComparison
  phosphorus: NutrientGoalComparison
  potassium: NutrientGoalComparison
  procnt: NutrientGoalComparison
  riboflavin: NutrientGoalComparison
  selenium: NutrientGoalComparison
  sodium: NutrientGoalComparison
  thiamin: NutrientGoalComparison
  totalfiber: NutrientGoalComparison
  vitamina: NutrientGoalComparison
  vitaminb6: NutrientGoalComparison
  vitaminb12: NutrientGoalComparison
  vitaminc: NutrientGoalComparison
  vitamind: NutrientGoalComparison
  vitamine: NutrientGoalComparison
  vitamink: NutrientGoalComparison
  zinc: NutrientGoalComparison
}

enum NutrientEnum {
  ACETIC_ACID
  ALANINE
  ALCOHOL_ETHYL
  ARGININE
  ASH
  ASPARTIC_ACID
  BETAINE
  BETA_SITOSTANOL
  BETA_SITOSTEROL
  BIOTIN
  BORON_B
  BRASSICASTEROL
  CAFFEINE
  CALCIUM_CA
  CAMPESTANOL
  CAMPESTEROL
  CARBOHYDRATE_BY_SUMMATION
  CARBOHYDRATE_OTHER
  CARBS
  CAROTENE_ALPHA
  CAROTENE_BETA
  CHLORINE_CL
  CHOLESTEROL
  CHOLINE_FREE
  CHOLINE_FROM_GLYCEROPHOSPHOCHOLINE
  CHOLINE_FROM_PHOSPHOCHOLINE
  CHOLINE_FROM_PHOSPHOTIDYL_CHOLINE
  CHOLINE_FROM_SPHINGOMYELIN
  CHOLINE_TOTAL
  CHROMIUM_CR
  CIS_BETA_CAROTENE
  CIS_LUTEIN_ZEAXANTHIN
  CIS_LYCOPENE
  COBALT_CO
  COPPER_CU
  CRYPTOXANTHIN_ALPHA
  CRYPTOXANTHIN_BETA
  CYSTEINE
  CYSTINE
  DELTA_5_AVENASTEROL
  DHA
  DPA
  ENERGY
  EPA
  EPIGALLOCATECHIN_3_GALLATE
  FAT
  FATTY_ACIDS_TOTAL_MONOUNSATURATED
  FATTY_ACIDS_TOTAL_POLYUNSATURATED
  FATTY_ACIDS_TOTAL_SATURATED
  FATTY_ACIDS_TOTAL_TRANS
  FATTY_ACIDS_TOTAL_TRANS_DIENOIC
  FATTY_ACIDS_TOTAL_TRANS_MONOENOIC
  FATTY_ACIDS_TOTAL_TRANS_POLYENOIC
  FIBER_INSOLUBLE
  FIBER_SOLUBLE
  FIBER_TOTAL_DIETARY
  FLUORIDE_F
  FOLATE_DFE
  FOLATE_FOOD
  FOLATE_TOTAL
  FOLIC_ACID
  FRUCTOSE
  GALACTOSE
  GLUCOSE_DEXTROSE
  GLUTAMIC_ACID
  GLUTAMINE
  GLYCINE
  HISTIDINE
  HYDROXYPROLINE
  INOSITOL
  INULIN
  IODINE_I
  IRON_FE
  ISOLEUCINE
  LACTIC_ACID
  LACTOSE
  LEUCINE
  LUTEIN
  LUTEIN_ZEAXANTHIN
  LYCOPENE
  LYSINE
  MAGNESIUM
  MALTOSE
  MANGANESE_MN
  METHIONINE
  MOLYBDENUM_MO
  NIACIN
  NICKEL_NI
  O5_FORMYLTETRAHYDROFOLIC_ACID_5_HCOH4
  O5_METHYL_TETRAHYDROFOLATE_5_MTHF
  O10_FORMYL_FOLIC_ACID_10HCOFA
  O25_HYDROXYCHOLECALCIFEROL
  PANTOTHENIC_ACID
  PHENYLALANINE
  PHOSPHORUS_P
  PHYTOENE
  PHYTOFLUENE
  PHYTOSTEROLS
  PHYTOSTEROLS_OTHER
  POTASSIUM_K
  PROLINE
  PROTEIN
  RETINOL
  RIBOFLAVIN
  RIBOSE
  SELENIUM_SE
  SERINE
  SODIUM_NA
  SORBITOL
  SPECIFIC_GRAVITY_SP
  STARCH
  STIGMASTEROL
  SUCROSE
  SUGARS_ADDED
  SUGARS_TOTAL_INCLUDING_NLEA
  SUGARS_TOTAL_NLEA
  SULFUR_S
  TAURINE
  THEOBROMINE
  THIAMIN
  THREONINE
  TOCOPHEROL_BETA
  TOCOPHEROL_DELTA
  TOCOPHEROL_GAMMA
  TOCOTRIENOL_ALPHA
  TOCOTRIENOL_BETA
  TOCOTRIENOL_DELTA
  TOCOTRIENOL_GAMMA
  TOTAL_FAT_NLEA
  TOTAL_SUGAR_ALCOHOLS
  TRANS_BETA_CAROTENE
  TRANS_LYCOPENE
  TRYPTOPHAN
  TYROSINE
  VALINE
  VITAMIN_A_IU
  VITAMIN_A_RAE
  VITAMIN_B_6
  VITAMIN_B_12
  VITAMIN_B_12_ADDED
  VITAMIN_C_TOTAL_ASCORBIC_ACID
  VITAMIN_D2_ERGOCALCIFEROL
  VITAMIN_D3_CHOLECALCIFEROL
  VITAMIN_D_D2_D3
  VITAMIN_D_D2_D3_INTERNATIONAL_UNITS
  VITAMIN_E
  VITAMIN_E_ADDED
  VITAMIN_E_ALPHA_TOCOPHEROL
  VITAMIN_E_LABEL_ENTRY_PRIMARILY
  VITAMIN_K_DIHYDROPHYLLOQUINONE
  VITAMIN_K_MENAQUINONE_4
  VITAMIN_K_PHYLLOQUINONE
  WATER
  XYLITOL
  ZEAXANTHIN
  ZINC_ZN
}

input NutrientFilterInput {
  nutrient: NutrientEnum!
  range: RangeFilter
}

type NutrientGoalComparison {
  goal: Float
  value: Float
}

input NutrientInput {
  amount: Float!
  nutrient: NutrientEnum!
  unit: String!
}

type Nutrients {
  chocdf: Float
  fat: Float
  fibtg: Float
  netcarbs: Float
  procnt: Float
  sugar: Float
}

type NutrientsFull {
  ca: Float
  chole: Float
  cholesterol: Float
  enercKcal: Float
  energy: Float
  fams: Float
  fapu: Float
  fasat: Float
  fatrn: Float
  fe: Float
  fiber: Float
  k: Float
  na: Float
  potassiumK: Float
  saturatedFat: Float
  sodiumNa: Float
  transFats: Float
  vitaIu: Float
  vitc: Float
}

type NutrientsPerServing {
  ala: Float
  calcium: Float
  calories: Float
  carbs: Float
  cholesterol: Float
  choline: Float
  copper: Float
  dha: Float
  dpa: Float
  epa: Float
  fat: Float
  fiber: Float
  iodine: Float
  iron: Float
  magnesium: Float
  manganese: Float
  molybdenum: Float
  monounsaturatedFat: Float
  netcarbs: Float
  omega3: Float
  phosphorus: Float
  polyunsaturatedFat: Float
  potassium: Float
  protein: Float
  saturatedFat: Float
  selenium: Float
  sodium: Float
  sugar: Float
  transFat: Float
  vitaminA: Float
  vitaminB1: Float
  vitaminB2: Float
  vitaminB3: Float
  vitaminB5: Float
  vitaminB6: Float
  vitaminB7: Float
  vitaminB9: Float
  vitaminB12: Float
  vitaminC: Float
  vitaminD: Float
  vitaminE: Float
  vitaminK: Float
  zinc: Float
}

type NutritionalInfo {
  ala: Float
  calcium: Float
  calories: Float
  carbs: Float
  cholesterol: Float
  choline: Float
  copper: Float
  dha: Float
  dpa: Float
  epa: Float
  fat: Float
  fiber: Float
  iodine: Float
  iron: Float
  magnesium: Float
  manganese: Float
  molybdenum: Float
  monounsaturatedFat: Float
  netcarbs: Float
  omega3: Float
  phosphorus: Float
  polyunsaturatedFat: Float
  potassium: Float
  protein: Float
  saturatedFat: Float
  selenium: Float
  sodium: Float
  sugar: Float
  transFat: Float
  vitaminA: Float
  vitaminB1: Float
  vitaminB2: Float
  vitaminB3: Float
  vitaminB5: Float
  vitaminB6: Float
  vitaminB7: Float
  vitaminB9: Float
  vitaminB12: Float
  vitaminC: Float
  vitaminD: Float
  vitaminE: Float
  vitaminK: Float
  zinc: Float
}

type NutritionEstimates {
  calories: Float
  carbs: Float
  fat: Float
  protein: Float
}

enum Operation {
  ADD
  REMOVE
  REPLACE
}

type OutoCompleteConnection {
  edges: [OutoCompleteEdge]!
  pageInfo: PageInfo!
}

type OutoCompleteEdge {
  cursor: String!
  node: Suggestion
}

input OwnNutrients {
  ca: Float
  chocdf: Float!
  chole: Float
  enercKcal: Float
  fams: Float
  fapu: Float
  fasat: Float
  fat: Float!
  fatrn: Float
  fe: Float
  fibtg: Float
  k: Float
  na: Float
  procnt: Float!
  sugar: Float
  vitaIu: Float
  vitc: Float
}

input OwnRecipeIngredient {
  id: String!
  mealType: MealType!
  quantity: Float!
  serving: Int!
}

input OwnServing {
  equivalent: Float!
  name: String!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Portion {
  amount: Float
  gramWeight: Float
  modifier: String
  modifierDescription: String
  mostCommon: Boolean
  portionWeight: Float
  seqNum: Int
  unit: String
  unitDescription: String
}

input PortionInput {
  amount: Float!
  gramWeight: Float!
  modifier: String
  unit: String!
}

scalar PositiveFloat

scalar PositiveInt

enum PostEventStatus {
  CANCELED_BY_ADMIN
  CANCELED_BY_COACH
  CANCELED_BY_MEMBER
  COACH_NO_SHOW
  COMPLETED
  MEMBER_NO_SHOW
  RESCHEDULED_BY_ADMIN
  RESCHEDULED_BY_COACH
  RESCHEDULED_BY_MEMBER
  SCHEDULED
}

enum PriceRate {
  RATE_0
  RATE_1
  RATE_2
  RATE_3
  RATE_4
}

type ProcessAppleReceipt {
  message: String!
  success: Boolean!
}

input ProcessAppleReceiptInput {
  isInitial: Boolean
  receiptData: String!
}

type ProductOption {
  name: String!
  values: [String!]
}

type ProductType implements Node {
  createdAt: DateTime
  id: ID!
  isActive: Boolean!
  name: String!
  programs(after: String, before: String, first: Int, isActive: Boolean, isPremium: Boolean, last: Int, offset: Int): ProgramConnection!
  updatedAt: DateTime
}

type ProductTypeConnection {
  edges: [ProductTypeEdge]!
  pageInfo: PageInfo!
}

type ProductTypeEdge {
  cursor: String!
  node: ProductType
}

type ProductVariant {
  availableForSale: Boolean!
  id: ID!
  price: Money!
  title: String!
}

type ProfileBiomarker implements Node {
  alert: Boolean
  alertText: String
  biomarker: Biomarker!
  biomarkerUnit: BiomarkerUnit
  createdAt: DateTime!
  date: DateTime!
  displayValue: String
  id: ID!
  labTestReport: LabTestReport!
  stringValue: JSONString! @deprecated(reason: "Use value instead")
  updatedAt: DateTime!
  value: GenericScalar!
}

type ProfileBiomarkerConnection {
  edges: [ProfileBiomarkerEdge]!
  pageInfo: PageInfo!
}

type ProfileBiomarkerEdge {
  cursor: String!
  node: ProfileBiomarker
}

type ProfileBiomarkerResult {
  articles(after: String, before: String, first: Int, last: Int, offset: Int): ContentLibraryTypeConnection
  biomarker: Biomarker!
  results(after: String, before: String, end: Date, first: Int, last: Int, offset: Int, start: Date): ProfileBiomarkerConnection
  supplements(after: String, before: String, first: Int, last: Int, offset: Int): SupplementConnection
}

type ProfileBiomarkers {
  cholesterolLdl: Float
  cortisol: Float
  createdAt: DateTime!
  ferritin: Float
  hba1c: Float
  profile: ProfileType!
  totalCholesterol: Float
  updatedAt: DateTime!
  vitaminB12: Float
  vitaminD: Float
}

input ProfileCustomAttribute {
  category: String
  dataType: AttrDataType!
  name: String!
  timestamp: Float
  value: GenericScalar!
}

enum ProfileField {
  ACTIVITY_LEVEL
  BIOLOGICAL_SEX
  BIRTHDATE
  CUSTOM_ATTRIBUTES
  FAVORITE_CUISINES
  HEIGHT
  IS_IMPERIAL
  MALNUTRITION_RISK
  PHONE
  PROGRAM
  RESTRICTIONS
  STARTING_WEIGHT
  TARGET_WEIGHT
  TUBE_FEEDING_ORAL_INTAKE
  WEEKLY_WEIGHT_GOAL
}

type ProfileMacroGoalsSettings {
  bmi: Int
  bmr: Int
  cd: Int
  dcig: Int
  profile: ProfileType
  success: Boolean
  tdee: Int
}

type ProfileMealPlanSettings {
  success: Boolean
}

enum ProfileMpDiversity {
  HIGH
  LOW
  MEDIUM
}

type ProfileRecommendationType {
  createdAt: DateTime
  databaseId: String
  id: UUID!
  profile: ProfileType!
  recommendation: RecommendationCatalogType
  updatedAt: DateTime
}

type ProfileRestrictionsUpdate {
  message: String!
  restrictions: [ID!]
  success: Boolean!
}

input ProfileTest {
  activityLevel: ActivityLevel
  age: Int!
  biologicalSex: BiologicalSex!
  goalWeight: Float
  height: Float
  name: String!
  steps: Int
  weight: Float
}

type ProfileType {
  activityLevel: ActivityLevel
  adherenceScore: Float!
  age: Int
  appVersion: String!
  basalMetabolicRate: Int
  biologicalSex: BiologicalSex
  biomarkers: ProfileBiomarkers
  birthdate: Date
  bloodPressureDiastolic: Float
  bloodPressureSystolic: Float
  bodyMassIndex: Float
  caloricDifference: Int
  country: String
  cpcs: [UUID!]!
  createdAt: DateTime
  currentSource: SourceType
  customAttributes: JSONString
  dailyCaloricIntakeGoal: Int
  debugMealPlanVariables: DebugMealPlanVariables!
  dietPreferences: [DietPreference!]!
  email: String!
  encodedAttributes: String
  externalId: String
  extraData: JSONString
  favoriteCuisines: [String!]
  gender: String
  glucoseLevel: Float
  goal: UUID
  goals: [String!]!
  goalsOn: Boolean!
  hasNotifications: Boolean
  hasOnboarded: Boolean!
  height: Float
  id: UUID!
  isImperial: Boolean!
  isPremium: Boolean
  journeyStarted: Boolean
  language: String!
  lat: String
  lon: String
  malnutritionRisk: Boolean!
  mealPlan(fromDate: Date): [MealPlanDay!]!
  mpCalories: Int
  mpCarbsPerc: Float
  mpDays: Int
  mpDiversity: ProfileMpDiversity
  mpError: Float
  mpFatPerc: Float
  mpFormat: [String!]!
  mpMonounsaturatedFatPerc: Float
  mpOmega3Perc: Float
  mpPolyunsaturatedFatPerc: Float
  mpProteinPerc: Float
  mpSaturatedFatPerc: Float
  mpTransFatPerc: Float
  phone: String
  preferredCommunicationChannel: CommunicationChannel!
  program: Program
  programName: String
  restrictions: [Restriction]
  sendbirdAccessToken: String!
  sendbirdId: String!
  startingWeight: Float
  subscription: SubscriptionType
  tags: [String!]
  targetWeight: Float
  thryvePartnerId: String!
  timezone: String!
  totalDailyEnergyExpenditure: Int
  tubeFeedingOralIntake: Int
  updatedAt: DateTime
  userId: String
  weeklyWeightGoal: WeeklyWeightGoal
  weight: Float
}

type Program implements Node {
  assistantSet: [Assistant!]!
  author: String
  authorAvatar: String
  authors: [UUID!]
  backgroundImage: String
  books: JSONString
  comment: String!
  contentlibrarySet(after: String, before: String, first: Int, last: Int, offset: Int): ContentLibraryTypeConnection!
  cover: String
  cpcsIngredientGroups: CPCIngredientGroup
  cpcsRecipeTags: CPCRule
  createdAt: DateTime!
  databaseId: String
  defaultVideoThumnail: String
  descriptionLong: String
  descriptionShort: String
  energyNutrientEquation: ProgramEnergyNutrientEquation!
  id: ID!
  image: String
  isActive: Boolean!
  isPremium: Boolean!
  name: String!
  order: Int!
  productSet(after: String, before: String, first: Int, last: Int, offset: Int): ProductTypeConnection!
  restrictions(encoded: Boolean): [String!]!
  showDefaultGoals: Boolean!
  slug: String
  subscriptionSet(after: String, before: String, first: Int, last: Int, offset: Int): SubscriptionTypeConnection!
  tags: [String!]!
  thirdpartydailyrecapquestionSet(after: String, before: String, first: Int, last: Int, offset: Int): ThirdPartyDailyRecapQuestionConnection!
  transactionSet(after: String, before: String, first: Int, last: Int, offset: Int): SubscriptionTransactionConnection!
  videoUrl: String
  visibility: Boolean!
}

type ProgramConnection {
  edges: [ProgramEdge]!
  pageInfo: PageInfo!
}

type ProgramEdge {
  cursor: String!
  node: Program
}

enum ProgramEnergyNutrientEquation {
  HARRIS_BENEDICT
  ONCOLOGY
}

input ProgramFiltersInput {
  hasSubscription: Boolean = false
}

input ProgramOrderBy {
  field: ProgramOrderByField = created_at
  order: SortOrder = ASC
}

enum ProgramOrderByField {
  author
  created_at
  name
}

type Protocol implements Node {
  bundle: Supplement
  createdAt: DateTime!
  group: ProtocolGroup!
  id: ID!
  isActive: Boolean!
  isPublic: Boolean!
  length: Int!
  name: String!
  owner: Coach
  program: Program
  supplementProtocols: [SupplementProtocol!]
  updatedAt: DateTime!
}

type ProtocolConnection {
  edges: [ProtocolEdge]!
  pageInfo: PageInfo!
}

type ProtocolEdge {
  cursor: String!
  node: Protocol
}

enum ProtocolGroup {
  PROTOCOL
  SINGLE_SUPPLEMENT
}

type PublishEvent {
  message: String
  success: Boolean
}

type PurchaseMealRecipe {
  message: String
  success: Boolean
}

type Query {
  allUsersAnswersByAssessment(after: String, assessmentId: ID!, before: String, first: Int, last: Int, offset: Int, orderBy: UserAnswerOrderByInput): UserAnswerConnection
  answer(id: ID!): AssessmentAnswer
  answers(after: String, before: String, filters: AnswersFilterInput, first: Int, last: Int, offset: Int): AssessmentAnswerConnection
  appUserActivities(after: String, before: String, coachId: ID!, end: DateTime, filters: AppUserActivityLogFiltersInput, first: Int, last: Int, offset: Int, start: DateTime): ActivityLogConnection
  appointmentCredits: AppointmentCredits!
  appointmentTypes(after: String, before: String, first: Int, last: Int, offset: Int): AppointmentTypeConnection
  articlesRecommended(after: String, before: String, first: Int, id: ID, last: Int, offset: Int): ArticleRecommendedConnection
  assessment(id: ID!): Assessment
  assessments(after: String, before: String, filters: AssessmentsFilterInput, first: Int, last: Int, offset: Int): AssessmentConnection
  assistantAnalytics(assistant: ID!, filters: AssistantAnalyticFiltersInput): AssistantAnalytics
  assistants(filters: AssistantFiltersInput): [Assistant!]
  autocomplete(after: String, before: String, enter: Boolean, first: Int, last: Int, mealType: MealType, mealTypes: [MealType], query: String): OutoCompleteConnection
  barcodeSearch(barcode: String!): FoodProduct
  biomarkerCatalog(after: String, before: String, filters: BiomarkerFilterInput, first: Int, id: ID, last: Int): BiomarkerConnection
  biomarkerCategories(after: String, before: String, filters: BiomarkerCategoryFilterInput, first: Int, id: ID, last: Int, offset: Int, orderBy: BiomarkerCategoryOrderBy, parentId: ID): BiomarkerCategoryConnection
  biomarkerResults(filters: BiomarkerResultsFilterInput): [ProfileBiomarker!]
  biomarkerUnits(after: String, before: String, first: Int, id: ID, last: Int, offset: Int): BiomarkerUnitConnection
  biomarkers(after: String, before: String, filters: BiomarkerFilterInput, first: Int, id: ID, last: Int): BiomarkerConnection
  bloodPressureLogs(after: String, end: DateTime!, first: Int, id: ID, source: SourceType, start: DateTime!): BloodPressureLogsConnnection!
  brandedFoods(after: String, barcode: String, before: String, filter: FoodFilter, first: Int, last: Int, query: String): BrandedFoodConnection
  checkedIntakes(category: IntakeCategory!, end: Date!, start: Date!): DailyChecklist @deprecated(reason: "No longer supported. Use intakesChecklist instead. This query doesn't support supplements on plan")
  coachAvailability(appointmentType: ID!, coaches: [ID!], end: DateTime!, start: DateTime!): [TimePeriod!]!
  coachTeams(after: String, before: String, filters: CoachTeamsFilterInput, first: Int, id: ID, last: Int, offset: Int): CoachTeamConnection
  coachTypes(after: String, before: String, filters: CoachTypesFilterInput, first: Int, id: ID, last: Int, offset: Int): CoachTypeConnection
  commonFoods(after: String, before: String, filter: FoodFilter, first: Int, last: Int, query: String): CommonFoodAPIConnection
  consentTypes(name: String): [ConsentType!]
  constraints(after: String, before: String, filters: ConstraintFilters, first: Int, last: Int): ConstraintConnection
  contentCategories(after: String, before: String, first: Int, id: ID, last: Int, offset: Int, tags: [String!]): ContentCategoryTypeConnection
  contentLibrary(after: String, before: String, categories: [ID], enablePersonalizedContent: Boolean = false, first: Int, id: ID, isRead: Boolean, last: Int, offset: Int, order: ContentLibraryOrderBy, search: String, tags: [String!]): ContentLibraryTypeConnection
  contentTags(after: String, before: String, first: Int, last: Int, name: String, offset: Int): ContentTagTypeConnection
  conversationSummary: ConversationSummary!
  countries: [GenericScalar]
  cuisines(after: String, before: String, first: Int, last: Int, name: String): CuisineConnection
  currentJourneys(after: String, before: String, first: Int, id: UUID, journeyId: ID, last: Int, offset: Int): JourneyProfileTypeConnection
  customMealPlan(breakfastDistribution: Float, calories: Int!, carbs: Float, days: Int, dinnerDistribution: Float, error: Float, fat: Float, format: [MealTime]!, lunchDistribution: Float, maxIngredientsCount: IntValueByMealTime, maxTimeMinutes: IntValueByMealTime, omega3: Float, program: ID, protein: Float, skipRecipes: [ID!], snackDistribution: Float): [MealPlanDay]
  dailyMoodSummary(endDate: Date!, startDate: Date!): DailyMoodSummary!
  dailyRecap(date: Date!, group: GroupQuestion): [DailyQuestion!]!
  dailyRecapQuestions(group: GroupQuestion): [DailyQuestion!]!
  dailyRecaps(endDate: Date!, group: GroupQuestion, startDate: Date!): [DailyRecap!]!
  dashboard: Dashboard
  dietPreferences(id: ID): [DietPreference]
  drugNutrientInteractions(after: String, before: String, filters: DrugNutrientInteractionsFilterInput, first: Int, last: Int, offset: Int): DrugGroupConnection
  escalations(after: String, before: String, filters: EscalationFilters, first: Int, last: Int): EscalationConnection
  exerciseTracker(after: String, end: DateTime!, first: Int, id: ID, source: SourceType, start: DateTime!): ExerciseEntriesConnection!
  expressMealTracks(after: String, end: DateTime!, first: Int, id: ID, mealTime: MealTime, start: DateTime!): ExpressMealTrackConnection!
  featureLimitations: [AppRestriction!]!
  featuredRecipesByProgram(programId: String): [Recipe]
  flags: GenericScalar
  foodLog(id: ID!): MealLog
  foodLogAssistant(userInput: String!): FoodLogAssistant
  foodLogs(after: String, end: Date!, first: Int, id: ID, start: Date!): FoodLogConnection!
  foodLogsByUser(after: String, before: String, first: Int, fromDate: Date!, last: Int, toDate: Date!, userId: String!): MealLogConnection
  foodSearch(after: String, barcode: String, before: String, filter: FoodFilter, first: Int, isBranded: Boolean, isCommon: Boolean, last: Int, query: String): GenericFoodConnection
  frequentMealLogs: [MealLog]
  googleTransaction(after: String, before: String, first: Int, id: UUID, last: Int, offset: Int): GooglePlayTransactionTypeConnection
  guardrails(after: String, before: String, filters: GuardrailFilterInput, first: Int, id: ID, last: Int, offset: Int): GuardrailConnection
  heartRateLogs(after: String, end: DateTime!, first: Int, id: ID, source: SourceType, start: DateTime!): HeartRateLogsConnnection!
  historicalBiomarkerResults(after: String, before: String, filters: HistoricalBiomarkerResultsFilterInput, first: Int, last: Int, offset: Int): ProfileBiomarkerConnection
  historicalResultsByBiomarker(id: ID!): ProfileBiomarkerResult
  hrvLogs(after: String, end: DateTime!, first: Int, id: ID, source: SourceType, start: DateTime!): HrvLogsConnnection!
  hydration(endDate: Date!, source: SourceType, startDate: Date!, toMl: Boolean): [Hydration!]!
  insights(category: InsightsCategory, date: Date!): [InsightsByCategory!]!
  intakesChecklist(category: IntakeCategory!, end: Date!, start: Date!): IntakesChecklist
  isUserProgramStarted: Boolean
  journey(assistantId: ID!): JourneyAssistantTypeResponse
  knowledgeBase(id: ID!): KnowledgeBaseResponse
  knowledgeBases(assistantId: ID!, search: String): [KnowledgeBaseType]
  labTestReports(after: String, before: String, externalId: String, first: Int, id: ID, isVisible: Boolean, last: Int, orderId: String, profile: ID, requisitionId: String): LabTestReportConnection
  locationAutocomplete(lat: Float!, lon: Float!, query: String!): [LocationAutocomplete]
  log(id: ID!): Logger
  logs(after: String, before: String, first: Int, last: Int, sortBy: SortBy, sortOrder: SortOrder, user: String): LoggerConnection
  macroGoals(date: Date!): MacroGoals
  mealLog(after: String, before: String, first: Int, fromDate: Date!, last: Int, toDate: Date!): MealLogConnection
  mealLogMacroAggs(fromDate: Date!, toDate: Date!): MealLogMacroAggs
  mealPlan(fillDays: Boolean = false, fromDate: Date): [MealPlanDay]
  mealPlanTemplate(id: ID!): MealPlanTemplate
  mealPlanTemplates(after: String, before: String, byCoach: ID, coachTypes: [ID!], excludeCoach: ID, first: Int, isPublic: Boolean, last: Int, newerFirst: Boolean, offset: Int, search: String): MealPlanTemplateConnection
  mealPlannerByCustomFormat(format: [MealTime]!): MealCustomPlannerDays
  mealPlannerByDay(mealPlannerQueryType: MealPlannerQueryType!): MealPlannerDays
  mealTracker(endDate: Date!, startDate: Date!): [MealTrack]!
  menuitem(id: ID!): MenuItem
  menuitemByProgram(databaseId: String!, programId: String!): MenuItem
  menuitemMealTags: [String]
  menuitemSearch(after: String, before: String, course: String, first: Int, last: Int, meals: [String], menu: String, query: String, restaurantId: String, tags: [String]): MenuItemConnection
  menuitemTags: [String]
  menuitems(restaurantId: String!): [MenuItem]
  menuitemsByProgram(programId: String!, restaurantId: String!): [MenuItem]
  myAppointments(end: DateTime, excludeAppointmentsCanceled: Boolean = true, labTestReportIds: [ID!], start: DateTime, timezone: String): [Appointment!]!
  myBrandedFoods(after: String, before: String, first: Int, id: String, last: Int): MyBrandedFoodConnection
  myChecklistItems(after: String, before: String, first: Int, id: ID, last: Int, offset: Int): MyChecklistItemConnection
  myChecklistLogs(end: Date!, start: Date!): MyChecklistLogs!
  myCoaches(after: String, before: String, excludeAppointmentCoaches: Boolean = false, first: Int, id: ID, last: Int, offset: Int): CoachConnection
  myCommonFoods(after: String, before: String, first: Int, id: String, last: Int): MyCommonFoodConnection
  myFavoriteArticles(after: String, before: String, categories: [ID], first: Int, last: Int, offset: Int, order: ContentLibraryOrderBy, search: String, tags: [String!]): ContentLibraryTypeConnection
  myFavoriteMenuitems(after: String, before: String, first: Int, last: Int): MenuItemConnection
  myFavoriteRecipes(after: String, before: String, first: Int, last: Int): RecipeConnection
  myFavoriteRestaurants(after: String, before: String, first: Int, last: Int): RestaurantConnection
  myProfile: ProfileType
  myRecipes(after: String, before: String, first: Int, id: ID, last: Int): UserRecipeConnection
  nextIntakes(category: IntakeCategory!): IntakesChecklistDay
  nextQuestion(questionId: ID!): AssessmentQuestion
  notes(after: String, before: String, eventId: ID, first: Int, id: ID, last: Int, offset: Int): NoteConnection
  nutrientAggregationsByFoodLog(fromDate: Date!, toDate: Date!): NutrientAggregationsByFoodLog
  onProgramPopularRestaurants(lat: Float!, lon: Float!): [Restaurant]
  outocomplete(after: String, before: String, enter: Boolean, first: Int, last: Int, mealType: MealType, mealTypes: [MealType], query: String): OutoCompleteConnection @deprecated(reason: "Deprecating soon.")
  ownFoodItem(id: ID!): MealLog
  ownFoodItems(after: String, before: String, first: Int, fromDate: Date, last: Int, toDate: Date): MealLogConnection
  ownMealLog(id: ID!): MealLog
  ownMealLogs: [MealLog]
  ownRecipe(id: ID!): MealLog
  ownRecipes(after: String, before: String, first: Int, fromDate: Date, last: Int, toDate: Date): MealLogConnection
  pastAppointments(after: String, before: String, end: DateTime, first: Int, last: Int, start: DateTime): AppointmentConnection
  popularRecipes(after: String, before: String, cuisines: [String!], first: Int, hidePurchasable: Boolean = true, last: Int, tags: [String!]): RecipeConnection
  premiumProgramRecipes(after: String, before: String, first: Int, last: Int): RecipeConnection
  profileRecommendations: [ProfileRecommendationType]
  program(id: ID!): Program
  programs(after: String, before: String, filters: ProgramFiltersInput, first: Int, isActive: Boolean, isPremium: Boolean, last: Int, offset: Int, orderBy: ProgramOrderBy): ProgramConnection
  purchases: UserPurchases
  question(id: ID!): AssessmentQuestion
  questionAttributes(after: String, before: String, first: Int, last: Int, offset: Int): AssessmentQuestionAttributeConnection
  questions(after: String, before: String, filters: QuestionsFilterInput, first: Int, last: Int, offset: Int): AssessmentQuestionConnection
  quizAnswers: [QuizAnswer!]!
  quizPrograms: [QuizProgram]
  recentMealLogs: [MealLog]
  recipe(id: ID!): Recipe
  recipeMealTags: [String]
  recipeSearch(after: String, before: String, cuisines: [String], dietaryTag: DietaryTag, filter: FoodFilter, first: Int, hasImage: Boolean, hasInstructions: Boolean, ingredients: [String], isPremium: Boolean, last: Int, macroNutrientsRange: MacroNutrientsRangeInput, maxPrepTime: Int, mealTime: RecipeMealTime, meals: [String], minPrepTime: Int, numberOfIngredients: Int, program: String, query: String, servingQuantity: Int, skillLevel: SkillLevel, tags: [String], totalTime: Float): RecipeConnection
  recipeSwapOptions(recipeId: String, serving: Int): RecipeSwapOptions
  recipeTags(after: String, before: String, first: Int, last: Int, name: String, offset: Int): RecipeTagConnection
  recipesByMealTime(after: String, before: String, cuisines: [String!], dietaryTags: [DietaryTag], first: Int, hidePurchasable: Boolean = true, last: Int, maxPrepTime: Int, mealTime: RecipeMealTime, tags: [String!]): RecipeConnection
  recipesByTag(after: String, before: String, dietaryTags: [DietaryTag], first: Int, hidePurchasable: Boolean = true, last: Int, maxPrepTime: Int, tag: String): RecipeConnection
  recommendedMenuitems(lat: Float!, lon: Float!): [MenuItem]
  recommendedSwaps(forSimpleMealPlan: Boolean, mealTime: RecipeMealTime!): RecommendedSwaps
  restaurant(id: ID!): Restaurant
  restaurantAutocomplete(lat: Float!, lon: Float!, query: String!): [Restaurant]
  restaurantRecommendedMenuitems(restaurantId: String!): [MenuItem]
  restaurantSearch(address: String, after: String, before: String, cuisines: [String], distance: Int = 3, first: Int, geoBoundingBox: GeoBoundingBox, gotAr: Boolean, isOpen: Boolean, last: Int, lat: Float, lon: Float, postalCode: String, priceRating: [PriceRate], program: String, query: String, stateProvince: String): RestaurantConnection
  restaurantSearchByLocation(cuisine: String, geoBoundingBox: GeoBoundingBox, geolat: Float, geolon: Float, lat: Float!, lon: Float!, query: String): RestaurantSearchResult
  restaurantsByLocation(after: String, before: String, first: Int, last: Int, lat: Float, lon: Float): RestaurantConnection
  restriction(id: ID!): Restriction
  restrictions(after: String, before: String, first: Int, last: Int): RestrictionConnection
  searchProfile(email: String!): ProfileType
  searchRecipeByNameOrIngredient(cuisines: [String!], query: String, tags: [String!]): RecipeSearchResult
  searchRecipesByIngredients(after: String, before: String, first: Int, last: Int, mustIngredients: [String]!): RecipeConnection
  serchForAllowedIngredient(ingredient: String!): [CPCIngredient]
  shoppingList(after: String, before: String, first: Int, last: Int, offset: Int, recipe: ID): ListItemConnection
  shoppingListAggregate(after: String, before: String, first: Int, id: UUID, last: Int, offset: Int): AggregateConnection
  shoppingListBadge: Boolean
  similarCaloriesRecipes(numberOfServings: Int, recipeId: ID!, size: Int): [Recipe]
  similarMacrosRecipes(recipeId: String, serving: Int, size: Int): [Recipe]
  sleepQualityScores(after: String, end: Date!, first: Int, id: ID, source: SourceType, start: Date!): SleepQualityScoresConnnection!
  sleepTimes(after: String, end: Date!, first: Int, id: ID, source: SourceType, start: Date!): SleepTimesConnnection!
  stepsCounter(after: String, end: DateTime!, first: Int, id: ID, source: SourceType, start: DateTime!): StepsCounterConnection!
  streaks(endDate: Date!, source: SourceType, startDate: Date!): [Streak!]!
  streaksStats(endDate: Date!, source: SourceType, startDate: Date!): StreaksStats!
  subscriptions(after: String, before: String, first: Int, id: UUID, last: Int, offset: Int): SubscriptionTypeConnection
  supplement(id: ID!): Supplement
  supplementParent(supplementId: ID!): SupplementParent
  supplementPlans(after: String, before: String, first: Int, id: ID, last: Int, offset: Int): SupplementPlanConnection
  supplementRecommendations(assessmentId: ID!, top: Int = 3): [AssessmentAnswerSupplement!]
  supplements(after: String, before: String, first: Int, id: ID, last: Int, name: String, offset: Int): SupplementConnection
  supplementsRecommended(after: String, before: String, first: Int, id: ID, last: Int, offset: Int): SupplementRecommendedConnection
  thirdPartyAppsCustomizations: ThirdPartyAppCustomization
  thirdPartyDailyRecapAnswers(answer: String, answerType: String): [DailyRecapAnswer!]
  thirdPartyDailyRecapQuestions(after: String, answers: [ID!], before: String, first: Int, group: DailyRecapQuestionGroup, last: Int, offset: Int, question: String): ThirdPartyDailyRecapQuestionConnection
  thirdPartyGoals(goal: TrackerComponent, id: ID): [ThirdPartyGoal!]
  todayFoods(endDate: Date!, startDate: Date!): Checklist @deprecated(reason: "No longer supported. Use intakesChecklist instead")
  todaySupplements(endDate: Date!, startDate: Date!): Checklist @deprecated(reason: "No longer supported. Use intakesChecklist instead")

  """
  Returns the goals for each enabled third party's components. By Example: SLEEP_TIME_TRACKER: default is 480 minutes (8h)
  """
  trackingDailyGoals: TrackingDailyGoals!
  trackingSources: [ConnectedSource!]!
  trendingRecipes(after: String, before: String, first: Int, last: Int): RecipeConnection
  upcomingAppointments(after: String, before: String, first: Int, last: Int): AppointmentConnection
  usdaFoodByNdbNumber(ndbNumber: String): UsdaFood
  userAnswersByAssessment(filters: UserAnswersByAssessmentInput, id: ID!): Assessment
  userAssessment(assessmentId: ID!): Assessment
  userAssessmentHistory(after: String, assessmentId: ID!, before: String, first: Int, last: Int, offset: Int): UserAnswerHistoryConnection
  userAssessments(after: String, before: String, filters: UserAssessmentsFilterInput, first: Int, last: Int, offset: Int): AssessmentConnection
  userConsent(consentTypeId: ID, profileId: ID): [UserConsentType!]
  users(after: String, before: String, filters: UsersFiltersInput, first: Int, isTestUser: Boolean, last: Int, profileUUIDs: [String!], subscriptionId: ID, userEmails: [String!], userUUIDs: [String!]): UserConnection
  usersProgress(after: String, before: String, filters: UsersProgressFilterInput, first: Int, last: Int, offset: Int): UserProgressConnection
  weightTracker(endDate: Date!, source: SourceType, startDate: Date!): WeightTracker
  wellnessProfile(id: ID!): WellnessProfileResponse
  wellnessScoreLastSevenDays(date: Date!, source: SourceType): WellnessScoreLastSevenDays!
  zoomAccountRecordings(after: String, before: String, end: Date!, first: Int, jwtToken: String!, last: Int, start: Date!): ZoomRecordingConnection
  zoomSessionRecordings(jwtToken: String!, sessionId: String!): ZoomRecording
}

enum QuestionProfileField {
  ACTIVITY_LEVEL
  BIOLOGICAL_SEX
  BIRTHDATE
  CUSTOM_ATTRIBUTES
  FAVORITE_CUISINES
  HEIGHT
  IS_IMPERIAL
  MALNUTRITION_RISK
  PROGRAM
  RESTRICTIONS
  STARTING_WEIGHT
  TARGET_WEIGHT
  TUBE_FEEDING_ORAL_INTAKE
  USER_PHONE
  WEEKLY_WEIGHT_GOAL
}

input QuestionsFilterInput {
  assessmentId: ID
  canSkip: Boolean
  questionType: QuestionType
  text: String
}

enum QuestionType {
  DATE_PICKER
  DROPDOWN
  MULTI_SELECT
  OPEN_NUMBER
  OPEN_QUESTION
  OPEN_TEXT
  SINGLE_SELECT
  TIME_PICKER
}

type QuizAnswer {
  answer: String!
  answerImage: String
  id: ID!
  question: String!
  questionImage: String
  timestamp: DateTime!
}

type QuizInfo {
  isActive: Boolean
  label: String
}

type QuizProgram {
  author: String
  authorAvatar: String
  backgroundImage: String
  description: String
  experience: QuizInfo
  health: QuizInfo
  isPremium: String
  name: String
  preferences: QuizInfo
  programId: String
}

input Range {
  gte: Float!
  lte: Float!
}

input RangeByMealTimeInput {
  breakfast: RangeInput
  dinner: RangeInput
  lunch: RangeInput
  snack: RangeInput
}

input RangeFilter {
  gte: Float
  lte: Float
}

input RangeInput {
  max: Int
  min: Int
}

input RangeOperator {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
}

type RawNutrientsFull {
  cholesterol: Float
  energy: Float
  fiber: Float
  potassiumK: Float
  saturatedFat: Float
  sodiumNa: Float
  transFats: Float
}

type ReassignChatConversation {
  message: String!
  success: Boolean!
}

input ReassignChatConversationInput {
  coachId: ID!
  conversationSid: String!
}

type Recipe implements Node {
  adherence: Float @deprecated(reason: "Not used, will be removed")
  adherenceDetails: Adherence
  author: String
  authorAvatar: String
  authors: String @deprecated(reason: "Use author instead of this")
  caloriesPerServing: CaloriesPerServing
  cleanName: String
  completeNutritionEstimates: GenericScalar @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  course: String @deprecated(reason: "Use courses instead")
  courses: [String]
  cuisine: String @deprecated(reason: "Use cuisines instead")
  cuisines: [String]
  databaseId: String
  datasetType: String @deprecated(reason: "Not used, internal use only")
  externalId: String
  favoritesCount: Int
  hasTrainableIngredients: Boolean
  id: ID!
  inUserShoppingList: Boolean
  indexedAt: DateTime
  ingredientLines: [String]
  ingredients: [Ingredient]
  ingredientsCount: Int
  instructions: [String]
  isActive: Boolean
  isFeatured: Boolean
  isIndexed: Boolean @deprecated(reason: "Not used, will be removed")
  isLogged: Boolean
  isPremium: Boolean
  isPurchasable: Boolean
  isRestricted: Boolean
  isUserFavorite: Boolean
  language: String
  logo: String
  mainImage: String
  mealBalanceIndex: MealBalanceIndexScore
  mealTags: [String]
  name: String
  nameLowercase: String @deprecated(reason: "Not used, will be removed")
  numberOfServings: Int
  nutrients: Nutrients @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutrientsFull: RawNutrientsFull @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutrientsPerServing: NutrientsPerServing
  nutritionEstimates: NutritionEstimates @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutritionalInfo: NutritionalInfo
  parsedIngredientLines(preferredUnitSystem: UnitSystem): [IngredientLine] @deprecated(reason: "Not used, will be removed")
  programIds: [String]
  rating: Int
  recipeType: String
  relativeCalories: RelativeCalories
  serving: Int
  servingWeight: Float
  servings: [Servings] @deprecated(reason: "Not used, will be removed")
  sgCuisines: [String]
  sgScores: SgScores @deprecated(reason: "Not used, internal use only")
  sgValidated: Boolean
  source: Source
  sourceUrl: String @deprecated(reason: "Use Source.recipeUrl instead")
  sourceUrlNotWorks: Boolean @deprecated(reason: "Not used, will be removed")
  sourceUrlWorks: Boolean!
  squareImage: String
  syntaxIngs: [String]
  tags: [String]
  text: String
  totalTime: String
  totalTimeInSeconds: Int
  updatedAt: DateTime
  url: String @deprecated(reason: "Use Source.recipeUrl instead")
  usersFavorite: [String]
  usersShoppingList: [String]
  weightInGrams: Float
  yieldText: String
}

type RecipeConnection {
  edges: [RecipeEdge]!
  pageInfo: PageInfo!
}

type RecipeEdge {
  cursor: String!
  node: Recipe
}

enum RecipeMealTime {
  BREAKFAST
  DINNER
  LUNCH
  SNACK
  TREAT_DESSERT
}

type RecipeProxy {
  recipe: Recipe!
}

type RecipeSearchResult {
  onPlan: [Recipe]
  otherResults: [Recipe]
}

type RecipeSwapOptions {
  onPlan(size: Int): [Recipe]
  similar(size: Int): [Recipe]
}

type RecipeTag implements Node {
  createdAt: DateTime!
  displayName: String!
  id: ID!
  termName: String!
  updatedAt: DateTime!
}

type RecipeTagConnection {
  edges: [RecipeTagEdge]!
  pageInfo: PageInfo!
}

type RecipeTagEdge {
  cursor: String!
  node: RecipeTag
}

type RecommendationCatalogType {
  createdAt: DateTime
  databaseId: String
  id: UUID!
  image: String
  profilerecommendationSet: [ProfileRecommendationType!]!
  reference: String!
  subtitle: String
  textAdditional1: String
  textAdditional2: String
  textMain: String
  title: String!
  updatedAt: DateTime
  url: String
}

type RecommendedSwaps {
  meals: [Recipe]
  recipes: [Recipe]
}

type RelativeCalories {
  ala: Float
  carbs: Float
  dha: Float
  dpa: Float
  epa: Float
  fat: Float
  monounsaturatedFat: Float
  omega3: Float
  polyunsaturatedFat: Float
  protein: Float
  saturatedFat: Float
  transFat: Float
}

type RemoveCoachChatConversation {
  message: String!
  success: Boolean!
}

input RemoveCoachChatConversationInput {
  coachId: ID!
  conversationSid: String!
}

type RemoveFavoriteArticle {
  message: String!
  success: Boolean!
}

type RemoveFromShoppingList {
  message: String
  success: Boolean
}

type RemoveMealLogMutation {
  success: Boolean
}

type RemoveMealPlan {
  message: String
  success: Boolean
}

type RemoveMealPlanRecipe {
  message: String!
  success: Boolean!
}

type RemoveOwnMeal {
  message: String
  success: Boolean
}

type RemoveUserConsent {
  message: String!
  success: Boolean!
}

type RemoveUserFromJourney {
  message: String!
  success: Boolean!
}

input RemoveUserFromJourneyInput {
  journey: ID!
  profile: ID!
}

type RequestAccountDeletion {
  message: String!
  success: Boolean!
}

type RequestResetPassword {
  message: String!
  resetPasswordCode: String
  success: Boolean!
}

type RequestUserDataDownload {
  message: String!
  success: Boolean!
}

type ResendAppointmentConfirmationEmail {
  message: String!
  success: Boolean!
}

type ResetPassword {
  message: String!
  success: Boolean!
}

type Restaurant implements Node {
  address1: String
  businessType: String
  cityTown: String
  country: String
  createdAt: DateTime
  cuisine: String @deprecated(reason: "Use cuisines instead of cuisine")
  cuisineTag: String @deprecated(reason: "Use cuisines instead of cuisine_tag")
  cuisines: [String]
  databaseId: String
  description: String
  favoritesCount: Int
  gotAr: Boolean
  hours: Hours
  id: ID!
  indexedAt: DateTime
  isActive: Boolean
  isClosed: Boolean
  isOpen: Boolean
  isOwnerVerified: Boolean
  isRecomended: Boolean
  isUserFavorite: Boolean
  location: [Float]
  locationId: String
  maxPriceRange: Float @deprecated(reason: "no longer used")
  minPriceRange: Float @deprecated(reason: "no longer used")
  name: String
  objectType: String
  phone: String
  photos: [String]
  postalCode: String
  priceRating: String
  recommendation: String
  recommendationsCount: Int
  shortName: String
  stateProvince: String
  suggest: String
  type: String
  updatedAt: DateTime
  usersFavorite: [String]
  websiteUrl: String
  yelpRating: Float
  yelpReviewCount: Int
}

type RestaurantConnection {
  edges: [RestaurantEdge]!
  pageInfo: PageInfo!
  totalCount: Int
}

type RestaurantEdge {
  cursor: String!
  node: Restaurant
  other: String
}

type RestaurantSearchResult {
  onPlan: [Restaurant]
  otherResults: [Restaurant]
}

type Restriction implements Node {
  databaseId: String @deprecated(reason: "use ID!")
  id: ID!
  isOnProgram: Boolean
  name: String
  slugname: String
  subcategory: String
}

type RestrictionConnection {
  edges: [RestrictionEdge]!
  pageInfo: PageInfo!
}

type RestrictionEdge {
  cursor: String!
  node: Restriction
}

type SaveZoomSessionForAppointment {
  message: String!
  success: Boolean!
}

input SaveZoomSessionForAppointmentInput {
  appointment: ID!
  sessionId: String!
}

type SelectDailyRecapQuestions {
  message: String!
  success: Boolean!
}

type SendFeedback {
  message: String
  success: Boolean
}

type SensitiveProfileAttributes {
  errors: [ErrorType]
  success: Boolean
}

type Servings {
  amount: Float
  description: String
  equivalent: Float
  selected: Boolean
  unit: String
}

type SetActiveSource {
  message: String!
  success: Boolean!
}

type SetMealPlanToTemplate {
  message: String!
  success: Boolean!
}

type SetThirdPartyAppUserAsTest {
  errors: [FormError!]
  message: String!
  success: Boolean!
  user: User
}

input SetThirdPartyAppUserAsTestInput {
  isTest: Boolean!
  user: ID!
}

type SetUserAnswers {
  errors: [FormError!]
  message: String!
  nextQuestion: AssessmentQuestion
  success: Boolean!
  userAnswers: [UserAnswer!]
}

input SetUserAnswersInput {
  assessmentId: ID!
  userAnswers: [UserAnswerInput!]!
}

type SgScores {
  keto: Float
}

input SimpleMPFiltersInput {
  cuisines: [String]
  kcalRange: RangeByMealTimeInput
  maxTimeMinutes: IntValueByMealTime
  tags: TermValuesByMealTimeInput
}

input SingleSupplementActivableProtocolInput {
  directionsOfUse: [DirectionsOfUseInput!]
  frequency: SPFrequencyInput
  friday: Boolean
  isActive: Boolean
  length: Int!
  monday: Boolean
  saturday: Boolean
  sunday: Boolean
  supplementId: ID!
  thursday: Boolean
  tuesday: Boolean
  wednesday: Boolean
}

enum SitemapURLTaskStatus {
  CREATED
  DONE
  ERROR
  PROCESSING
}

type SitemapUrlType {
  id: ID
  knowledgeBase: ID
  sitemapUrl: String!
  taskStatus: SitemapURLTaskStatus!
  url: String!
  urlLastFetch: DateTime!
}

enum SkillLevel {
  EASY
  EXPERT
  MEDIUM
}

input SleepQualityEntryInput {
  date: Date!
  source: SourceType!
  value: PositiveInt!
}

type SleepQualityScore {
  date: Date!
  floatValue: Float!
  id: ID!
  source: SourceType!

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int

  """
  sleep quality index scaling from 0 to 100, where the values above 77 signify
  good sleep quality, while those below 77 signify poor sleep quality.
  """
  value: Int! @deprecated
}

type SleepQualityScoreEdge {
  cursor: String!
  node: SleepQualityScore
}

type SleepQualityScoresConnnection {
  average: Int! @deprecated
  edges: [SleepQualityScoreEdge]!
  floatAverage: Float!
  pageInfo: PageInfo!
}

type SleepTime {
  createdAt: DateTime!
  date: Date!
  floatValue: Float!
  id: ID!
  source: SourceType!

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int

  """Sleep duration in minutes"""
  value: Int! @deprecated
}

type SleepTimeEdge {
  cursor: String!
  node: SleepTime
}

input SleepTimeEntryInput {
  date: Date!
  source: SourceType!
  value: PositiveInt!
}

type SleepTimesConnnection {
  dailyGoal: Int!
  edges: [SleepTimeEdge]!
  latestEntry: DateTime
  pageInfo: PageInfo!
  totalTime: Int!
}

enum SortBy {
  INDEXED_AT
}

enum SortOrder {
  ASC
  DESC
}

type Source {
  displayName: String
  recipeUrl: String!
  siteUrl: String
}

enum SourceType {
  APPLE
  FITBIT
  GARMIN
  GOOGLEFIT_NATIVE
  GOOGLEFIT_REST
  HUAWEIHEALTH
  IHEALTH
  MISFIT
  OMRONCONNECT
  OMRONWELLNESS
  OURA
  POLAR
  SAMSUNG
  STRAVA
  SUGGESTIC
  SUUNTO
  WITHINGS
}

type SPFrequency {
  periodicity: SPPeriodicity!
  times: Int!
}

input SPFrequencyInput {
  periodicity: SPPeriodicity!
  times: Int!
}

enum SPPeriodicity {
  DAILY
  MONTHLY
  WEEKLY
  YEARLY
}

input SPProtocolInput {
  directionsOfUse: [DirectionsOfUseInput!]!
  frequency: SPFrequencyInput
  friday: Boolean
  isActive: Boolean
  monday: Boolean
  protocolId: ID!
  saturday: Boolean
  sunday: Boolean
  thursday: Boolean
  tuesday: Boolean
  wednesday: Boolean
}

input SPUpdateProtocolInput {
  directionsOfUse: [DirectionsOfUseInput!]
  frequency: SPFrequencyInput
  friday: Boolean
  isActive: Boolean
  monday: Boolean
  protocolId: ID!
  saturday: Boolean
  sunday: Boolean
  thursday: Boolean
  tuesday: Boolean
  wednesday: Boolean
}

input StartChatConversationInput {
  assistant: ID
  clientMutationId: String
}

type StartChatConversationPayload {
  clientMutationId: String
  conversationSid: String
  message: String!
  success: Boolean!
}

type StartJourneys {
  message: String
  success: Boolean
}

type StartOverMealPlan {
  message: String
  success: Boolean
}

type StepCount {
  createdAt: DateTime!
  datetime: DateTime!
  id: ID!
  source: SourceType!
  steps: Int!

  """field only relevant for sources other than Suggestic"""
  timezoneOffset: Int
}

input StepCountEntryInput {
  datetime: DateTime!
  source: SourceType!
  steps: PositiveInt!
}

type StepsCounterConnection {
  dailyGoal: Int!
  distance: Float!
  edges: [StepsCounterEdge]!
  latestEntry: DateTime
  pageInfo: PageInfo!
}

type StepsCounterEdge {
  cursor: String!
  node: StepCount
}

type StoreConversationSummary {
  message: String!
  success: Boolean!
}

input StoreConversationSummaryInput {
  text: String!
}

type Streak {
  activities: [EntryType] @deprecated
  completed: [EntryType]
  date: Date
  dayStatus: DayStatus
  empties: [EntryType]
  expectedActivities: [EntryType]
  hasPreviousStreak: Boolean
  isToday: Boolean
  longestPerfectDayStreakEver: Int
  longestStreakEver: Int! @deprecated
  totalPerfectDays: Int! @deprecated
}

type StreaksStats {
  longestStreak: Int!
  totalPerfectDays: Int!
}

enum SubscriptionBillingPeriod {
  MONTH
  ONCE
  SEMESTER
  TRI_MONTH
  YEAR
}

enum SubscriptionDuration {
  FOREVER
  MONTH
  SEMESTER
  TRI_MONTH
  YEAR
}

type SubscriptionTransaction implements Node {
  cancellationDate: DateTime
  cancellationSource: String
  createdAt: DateTime
  email: String
  expirationDate: DateTime
  expiresStat: String
  externalTransactionId: String
  hasRefund: Boolean!
  id: ID!
  isActive: Boolean!
  isCanceled: Boolean!
  isDowngrade: Boolean!
  isExpired: Boolean
  isInitial: Boolean!
  isProcess: Boolean!
  isRenewal: Boolean!
  isTrialPeriod: Boolean!
  livemode: Boolean!
  parentId: String
  parentType: String
  program: Program
  programStat: String
  purchaseDate: DateTime
  subscription: SubscriptionType
  transactionProvider: String!
  updatedAt: DateTime
}

type SubscriptionTransactionConnection {
  edges: [SubscriptionTransactionEdge]!
  pageInfo: PageInfo!
}

type SubscriptionTransactionEdge {
  cursor: String!
  node: SubscriptionTransaction
}

type SubscriptionType implements Node {
  appleId: String
  billingPeriod: SubscriptionBillingPeriod
  createdAt: DateTime
  databaseId: String
  duration: SubscriptionDuration!
  googleplaySku: String
  id: ID!
  isActive: Boolean!
  isRecurring: Boolean!
  name: String!
  periodPrice: Int!
  permissions: [String!]
  product: ProductType
  totalPrice: Int!
  trialPeriodDays: Int!
  updatedAt: DateTime
}

type SubscriptionTypeConnection {
  edges: [SubscriptionTypeEdge]!
  pageInfo: PageInfo!
}

type SubscriptionTypeEdge {
  cursor: String!
  node: SubscriptionType
}

type Suggestion {
  author: String
  barcode: String
  brand: String
  courses: [String]
  databaseId: String
  extraInfo: String
  foodBlockOrManufacturer: String
  indexedAt: DateTime
  isRawIngredient: Boolean
  isVerified: Boolean
  location: GeoPoint
  manufacName: String
  mealType: MealType
  mealTypeDisplayName: String
  name: String
  nutrients: Nutrients @deprecated(reason: "Use nutritionalInfo instead")
  nutritionalInfo: NutritionalInfo
  profileId: String
  secondaryInfoText: String
  serving: Int
  servingWeight: Float
  servings: [Servings]
  suggest: String
  unitOption: String
  updatedAt: DateTime
}

type Supplement implements Node {
  answerSet(after: String, before: String, first: Int, last: Int, offset: Int): AssessmentAnswerConnection!
  answersupplementSet(after: String, before: String, first: Int, last: Int, offset: Int): AssessmentAnswerSupplementConnection!
  brand: String!
  category: String!
  createdAt: DateTime!
  description: String
  directionsOfUse: [SupplementDirection!]!
  directionsOfUseText: String
  externalId: String
  id: ID!
  images: [String!]
  ingredients: String
  instructions: String
  mainImage: String!
  name: String!
  productUrl: String
  protocolBundle(after: String, before: String, first: Int, last: Int, offset: Int): ProtocolConnection!
  servingName: String!
  shopifyParentId: String
  shopifyVariantId: String
  sizeCount: Int!
  sku: String
  storeId: String
  supplementFacts: String
  supplementrecommendationSet(after: String, before: String, first: Int, last: Int, offset: Int): SupplementRecommendedConnection!
  updatedAt: DateTime!
}

input SupplementCartItem {
  quantity: Int!
  variantId: ID!
}

type SupplementConnection {
  edges: [SupplementEdge]!
  pageInfo: PageInfo!
}

type SupplementDirection {
  createdAt: DateTime!
  id: ID!
  quantity: Float!
  timeOfDay: TimeOfDay!
  updatedAt: DateTime!
}

type SupplementEdge {
  cursor: String!
  node: Supplement
}

type SupplementOnPlan {
  checked: Boolean!
  order: Int!
  planName: String!
  quantity: Float!
  supplement: Supplement!
  timeOfDay: TimeOfDay
}

type SupplementParent {
  availableForSale: Boolean!
  featuredImage: String
  id: ID!
  options: [ProductOption!]
  title: String!
  variants: [ProductVariant!]!
}

type SupplementPlan implements Node {
  createdAt: DateTime!
  exercise: String
  id: ID!
  isActive: Boolean!
  name: String!
  nutrition: String
  overview: String
  protocols(coachTypes: [ID!], group: ProtocolGroup): [SupplementPlanProtocol!]!
  resources: String
  startDate: Date!
  updatedAt: DateTime!
  visibility: Boolean!
}

type SupplementPlanConnection {
  edges: [SupplementPlanEdge]!
  pageInfo: PageInfo!
}

type SupplementPlanEdge {
  cursor: String!
  node: SupplementPlan
}

type SupplementPlanProtocol {
  createdAt: DateTime!
  directionsOfUse: [SupplementDirection!]!
  endsAt: DateTime
  frequency: SPFrequency
  friday: Boolean!
  id: ID!
  isActive: Boolean!
  monday: Boolean!
  order: Int!
  protocol: Protocol!
  saturday: Boolean!
  startsAt: DateTime
  sunday: Boolean!
  thursday: Boolean!
  tuesday: Boolean!
  updatedAt: DateTime!
  wednesday: Boolean!
}

type SupplementProtocol {
  directionsOfUse: [SupplementDirection!]!
  friday: Boolean!
  id: ID!
  monday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
  supplement: Supplement!
  thursday: Boolean!
  tuesday: Boolean!
  wednesday: Boolean!
}

type SupplementRecommended implements Node {
  biomarker: Biomarker!
  createdAt: DateTime!
  id: ID!
  normalValues: [GenericScalar!]
  supplement: Supplement!
  updatedAt: DateTime!
  valueMax: Float
  valueMin: Float
}

type SupplementRecommendedConnection {
  edges: [SupplementRecommendedEdge]!
  pageInfo: PageInfo!
}

type SupplementRecommendedEdge {
  cursor: String!
  node: SupplementRecommended
}

type SwapMealPlanRecipe {
  mealPlan: [MealPlanDay] @deprecated(reason: "Not used, will be removed")
  message: String
  success: Boolean
}

type TaskItemType {
  id: ID!
  isCompleted: Boolean
  keyHash: String
  name: String
  taskListId: String
}

type TaskListType {
  databaseId: String
  id: ID!
  name: String!
  taskItems: [TaskItemType]
}

type Tendency {
  difference: Float
  type: TendencyType
}

enum TendencyType {
  DOWN
  UP
}

input TermValuesByMealTimeInput {
  breakfast: [String!]
  dinner: [String!]
  lunch: [String!]
  snack: [String!]
}

type ThirdPartyAppCustomization implements Node {
  backgroundGradientColor1: String
  backgroundGradientColor2: String
  id: ID!
  logo: String
  primaryColor: String
  secondaryColor: String
  selectedFeatures: [String!]!
}

type ThirdPartyDailyRecapQuestion implements Node {
  answers: [DailyRecapAnswer!]
  group: DailyRecapQuestionGroup
  id: ID!
  imageUrl: String
  isDefault: Boolean
  lang: JSONString!
  program: Program
  question: String
  title: String
}

type ThirdPartyDailyRecapQuestionConnection {
  edges: [ThirdPartyDailyRecapQuestionEdge]!
  pageInfo: PageInfo!
}

type ThirdPartyDailyRecapQuestionEdge {
  cursor: String!
  node: ThirdPartyDailyRecapQuestion
}

type ThirdPartyGoal implements Node {
  goal: ThirdPartyGoalGoal!
  id: ID!
  value: Float!
}

enum ThirdPartyGoalGoal {
  BLOOD_PRESSURE_TRACKER
  DAILY_MOOD
  DAILY_RECAP
  EXERCISE_TRACKER
  FOOD_LOGS
  FOOD_LOG_MEAL_TRACKER
  HEART_RATE_TRACKER
  HRV_TRACKER
  HYDRATION_TRACKER
  MP_MEAL_TRACKER
  MY_CHECKLIST_TRACKER
  PLAN_SUPPLEMENT
  PLAN_SUPPLEMENTS_MY_CHECKLIST
  SLEEP_QUALITY_SCORE_TRACKER
  SLEEP_TIME_TRACKER
  STEPS_TRACKER
  TODAY_FOOD
  TODAY_SUPPLEMENT
  WEIGHT_TRACKER
}

scalar Time

enum TimeOfDay {
  AT_BEDTIME
  AT_WAKING
  WITH_BREAKFAST
  WITH_DINNER
  WITH_LUNCH
}

type TimePeriod {
  coaches: [Coach!]!
  end: DateTime!
  start: DateTime!
}

type ToggleShoppingListItem {
  message: String
  success: Boolean
}

type ToggleShoppingListItems {
  message: String
  success: Boolean
}

type ToggleTaskCompleted {
  message: String
  success: Boolean
}

enum TrackerComponent {
  BLOOD_PRESSURE_TRACKER
  DAILY_MOOD
  DAILY_RECAP
  EXERCISE_TRACKER
  FOOD_LOGS
  FOOD_LOG_MEAL_TRACKER
  HEART_RATE_TRACKER
  HRV_TRACKER
  HYDRATION_TRACKER
  MP_MEAL_TRACKER
  MY_CHECKLIST_TRACKER
  PLAN_SUPPLEMENT
  PLAN_SUPPLEMENTS_MY_CHECKLIST
  SLEEP_QUALITY_SCORE_TRACKER
  SLEEP_TIME_TRACKER
  STEPS_TRACKER
  TODAY_FOOD
  TODAY_SUPPLEMENT
  WEIGHT_TRACKER
}

type TrackingDailyGoal {
  entryType: EntryType!
  goal: Int
}

type TrackingDailyGoals {
  dailyGoals: [TrackingDailyGoal!]!
}

type UncheckIntake {
  message: String!
  success: Boolean!
}

type UncheckTodayFood {
  message: String!
  success: Boolean!
}

type UncheckTodaySupplement {
  message: String!
  success: Boolean!
}

enum UnitSystem {
  IMPERIAL
  METRIC
}

type UnlinkUserAssessment {
  message: String!
  success: Boolean!
}

type UpdateAnswer {
  answer: AssessmentAnswer
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateAnswerInput {
  assessmentEnded: Boolean = false
  attribute: AttributeInput
  blockOtherAnswers: Boolean = false
  id: ID!
  isCorrect: Boolean
  nextQuestionId: ID
  score: Int
  supplements: [AnswerSupplementInput!]
  text: String
  value: String
}

type UpdateAppointment {
  appointment: Appointment
  message: String!
  success: Boolean!
}

type UpdateAppointmentCredits {
  credits: AppointmentCredit
  message: String!
  success: Boolean!
}

input UpdateAppointmentInput {
  appointment: ID!
  appointmentType: ID
  contactType: CalendarContactType
  datetime: DateTime
  postEventStatus: PostEventStatus
  timezone: String
}

type UpdateArticleRecommended {
  articleRecommended: ArticleRecommended
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateArticleRecommendedInput {
  articleId: ID
  biomarkerId: ID
  id: ID!
  normalValues: [GenericScalar!]
  range: BiomarkerRangeInput
}

type UpdateAssessment {
  assessment: Assessment
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateAssessmentInput {
  assessmentType: AssessmentType
  bottomProgressBar: Boolean
  closeButton: Boolean
  description: String
  disableLoader: Boolean
  hasScore: Boolean
  icon: Upload
  id: ID!
  interval: Int
  isDraft: Boolean
  isPublic: Boolean
  order: Int
  progressBar: Boolean
  progressMaxCount: Int
  relativeButtonPosition: Boolean
  resultsImageUrl: String
  style: GenericScalar
  title: String
  weight: Int
}

type UpdateAssistant {
  assistant: Assistant
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateAssistantInput {
  id: ID!
  mainGoal: String
  mode: AssistantMode
  name: String
  onboarding: Boolean
  onboardingPrompt: String
  programId: ID
  voice: String
}

type UpdateBiomarker {
  biomarker: Biomarker
  errors: [FormError!]
  message: String!
  success: Boolean!
}

type UpdateBiomarkerCategory {
  biomarkerCategory: BiomarkerCategory
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateBiomarkerCategoryInput {
  id: ID!
  name: String
  order: Int
  parent: ID
}

input UpdateBiomarkerInput {
  aliases: [BiomarkerAliasInput!]
  borderlineRange: BiomarkerRangeInput
  category: ID
  description: String
  id: ID!
  isVisible: Boolean = true
  method: String
  name: String
  normalValues: [GenericScalar!] = ["{}"]
  optimalRange: BiomarkerRangeInput
  order: Int = 0
  range: BiomarkerRangeInput
  units: [ID!]
}

type UpdateBloodPressureLog {
  message: String!
  success: Boolean!
}

type UpdateCoachTeam {
  coachTeam: CoachTeam
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateCoachTeamInput {
  coaches: [ID!]
  description: String
  id: ID!
  name: String
}

type UpdateCoachType {
  coachType: CoachType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateCoachTypeInput {
  coaches: [ID!]
  description: String
  id: ID!
  name: String
}

type UpdateContentCategory {
  contentCategory: ContentCategoryType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateContentCategoryInput {
  id: ID!
  image: Upload
  lang: GenericScalar
  name: String
  order: Int
  subcategories: [ID]
  subtitle: String
  tags: [ID]
}

type UpdateContentLibrary {
  contentLibrary: ContentLibraryType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateContentLibraryInput {
  categories: [ID]
  id: ID!
  imageUrl: String
  isBlocked: Boolean
  isFeatured: Boolean
  lang: GenericScalar = "{}"
  order: Int
  programs: [ID!]
  sourceUrl: String
  subTitle: String
  tags: [ID]
  title: String
}

type UpdateContentTag {
  contentTag: ContentTagType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

type UpdateDailyRecapAnswer {
  dailyRecapAnswer: DailyRecapAnswer
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateDailyRecapAnswerInput {
  answer: String
  id: ID!
  lang: GenericScalar
  type: String
}

type UpdateDailyRecapQuestion {
  dailyRecapQuestion: ThirdPartyDailyRecapQuestion
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateDailyRecapQuestionInput {
  answers: [ID]
  id: ID!
  imageUrl: String
  lang: GenericScalar
  program: ID
  question: String
}

type UpdateDietPreference {
  dietPreference: DietPreference
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateDietPreferenceInput {
  id: ID!
  name: String
  operationOverRestrictions: Operation
  restrictions: [ID!]
}

type UpdateDynamicQuestion {
  dynamicQuestion: AssessmentDynamicQuestion
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateDynamicQuestionInput {
  dependsOnAnswers: [ID!]
  id: ID!
  order: Int
  parentQuestionId: ID
  questionId: ID
}

type UpdateExpressTrack {
  message: String!
  success: Boolean!
}

type UpdateGuardrail {
  errors: [FormError!]
  guardrail: Guardrail
  message: String!
  success: Boolean!
}

input UpdateGuardrailInput {
  assistant: ID
  description: String
  id: ID!
  message: String
  name: String
}

type UpdateHydration {
  message: String
  success: Boolean
}

type UpdateInteraction {
  interaction: InteractionType
  message: String!
  success: Boolean!
}

type UpdateJourney {
  journey: JourneyAssistantType
  message: String!
  success: Boolean!
}

input UpdateJourneyInput {
  id: ID!
  sendWelcomeMessage: Boolean
  welcomeMessage: String
}

type UpdateJourneyStatus {
  message: String
  success: Boolean
}

type UpdateLabTestReport {
  errors: [FormError!]
  message: String!
  report: LabTestReport
  success: Boolean!
}

type UpdateMealLogMutation {
  success: Boolean
}

type UpdateMealPlanSettings {
  message: String!
  success: Boolean!
}

type UpdateMealPlanTemplate {
  mealPlan: MealPlanTemplate
  message: String!
  success: Boolean!
}

input UpdateMPSettingsInput {
  calories: Int
  carbs: Int
  fat: Int
  format: [MealTime!]
  omega3: Float
  protein: Int
}

type UpdateMyBrandedFood {
  message: String!
  success: Boolean!
}

input UpdateMyBrandedFoodInput {
  brandName: String
  brandOwner: String
  brandedFoodCategory: String
  description: String
  gtinUpc: String
  householdServingFulltext: String
  name: String
  nutrients: [NutrientInput]
  servingSize: Float
  servingSizeUnit: String
}

type UpdateMyChecklistItem {
  message: String!
  myChecklistItem: MyChecklistItem
  success: Boolean!
}

type UpdateMyCommonFood {
  message: String!
  success: Boolean!
}

input UpdateMyCommonFoodInput {
  description: String
  name: String
  nutrients: [NutrientInput]
  portions: [PortionInput]
}

type UpdateMyRecipe {
  message: String!
  recipe: UserRecipe
  success: Boolean!
}

input UpdateMyRecipeInput {
  courses: [String!]
  cuisines: [String!]
  ingredientLines: [String!]
  ingredients: [IngredientAmount!]
  instructions: [String!]
  language: Language
  mainImage: String
  mealTimes: [MealTime!]
  name: String
  numberOfServings: Int
  squareImage: String
  tags: [String]
  text: String
  totalTime: String
  totalTimeInSeconds: Int
}

type UpdateNote {
  errors: [FormError!]
  message: String!
  note: Note
  success: Boolean!
}

type UpdateOwnMealMutation {
  message: String
  success: Boolean
}

type UpdateOwnRecipe {
  message: String!
  success: Boolean!
}

type UpdateProfile {
  errors: [ErrorType]
  success: Boolean
}

type UpdateProfileBiomarkers {
  success: Boolean
}

type UpdateProtocol {
  message: String!
  protocol: Protocol
  success: Boolean!
}

input UpdateProtocolInput {
  group: ProtocolGroup
  id: ID!
  isActive: Boolean
}

type UpdateQuestion {
  errors: [FormError!]
  message: String!
  question: AssessmentQuestion
  success: Boolean!
}

input UpdateQuestionInput {
  answers: [CreateQuestionAnswerInput!]
  assessmentId: ID
  attributes: [ID!]
  canSkip: Boolean
  collapsibleHelpText: Boolean
  comment: String
  finalButton: String
  finalText: String
  finalTitle: String
  hasDynamicAnswers: Boolean = false
  helpText: String
  helpTitle: String
  htmlElement: FormHtmlElement
  id: ID!
  information: String
  informationTitle: String
  isExit: Boolean = false
  isFinalQuestion: Boolean
  isInitialQuestion: Boolean
  maxOptionsSelected: Int
  minOptionsSelected: Int
  nextQuestionId: ID
  profileField: ProfileField
  questionType: QuestionType
  text: String
}

type UpdateShoppingListRecipeServings {
  success: Boolean
}

input UpdateSPInput {
  coach: ID
  exercise: String
  id: ID!
  isActive: Boolean
  name: String
  nutrition: String
  overview: String
  resources: String
  setProtocols: [SPProtocolInput!]
  setSupplements: [SingleSupplementActivableProtocolInput!]
  startDate: Date
  updateProtocols: [SPUpdateProtocolInput!]
  visibility: Boolean
}

type UpdateSubscription {
  message: String
  success: Boolean
}

type UpdateSupplement {
  message: String!
  success: Boolean!
  supplement: Supplement
}

input UpdateSupplementInput {
  brand: String
  category: String
  description: String
  directionsOfUse: [DirectionsOfUseInput!]
  directionsOfUseText: String
  externalId: String
  id: ID!
  images: [String!]
  ingredients: String
  instructions: String
  mainImage: String
  name: String
  servingName: String
  shopifyParentId: String
  shopifyVariantId: String
  sizeCount: Int
  sku: String
  storeId: String
  supplementFacts: String
}

type UpdateSupplementPlan {
  message: String!
  success: Boolean!
  supplementPlan: SupplementPlan
}

type UpdateSupplementRecommended {
  errors: [FormError!]
  message: String!
  success: Boolean!
  supplementRecommended: SupplementRecommended
}

input UpdateSupplementRecommendedInput {
  biomarkerId: ID
  id: ID!
  normalValues: [GenericScalar!]
  range: BiomarkerRangeInput
  supplementId: ID
}

type UpdateThirdPartyGoal {
  goal: ThirdPartyGoal
  message: String!
  success: Boolean!
}

input UpdateThirdPartyGoalInput {
  id: ID!
  value: Float!
}

type UpdateThirdPartyTrackerComponent {
  enabledComponents: [TrackerComponent!]
  message: String!
  success: Boolean!
}

input UpdateThirdPartyTrackerComponentInput {
  components: [TrackerComponent!]!
  operation: Operation!
}

type UpdateUserAssessmentScore {
  errors: [FormError!]
  message: String!
  success: Boolean!
  userProgress: UserProgress
}

input UpdateUserAssessmentScoreInput {
  assessmentId: ID!
  profileId: ID!
  score: Int
}

type UpdateUserProgram {
  message: String
  success: Boolean
}

type UpdateUserProgress {
  errors: [FormError!]
  message: String!
  success: Boolean!
  userProgress: UserProgress
}

input UpdateUserProgressInput {
  id: ID!
  score: Int
}

scalar Upload

type UsdaFood implements Node {
  commonNames: [String]
  dataType: String
  description: String
  foodDataId: String
  id: ID!
  nutrients: [Nutrients]
  portions: [Portion]
}

type User implements Node {
  appleUserSource: String
  appleUserSourceJson: JSONString
  avatar: String
  createdAt: DateTime!
  databaseId: String
  email: String
  id: ID!
  isActive: Boolean!
  isArUser: Boolean!
  isTest: Boolean!
  name: String
  organizationId: UUID
  phone: String!
  profileId: String
  subscription: SubscriptionType
  updatedAt: DateTime!
  userSource: String
}

type UserAnswer implements Node {
  answer: AssessmentAnswer
  answerText: String
  createdAt: DateTime!
  id: ID!
  profile: ProfileType!
  question: AssessmentQuestion!
  rankingOrder: Int
  updatedAt: DateTime!
}

type UserAnswerConnection {
  edges: [UserAnswerEdge]!
  pageInfo: PageInfo!
}

type UserAnswerEdge {
  cursor: String!
  node: UserAnswer
}

type UserAnswerHistory implements Node {
  answer: AssessmentAnswer
  answerText: String
  attempts: Int!
  createdAt: DateTime!
  id: ID!
  question: AssessmentQuestion!
  rankingOrder: Int
  updatedAt: DateTime!
}

type UserAnswerHistoryConnection {
  edges: [UserAnswerHistoryEdge]!
  pageInfo: PageInfo!
}

type UserAnswerHistoryEdge {
  cursor: String!
  node: UserAnswerHistory
}

input UserAnswerInput {
  answerId: ID
  answerText: String
  questionId: ID!
  rankingOrder: Int
}

enum UserAnswerOrderByField {
  answer
  answer_text
  created_at
  id
  profile
  question
  updated_at
}

input UserAnswerOrderByInput {
  field: UserAnswerOrderByField = profile
  order: SortOrder = ASC
}

input UserAnswersByAssessmentInput {
  questionIds: [ID!]
}

input UserAssessmentsFilterInput {
  description: String
  status: AssessmentStatus
  title: String
}

type UserConnection {
  edges: [UserEdge]!
  pageInfo: PageInfo!
}

type UserConsentType implements Node {
  consentType: ConsentType!
  consentedAt: DateTime!
  id: ID!
  profile: ProfileType!
}

type UserEdge {
  cursor: String!
  node: User
}

type UserFavoriteMenuItem {
  isUserFavorite: Boolean
  success: Boolean
}

type UserFavoriteRecipe {
  isUserFavorite: Boolean
  message: String!
  success: Boolean
}

type UserFavoriteRestaurant {
  isUserFavorite: Boolean
  success: Boolean
}

type UserProgress implements Node {
  assessment: Assessment!
  createdAt: DateTime!
  currentQuestion: AssessmentQuestion!
  endDate: DateTime!
  id: ID!
  profile: ProfileType!
  score: Float
  startDate: DateTime!
  updatedAt: DateTime!
}

type UserProgressConnection {
  edges: [UserProgressEdge]!
  pageInfo: PageInfo!
}

type UserProgressEdge {
  cursor: String!
  node: UserProgress
}

type UserPurchases {
  activeSubscriptionTransaction: SubscriptionTransaction
}

type UserRecipe implements Node {
  courses: [String!]
  cuisines: [String!]
  id: ID!
  ingredientLines: [String!]!
  ingredients: [IngredientFoodFormat!]!
  instructions: String
  language: Language!
  mainImage: String
  mealTimes: [RecipeMealTime!]
  name: String!
  numberOfServings: Int!
  nutrients: [Nutrient!]
  nutrientsPerServing: [Nutrient!]
  servingWeight: Float!
  squareImage: String
  tags: [String]
  text: String
  totalTime: String
  totalTimeInSeconds: Int
  weightInGrams: Float!
}

type UserRecipeConnection {
  count: Int
  edges: [UserRecipeEdge]!
  pageInfo: PageInfo!
}

type UserRecipeEdge {
  cursor: String!
  node: UserRecipe
}

type UserRecipeProxy {
  userRecipe: UserRecipe!
}

input UsersFiltersInput {
  createdAt: CreatedAtRangeInput
}

input UsersProgressFilterInput {
  assessmentId: ID
  currentQuestionId: ID
  profileId: ID
  scoreRange: RangeOperator
}

scalar UUID

enum VideoZoomRole {
  HOST
  PARTICIPANT
}

enum WeeklyWeightGoal {
  GOAL_0_5
  GOAL_1
  GOAL_1_0
  GOAL_1_5
  GOAL_2
  GOAL_2_0
  GOAL_3
  GOAL_4
  MAINTAIN
  MANTAIN
}

input WeightEntryInput {
  date: Date!
  source: SourceType
  value: PositiveFloat!
}

type WeightTracker {
  entries: [Entry]
  latestEntry: DateTime
  start: Float
  tendency: Tendency
  today: Float
}

type WellnessProfileResponse {
  message: String!
  profile: WellnessProfileType
  success: Boolean!
}

type WellnessProfileType {
  activityLevel: String
  age: Int
  biologicalSex: String
  birthdate: Date
  dailyCaloricIntakeGoal: Int
  hasOnboarded: Boolean!
  height: Float
  id: ID
  phone: String
  programName: String
  restrictions: [Restriction]
  startingWeight: Float
  targetWeight: Float
  weight: Float
}

type WellnessScoreLastSevenDays {
  dailyStreakScore: [DailyStreakScore!]
  wellnessScore: Float!
}

type ZoomParticipantAudioFile {
  downloadUrl: String!
  fileExtension: String!
  fileName: String!
  fileSize: Int!
  fileType: String!
  id: String!
  recordingEnd: String!
  recordingStart: String!
  status: String!
}

type ZoomParticipantVideoFile {
  downloadUrl: String!
  fileExtension: String!
  fileName: String!
  fileSize: Int!
  fileType: String!
  id: String!
  recordingEnd: String!
  recordingStart: String!
  recordingType: String!
  status: String!
}

type ZoomRecodingFile {
  deletedTime: String
  downloadUrl: String!
  fileExtension: String!
  fileSize: Float!
  fileType: String!
  id: String!
  recordingEnd: String!
  recordingStart: String!
  recordingType: String!
  status: String!
}

type ZoomRecording {
  downloadAccessToken: String
  duration: Int!
  participantAudioFiles: [ZoomParticipantAudioFile!]
  participantVideoFiles: [ZoomParticipantVideoFile!]
  recordingCount: Int!
  recordingFiles: [ZoomRecodingFile!]
  sessionId: String!
  sessionName: String!
  startTime: String!
  timezone: String
  totalSize: Int!
}

type ZoomRecordingConnection {
  edges: [ZoomRecordingEdge]!
  pageInfo: PageInfo!
}

type ZoomRecordingEdge {
  cursor: String!
  node: ZoomRecording
}

